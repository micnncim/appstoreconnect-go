/*
App Store Connect API

No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)

API version: 3.0
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package appstoreconnect

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"strings"
)

// AppInfosApiService AppInfosApi service
type AppInfosApiService service

type ApiAppInfosAgeRatingDeclarationGetToOneRelatedRequest struct {
	ctx                         context.Context
	ApiService                  *AppInfosApiService
	id                          string
	fieldsAgeRatingDeclarations *[]string
}

// the fields to include for returned resources of type ageRatingDeclarations
func (r ApiAppInfosAgeRatingDeclarationGetToOneRelatedRequest) FieldsAgeRatingDeclarations(fieldsAgeRatingDeclarations []string) ApiAppInfosAgeRatingDeclarationGetToOneRelatedRequest {
	r.fieldsAgeRatingDeclarations = &fieldsAgeRatingDeclarations
	return r
}

func (r ApiAppInfosAgeRatingDeclarationGetToOneRelatedRequest) Execute() (*AgeRatingDeclarationResponse, *http.Response, error) {
	return r.ApiService.AppInfosAgeRatingDeclarationGetToOneRelatedExecute(r)
}

/*
AppInfosAgeRatingDeclarationGetToOneRelated Method for AppInfosAgeRatingDeclarationGetToOneRelated

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id the id of the requested resource
	@return ApiAppInfosAgeRatingDeclarationGetToOneRelatedRequest
*/
func (a *AppInfosApiService) AppInfosAgeRatingDeclarationGetToOneRelated(ctx context.Context, id string) ApiAppInfosAgeRatingDeclarationGetToOneRelatedRequest {
	return ApiAppInfosAgeRatingDeclarationGetToOneRelatedRequest{
		ApiService: a,
		ctx:        ctx,
		id:         id,
	}
}

// Execute executes the request
//
//	@return AgeRatingDeclarationResponse
func (a *AppInfosApiService) AppInfosAgeRatingDeclarationGetToOneRelatedExecute(r ApiAppInfosAgeRatingDeclarationGetToOneRelatedRequest) (*AgeRatingDeclarationResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *AgeRatingDeclarationResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AppInfosApiService.AppInfosAgeRatingDeclarationGetToOneRelated")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/appInfos/{id}/ageRatingDeclaration"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.fieldsAgeRatingDeclarations != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields[ageRatingDeclarations]", r.fieldsAgeRatingDeclarations, "csv")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiAppInfosAppInfoLocalizationsGetToManyRelatedRequest struct {
	ctx                        context.Context
	ApiService                 *AppInfosApiService
	id                         string
	filterLocale               *[]string
	fieldsAppInfos             *[]string
	fieldsAppInfoLocalizations *[]string
	limit                      *int32
	include                    *[]string
}

// filter by attribute &#39;locale&#39;
func (r ApiAppInfosAppInfoLocalizationsGetToManyRelatedRequest) FilterLocale(filterLocale []string) ApiAppInfosAppInfoLocalizationsGetToManyRelatedRequest {
	r.filterLocale = &filterLocale
	return r
}

// the fields to include for returned resources of type appInfos
func (r ApiAppInfosAppInfoLocalizationsGetToManyRelatedRequest) FieldsAppInfos(fieldsAppInfos []string) ApiAppInfosAppInfoLocalizationsGetToManyRelatedRequest {
	r.fieldsAppInfos = &fieldsAppInfos
	return r
}

// the fields to include for returned resources of type appInfoLocalizations
func (r ApiAppInfosAppInfoLocalizationsGetToManyRelatedRequest) FieldsAppInfoLocalizations(fieldsAppInfoLocalizations []string) ApiAppInfosAppInfoLocalizationsGetToManyRelatedRequest {
	r.fieldsAppInfoLocalizations = &fieldsAppInfoLocalizations
	return r
}

// maximum resources per page
func (r ApiAppInfosAppInfoLocalizationsGetToManyRelatedRequest) Limit(limit int32) ApiAppInfosAppInfoLocalizationsGetToManyRelatedRequest {
	r.limit = &limit
	return r
}

// comma-separated list of relationships to include
func (r ApiAppInfosAppInfoLocalizationsGetToManyRelatedRequest) Include(include []string) ApiAppInfosAppInfoLocalizationsGetToManyRelatedRequest {
	r.include = &include
	return r
}

func (r ApiAppInfosAppInfoLocalizationsGetToManyRelatedRequest) Execute() (*AppInfoLocalizationsResponse, *http.Response, error) {
	return r.ApiService.AppInfosAppInfoLocalizationsGetToManyRelatedExecute(r)
}

/*
AppInfosAppInfoLocalizationsGetToManyRelated Method for AppInfosAppInfoLocalizationsGetToManyRelated

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id the id of the requested resource
	@return ApiAppInfosAppInfoLocalizationsGetToManyRelatedRequest
*/
func (a *AppInfosApiService) AppInfosAppInfoLocalizationsGetToManyRelated(ctx context.Context, id string) ApiAppInfosAppInfoLocalizationsGetToManyRelatedRequest {
	return ApiAppInfosAppInfoLocalizationsGetToManyRelatedRequest{
		ApiService: a,
		ctx:        ctx,
		id:         id,
	}
}

// Execute executes the request
//
//	@return AppInfoLocalizationsResponse
func (a *AppInfosApiService) AppInfosAppInfoLocalizationsGetToManyRelatedExecute(r ApiAppInfosAppInfoLocalizationsGetToManyRelatedRequest) (*AppInfoLocalizationsResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *AppInfoLocalizationsResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AppInfosApiService.AppInfosAppInfoLocalizationsGetToManyRelated")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/appInfos/{id}/appInfoLocalizations"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.filterLocale != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter[locale]", r.filterLocale, "csv")
	}
	if r.fieldsAppInfos != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields[appInfos]", r.fieldsAppInfos, "csv")
	}
	if r.fieldsAppInfoLocalizations != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields[appInfoLocalizations]", r.fieldsAppInfoLocalizations, "csv")
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "")
	}
	if r.include != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "include", r.include, "csv")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiAppInfosGetInstanceRequest struct {
	ctx                         context.Context
	ApiService                  *AppInfosApiService
	id                          string
	fieldsAppInfos              *[]string
	include                     *[]string
	fieldsAgeRatingDeclarations *[]string
	fieldsAppInfoLocalizations  *[]string
	fieldsAppCategories         *[]string
	limitAppInfoLocalizations   *int32
}

// the fields to include for returned resources of type appInfos
func (r ApiAppInfosGetInstanceRequest) FieldsAppInfos(fieldsAppInfos []string) ApiAppInfosGetInstanceRequest {
	r.fieldsAppInfos = &fieldsAppInfos
	return r
}

// comma-separated list of relationships to include
func (r ApiAppInfosGetInstanceRequest) Include(include []string) ApiAppInfosGetInstanceRequest {
	r.include = &include
	return r
}

// the fields to include for returned resources of type ageRatingDeclarations
func (r ApiAppInfosGetInstanceRequest) FieldsAgeRatingDeclarations(fieldsAgeRatingDeclarations []string) ApiAppInfosGetInstanceRequest {
	r.fieldsAgeRatingDeclarations = &fieldsAgeRatingDeclarations
	return r
}

// the fields to include for returned resources of type appInfoLocalizations
func (r ApiAppInfosGetInstanceRequest) FieldsAppInfoLocalizations(fieldsAppInfoLocalizations []string) ApiAppInfosGetInstanceRequest {
	r.fieldsAppInfoLocalizations = &fieldsAppInfoLocalizations
	return r
}

// the fields to include for returned resources of type appCategories
func (r ApiAppInfosGetInstanceRequest) FieldsAppCategories(fieldsAppCategories []string) ApiAppInfosGetInstanceRequest {
	r.fieldsAppCategories = &fieldsAppCategories
	return r
}

// maximum number of related appInfoLocalizations returned (when they are included)
func (r ApiAppInfosGetInstanceRequest) LimitAppInfoLocalizations(limitAppInfoLocalizations int32) ApiAppInfosGetInstanceRequest {
	r.limitAppInfoLocalizations = &limitAppInfoLocalizations
	return r
}

func (r ApiAppInfosGetInstanceRequest) Execute() (*AppInfoResponse, *http.Response, error) {
	return r.ApiService.AppInfosGetInstanceExecute(r)
}

/*
AppInfosGetInstance Method for AppInfosGetInstance

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id the id of the requested resource
	@return ApiAppInfosGetInstanceRequest
*/
func (a *AppInfosApiService) AppInfosGetInstance(ctx context.Context, id string) ApiAppInfosGetInstanceRequest {
	return ApiAppInfosGetInstanceRequest{
		ApiService: a,
		ctx:        ctx,
		id:         id,
	}
}

// Execute executes the request
//
//	@return AppInfoResponse
func (a *AppInfosApiService) AppInfosGetInstanceExecute(r ApiAppInfosGetInstanceRequest) (*AppInfoResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *AppInfoResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AppInfosApiService.AppInfosGetInstance")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/appInfos/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.fieldsAppInfos != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields[appInfos]", r.fieldsAppInfos, "csv")
	}
	if r.include != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "include", r.include, "csv")
	}
	if r.fieldsAgeRatingDeclarations != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields[ageRatingDeclarations]", r.fieldsAgeRatingDeclarations, "csv")
	}
	if r.fieldsAppInfoLocalizations != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields[appInfoLocalizations]", r.fieldsAppInfoLocalizations, "csv")
	}
	if r.fieldsAppCategories != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields[appCategories]", r.fieldsAppCategories, "csv")
	}
	if r.limitAppInfoLocalizations != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit[appInfoLocalizations]", r.limitAppInfoLocalizations, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiAppInfosPrimaryCategoryGetToOneRelatedRequest struct {
	ctx                 context.Context
	ApiService          *AppInfosApiService
	id                  string
	fieldsAppCategories *[]string
	limitSubcategories  *int32
	include             *[]string
}

// the fields to include for returned resources of type appCategories
func (r ApiAppInfosPrimaryCategoryGetToOneRelatedRequest) FieldsAppCategories(fieldsAppCategories []string) ApiAppInfosPrimaryCategoryGetToOneRelatedRequest {
	r.fieldsAppCategories = &fieldsAppCategories
	return r
}

// maximum number of related subcategories returned (when they are included)
func (r ApiAppInfosPrimaryCategoryGetToOneRelatedRequest) LimitSubcategories(limitSubcategories int32) ApiAppInfosPrimaryCategoryGetToOneRelatedRequest {
	r.limitSubcategories = &limitSubcategories
	return r
}

// comma-separated list of relationships to include
func (r ApiAppInfosPrimaryCategoryGetToOneRelatedRequest) Include(include []string) ApiAppInfosPrimaryCategoryGetToOneRelatedRequest {
	r.include = &include
	return r
}

func (r ApiAppInfosPrimaryCategoryGetToOneRelatedRequest) Execute() (*AppCategoryResponse, *http.Response, error) {
	return r.ApiService.AppInfosPrimaryCategoryGetToOneRelatedExecute(r)
}

/*
AppInfosPrimaryCategoryGetToOneRelated Method for AppInfosPrimaryCategoryGetToOneRelated

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id the id of the requested resource
	@return ApiAppInfosPrimaryCategoryGetToOneRelatedRequest
*/
func (a *AppInfosApiService) AppInfosPrimaryCategoryGetToOneRelated(ctx context.Context, id string) ApiAppInfosPrimaryCategoryGetToOneRelatedRequest {
	return ApiAppInfosPrimaryCategoryGetToOneRelatedRequest{
		ApiService: a,
		ctx:        ctx,
		id:         id,
	}
}

// Execute executes the request
//
//	@return AppCategoryResponse
func (a *AppInfosApiService) AppInfosPrimaryCategoryGetToOneRelatedExecute(r ApiAppInfosPrimaryCategoryGetToOneRelatedRequest) (*AppCategoryResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *AppCategoryResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AppInfosApiService.AppInfosPrimaryCategoryGetToOneRelated")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/appInfos/{id}/primaryCategory"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.fieldsAppCategories != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields[appCategories]", r.fieldsAppCategories, "csv")
	}
	if r.limitSubcategories != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit[subcategories]", r.limitSubcategories, "")
	}
	if r.include != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "include", r.include, "csv")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiAppInfosPrimarySubcategoryOneGetToOneRelatedRequest struct {
	ctx                 context.Context
	ApiService          *AppInfosApiService
	id                  string
	fieldsAppCategories *[]string
	limitSubcategories  *int32
	include             *[]string
}

// the fields to include for returned resources of type appCategories
func (r ApiAppInfosPrimarySubcategoryOneGetToOneRelatedRequest) FieldsAppCategories(fieldsAppCategories []string) ApiAppInfosPrimarySubcategoryOneGetToOneRelatedRequest {
	r.fieldsAppCategories = &fieldsAppCategories
	return r
}

// maximum number of related subcategories returned (when they are included)
func (r ApiAppInfosPrimarySubcategoryOneGetToOneRelatedRequest) LimitSubcategories(limitSubcategories int32) ApiAppInfosPrimarySubcategoryOneGetToOneRelatedRequest {
	r.limitSubcategories = &limitSubcategories
	return r
}

// comma-separated list of relationships to include
func (r ApiAppInfosPrimarySubcategoryOneGetToOneRelatedRequest) Include(include []string) ApiAppInfosPrimarySubcategoryOneGetToOneRelatedRequest {
	r.include = &include
	return r
}

func (r ApiAppInfosPrimarySubcategoryOneGetToOneRelatedRequest) Execute() (*AppCategoryResponse, *http.Response, error) {
	return r.ApiService.AppInfosPrimarySubcategoryOneGetToOneRelatedExecute(r)
}

/*
AppInfosPrimarySubcategoryOneGetToOneRelated Method for AppInfosPrimarySubcategoryOneGetToOneRelated

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id the id of the requested resource
	@return ApiAppInfosPrimarySubcategoryOneGetToOneRelatedRequest
*/
func (a *AppInfosApiService) AppInfosPrimarySubcategoryOneGetToOneRelated(ctx context.Context, id string) ApiAppInfosPrimarySubcategoryOneGetToOneRelatedRequest {
	return ApiAppInfosPrimarySubcategoryOneGetToOneRelatedRequest{
		ApiService: a,
		ctx:        ctx,
		id:         id,
	}
}

// Execute executes the request
//
//	@return AppCategoryResponse
func (a *AppInfosApiService) AppInfosPrimarySubcategoryOneGetToOneRelatedExecute(r ApiAppInfosPrimarySubcategoryOneGetToOneRelatedRequest) (*AppCategoryResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *AppCategoryResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AppInfosApiService.AppInfosPrimarySubcategoryOneGetToOneRelated")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/appInfos/{id}/primarySubcategoryOne"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.fieldsAppCategories != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields[appCategories]", r.fieldsAppCategories, "csv")
	}
	if r.limitSubcategories != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit[subcategories]", r.limitSubcategories, "")
	}
	if r.include != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "include", r.include, "csv")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiAppInfosPrimarySubcategoryTwoGetToOneRelatedRequest struct {
	ctx                 context.Context
	ApiService          *AppInfosApiService
	id                  string
	fieldsAppCategories *[]string
	limitSubcategories  *int32
	include             *[]string
}

// the fields to include for returned resources of type appCategories
func (r ApiAppInfosPrimarySubcategoryTwoGetToOneRelatedRequest) FieldsAppCategories(fieldsAppCategories []string) ApiAppInfosPrimarySubcategoryTwoGetToOneRelatedRequest {
	r.fieldsAppCategories = &fieldsAppCategories
	return r
}

// maximum number of related subcategories returned (when they are included)
func (r ApiAppInfosPrimarySubcategoryTwoGetToOneRelatedRequest) LimitSubcategories(limitSubcategories int32) ApiAppInfosPrimarySubcategoryTwoGetToOneRelatedRequest {
	r.limitSubcategories = &limitSubcategories
	return r
}

// comma-separated list of relationships to include
func (r ApiAppInfosPrimarySubcategoryTwoGetToOneRelatedRequest) Include(include []string) ApiAppInfosPrimarySubcategoryTwoGetToOneRelatedRequest {
	r.include = &include
	return r
}

func (r ApiAppInfosPrimarySubcategoryTwoGetToOneRelatedRequest) Execute() (*AppCategoryResponse, *http.Response, error) {
	return r.ApiService.AppInfosPrimarySubcategoryTwoGetToOneRelatedExecute(r)
}

/*
AppInfosPrimarySubcategoryTwoGetToOneRelated Method for AppInfosPrimarySubcategoryTwoGetToOneRelated

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id the id of the requested resource
	@return ApiAppInfosPrimarySubcategoryTwoGetToOneRelatedRequest
*/
func (a *AppInfosApiService) AppInfosPrimarySubcategoryTwoGetToOneRelated(ctx context.Context, id string) ApiAppInfosPrimarySubcategoryTwoGetToOneRelatedRequest {
	return ApiAppInfosPrimarySubcategoryTwoGetToOneRelatedRequest{
		ApiService: a,
		ctx:        ctx,
		id:         id,
	}
}

// Execute executes the request
//
//	@return AppCategoryResponse
func (a *AppInfosApiService) AppInfosPrimarySubcategoryTwoGetToOneRelatedExecute(r ApiAppInfosPrimarySubcategoryTwoGetToOneRelatedRequest) (*AppCategoryResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *AppCategoryResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AppInfosApiService.AppInfosPrimarySubcategoryTwoGetToOneRelated")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/appInfos/{id}/primarySubcategoryTwo"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.fieldsAppCategories != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields[appCategories]", r.fieldsAppCategories, "csv")
	}
	if r.limitSubcategories != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit[subcategories]", r.limitSubcategories, "")
	}
	if r.include != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "include", r.include, "csv")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiAppInfosSecondaryCategoryGetToOneRelatedRequest struct {
	ctx                 context.Context
	ApiService          *AppInfosApiService
	id                  string
	fieldsAppCategories *[]string
	limitSubcategories  *int32
	include             *[]string
}

// the fields to include for returned resources of type appCategories
func (r ApiAppInfosSecondaryCategoryGetToOneRelatedRequest) FieldsAppCategories(fieldsAppCategories []string) ApiAppInfosSecondaryCategoryGetToOneRelatedRequest {
	r.fieldsAppCategories = &fieldsAppCategories
	return r
}

// maximum number of related subcategories returned (when they are included)
func (r ApiAppInfosSecondaryCategoryGetToOneRelatedRequest) LimitSubcategories(limitSubcategories int32) ApiAppInfosSecondaryCategoryGetToOneRelatedRequest {
	r.limitSubcategories = &limitSubcategories
	return r
}

// comma-separated list of relationships to include
func (r ApiAppInfosSecondaryCategoryGetToOneRelatedRequest) Include(include []string) ApiAppInfosSecondaryCategoryGetToOneRelatedRequest {
	r.include = &include
	return r
}

func (r ApiAppInfosSecondaryCategoryGetToOneRelatedRequest) Execute() (*AppCategoryResponse, *http.Response, error) {
	return r.ApiService.AppInfosSecondaryCategoryGetToOneRelatedExecute(r)
}

/*
AppInfosSecondaryCategoryGetToOneRelated Method for AppInfosSecondaryCategoryGetToOneRelated

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id the id of the requested resource
	@return ApiAppInfosSecondaryCategoryGetToOneRelatedRequest
*/
func (a *AppInfosApiService) AppInfosSecondaryCategoryGetToOneRelated(ctx context.Context, id string) ApiAppInfosSecondaryCategoryGetToOneRelatedRequest {
	return ApiAppInfosSecondaryCategoryGetToOneRelatedRequest{
		ApiService: a,
		ctx:        ctx,
		id:         id,
	}
}

// Execute executes the request
//
//	@return AppCategoryResponse
func (a *AppInfosApiService) AppInfosSecondaryCategoryGetToOneRelatedExecute(r ApiAppInfosSecondaryCategoryGetToOneRelatedRequest) (*AppCategoryResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *AppCategoryResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AppInfosApiService.AppInfosSecondaryCategoryGetToOneRelated")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/appInfos/{id}/secondaryCategory"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.fieldsAppCategories != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields[appCategories]", r.fieldsAppCategories, "csv")
	}
	if r.limitSubcategories != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit[subcategories]", r.limitSubcategories, "")
	}
	if r.include != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "include", r.include, "csv")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiAppInfosSecondarySubcategoryOneGetToOneRelatedRequest struct {
	ctx                 context.Context
	ApiService          *AppInfosApiService
	id                  string
	fieldsAppCategories *[]string
	limitSubcategories  *int32
	include             *[]string
}

// the fields to include for returned resources of type appCategories
func (r ApiAppInfosSecondarySubcategoryOneGetToOneRelatedRequest) FieldsAppCategories(fieldsAppCategories []string) ApiAppInfosSecondarySubcategoryOneGetToOneRelatedRequest {
	r.fieldsAppCategories = &fieldsAppCategories
	return r
}

// maximum number of related subcategories returned (when they are included)
func (r ApiAppInfosSecondarySubcategoryOneGetToOneRelatedRequest) LimitSubcategories(limitSubcategories int32) ApiAppInfosSecondarySubcategoryOneGetToOneRelatedRequest {
	r.limitSubcategories = &limitSubcategories
	return r
}

// comma-separated list of relationships to include
func (r ApiAppInfosSecondarySubcategoryOneGetToOneRelatedRequest) Include(include []string) ApiAppInfosSecondarySubcategoryOneGetToOneRelatedRequest {
	r.include = &include
	return r
}

func (r ApiAppInfosSecondarySubcategoryOneGetToOneRelatedRequest) Execute() (*AppCategoryResponse, *http.Response, error) {
	return r.ApiService.AppInfosSecondarySubcategoryOneGetToOneRelatedExecute(r)
}

/*
AppInfosSecondarySubcategoryOneGetToOneRelated Method for AppInfosSecondarySubcategoryOneGetToOneRelated

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id the id of the requested resource
	@return ApiAppInfosSecondarySubcategoryOneGetToOneRelatedRequest
*/
func (a *AppInfosApiService) AppInfosSecondarySubcategoryOneGetToOneRelated(ctx context.Context, id string) ApiAppInfosSecondarySubcategoryOneGetToOneRelatedRequest {
	return ApiAppInfosSecondarySubcategoryOneGetToOneRelatedRequest{
		ApiService: a,
		ctx:        ctx,
		id:         id,
	}
}

// Execute executes the request
//
//	@return AppCategoryResponse
func (a *AppInfosApiService) AppInfosSecondarySubcategoryOneGetToOneRelatedExecute(r ApiAppInfosSecondarySubcategoryOneGetToOneRelatedRequest) (*AppCategoryResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *AppCategoryResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AppInfosApiService.AppInfosSecondarySubcategoryOneGetToOneRelated")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/appInfos/{id}/secondarySubcategoryOne"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.fieldsAppCategories != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields[appCategories]", r.fieldsAppCategories, "csv")
	}
	if r.limitSubcategories != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit[subcategories]", r.limitSubcategories, "")
	}
	if r.include != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "include", r.include, "csv")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiAppInfosSecondarySubcategoryTwoGetToOneRelatedRequest struct {
	ctx                 context.Context
	ApiService          *AppInfosApiService
	id                  string
	fieldsAppCategories *[]string
	limitSubcategories  *int32
	include             *[]string
}

// the fields to include for returned resources of type appCategories
func (r ApiAppInfosSecondarySubcategoryTwoGetToOneRelatedRequest) FieldsAppCategories(fieldsAppCategories []string) ApiAppInfosSecondarySubcategoryTwoGetToOneRelatedRequest {
	r.fieldsAppCategories = &fieldsAppCategories
	return r
}

// maximum number of related subcategories returned (when they are included)
func (r ApiAppInfosSecondarySubcategoryTwoGetToOneRelatedRequest) LimitSubcategories(limitSubcategories int32) ApiAppInfosSecondarySubcategoryTwoGetToOneRelatedRequest {
	r.limitSubcategories = &limitSubcategories
	return r
}

// comma-separated list of relationships to include
func (r ApiAppInfosSecondarySubcategoryTwoGetToOneRelatedRequest) Include(include []string) ApiAppInfosSecondarySubcategoryTwoGetToOneRelatedRequest {
	r.include = &include
	return r
}

func (r ApiAppInfosSecondarySubcategoryTwoGetToOneRelatedRequest) Execute() (*AppCategoryResponse, *http.Response, error) {
	return r.ApiService.AppInfosSecondarySubcategoryTwoGetToOneRelatedExecute(r)
}

/*
AppInfosSecondarySubcategoryTwoGetToOneRelated Method for AppInfosSecondarySubcategoryTwoGetToOneRelated

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id the id of the requested resource
	@return ApiAppInfosSecondarySubcategoryTwoGetToOneRelatedRequest
*/
func (a *AppInfosApiService) AppInfosSecondarySubcategoryTwoGetToOneRelated(ctx context.Context, id string) ApiAppInfosSecondarySubcategoryTwoGetToOneRelatedRequest {
	return ApiAppInfosSecondarySubcategoryTwoGetToOneRelatedRequest{
		ApiService: a,
		ctx:        ctx,
		id:         id,
	}
}

// Execute executes the request
//
//	@return AppCategoryResponse
func (a *AppInfosApiService) AppInfosSecondarySubcategoryTwoGetToOneRelatedExecute(r ApiAppInfosSecondarySubcategoryTwoGetToOneRelatedRequest) (*AppCategoryResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *AppCategoryResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AppInfosApiService.AppInfosSecondarySubcategoryTwoGetToOneRelated")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/appInfos/{id}/secondarySubcategoryTwo"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.fieldsAppCategories != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields[appCategories]", r.fieldsAppCategories, "csv")
	}
	if r.limitSubcategories != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit[subcategories]", r.limitSubcategories, "")
	}
	if r.include != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "include", r.include, "csv")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiAppInfosUpdateInstanceRequest struct {
	ctx                  context.Context
	ApiService           *AppInfosApiService
	id                   string
	appInfoUpdateRequest *AppInfoUpdateRequest
}

// AppInfo representation
func (r ApiAppInfosUpdateInstanceRequest) AppInfoUpdateRequest(appInfoUpdateRequest AppInfoUpdateRequest) ApiAppInfosUpdateInstanceRequest {
	r.appInfoUpdateRequest = &appInfoUpdateRequest
	return r
}

func (r ApiAppInfosUpdateInstanceRequest) Execute() (*AppInfoResponse, *http.Response, error) {
	return r.ApiService.AppInfosUpdateInstanceExecute(r)
}

/*
AppInfosUpdateInstance Method for AppInfosUpdateInstance

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id the id of the requested resource
	@return ApiAppInfosUpdateInstanceRequest
*/
func (a *AppInfosApiService) AppInfosUpdateInstance(ctx context.Context, id string) ApiAppInfosUpdateInstanceRequest {
	return ApiAppInfosUpdateInstanceRequest{
		ApiService: a,
		ctx:        ctx,
		id:         id,
	}
}

// Execute executes the request
//
//	@return AppInfoResponse
func (a *AppInfosApiService) AppInfosUpdateInstanceExecute(r ApiAppInfosUpdateInstanceRequest) (*AppInfoResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPatch
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *AppInfoResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AppInfosApiService.AppInfosUpdateInstance")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/appInfos/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.appInfoUpdateRequest == nil {
		return localVarReturnValue, nil, reportError("appInfoUpdateRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.appInfoUpdateRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 409 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
