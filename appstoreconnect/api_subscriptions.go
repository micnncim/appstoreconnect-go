/*
App Store Connect API

No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)

API version: 3.0
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package appstoreconnect

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"strings"
)

// SubscriptionsApiService SubscriptionsApi service
type SubscriptionsApiService service

type ApiSubscriptionsAppStoreReviewScreenshotGetToOneRelatedRequest struct {
	ctx                                         context.Context
	ApiService                                  *SubscriptionsApiService
	id                                          string
	fieldsSubscriptionAppStoreReviewScreenshots *[]string
	fieldsSubscriptions                         *[]string
	include                                     *[]string
}

// the fields to include for returned resources of type subscriptionAppStoreReviewScreenshots
func (r ApiSubscriptionsAppStoreReviewScreenshotGetToOneRelatedRequest) FieldsSubscriptionAppStoreReviewScreenshots(fieldsSubscriptionAppStoreReviewScreenshots []string) ApiSubscriptionsAppStoreReviewScreenshotGetToOneRelatedRequest {
	r.fieldsSubscriptionAppStoreReviewScreenshots = &fieldsSubscriptionAppStoreReviewScreenshots
	return r
}

// the fields to include for returned resources of type subscriptions
func (r ApiSubscriptionsAppStoreReviewScreenshotGetToOneRelatedRequest) FieldsSubscriptions(fieldsSubscriptions []string) ApiSubscriptionsAppStoreReviewScreenshotGetToOneRelatedRequest {
	r.fieldsSubscriptions = &fieldsSubscriptions
	return r
}

// comma-separated list of relationships to include
func (r ApiSubscriptionsAppStoreReviewScreenshotGetToOneRelatedRequest) Include(include []string) ApiSubscriptionsAppStoreReviewScreenshotGetToOneRelatedRequest {
	r.include = &include
	return r
}

func (r ApiSubscriptionsAppStoreReviewScreenshotGetToOneRelatedRequest) Execute() (*SubscriptionAppStoreReviewScreenshotResponse, *http.Response, error) {
	return r.ApiService.SubscriptionsAppStoreReviewScreenshotGetToOneRelatedExecute(r)
}

/*
SubscriptionsAppStoreReviewScreenshotGetToOneRelated Method for SubscriptionsAppStoreReviewScreenshotGetToOneRelated

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id the id of the requested resource
	@return ApiSubscriptionsAppStoreReviewScreenshotGetToOneRelatedRequest
*/
func (a *SubscriptionsApiService) SubscriptionsAppStoreReviewScreenshotGetToOneRelated(ctx context.Context, id string) ApiSubscriptionsAppStoreReviewScreenshotGetToOneRelatedRequest {
	return ApiSubscriptionsAppStoreReviewScreenshotGetToOneRelatedRequest{
		ApiService: a,
		ctx:        ctx,
		id:         id,
	}
}

// Execute executes the request
//
//	@return SubscriptionAppStoreReviewScreenshotResponse
func (a *SubscriptionsApiService) SubscriptionsAppStoreReviewScreenshotGetToOneRelatedExecute(r ApiSubscriptionsAppStoreReviewScreenshotGetToOneRelatedRequest) (*SubscriptionAppStoreReviewScreenshotResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *SubscriptionAppStoreReviewScreenshotResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SubscriptionsApiService.SubscriptionsAppStoreReviewScreenshotGetToOneRelated")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/subscriptions/{id}/appStoreReviewScreenshot"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.fieldsSubscriptionAppStoreReviewScreenshots != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields[subscriptionAppStoreReviewScreenshots]", r.fieldsSubscriptionAppStoreReviewScreenshots, "csv")
	}
	if r.fieldsSubscriptions != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields[subscriptions]", r.fieldsSubscriptions, "csv")
	}
	if r.include != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "include", r.include, "csv")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSubscriptionsCreateInstanceRequest struct {
	ctx                       context.Context
	ApiService                *SubscriptionsApiService
	subscriptionCreateRequest *SubscriptionCreateRequest
}

// Subscription representation
func (r ApiSubscriptionsCreateInstanceRequest) SubscriptionCreateRequest(subscriptionCreateRequest SubscriptionCreateRequest) ApiSubscriptionsCreateInstanceRequest {
	r.subscriptionCreateRequest = &subscriptionCreateRequest
	return r
}

func (r ApiSubscriptionsCreateInstanceRequest) Execute() (*SubscriptionResponse, *http.Response, error) {
	return r.ApiService.SubscriptionsCreateInstanceExecute(r)
}

/*
SubscriptionsCreateInstance Method for SubscriptionsCreateInstance

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiSubscriptionsCreateInstanceRequest
*/
func (a *SubscriptionsApiService) SubscriptionsCreateInstance(ctx context.Context) ApiSubscriptionsCreateInstanceRequest {
	return ApiSubscriptionsCreateInstanceRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return SubscriptionResponse
func (a *SubscriptionsApiService) SubscriptionsCreateInstanceExecute(r ApiSubscriptionsCreateInstanceRequest) (*SubscriptionResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *SubscriptionResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SubscriptionsApiService.SubscriptionsCreateInstance")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/subscriptions"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.subscriptionCreateRequest == nil {
		return localVarReturnValue, nil, reportError("subscriptionCreateRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.subscriptionCreateRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 409 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSubscriptionsDeleteInstanceRequest struct {
	ctx        context.Context
	ApiService *SubscriptionsApiService
	id         string
}

func (r ApiSubscriptionsDeleteInstanceRequest) Execute() (*http.Response, error) {
	return r.ApiService.SubscriptionsDeleteInstanceExecute(r)
}

/*
SubscriptionsDeleteInstance Method for SubscriptionsDeleteInstance

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id the id of the requested resource
	@return ApiSubscriptionsDeleteInstanceRequest
*/
func (a *SubscriptionsApiService) SubscriptionsDeleteInstance(ctx context.Context, id string) ApiSubscriptionsDeleteInstanceRequest {
	return ApiSubscriptionsDeleteInstanceRequest{
		ApiService: a,
		ctx:        ctx,
		id:         id,
	}
}

// Execute executes the request
func (a *SubscriptionsApiService) SubscriptionsDeleteInstanceExecute(r ApiSubscriptionsDeleteInstanceRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodDelete
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SubscriptionsApiService.SubscriptionsDeleteInstance")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/subscriptions/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 409 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiSubscriptionsGetInstanceRequest struct {
	ctx                                         context.Context
	ApiService                                  *SubscriptionsApiService
	id                                          string
	fieldsSubscriptions                         *[]string
	include                                     *[]string
	fieldsPromotedPurchases                     *[]string
	fieldsSubscriptionPricePoints               *[]string
	fieldsSubscriptionPromotionalOffers         *[]string
	fieldsSubscriptionOfferCodes                *[]string
	fieldsSubscriptionAppStoreReviewScreenshots *[]string
	fieldsSubscriptionAvailabilities            *[]string
	fieldsSubscriptionPrices                    *[]string
	fieldsSubscriptionIntroductoryOffers        *[]string
	fieldsSubscriptionLocalizations             *[]string
	limitIntroductoryOffers                     *int32
	limitOfferCodes                             *int32
	limitPrices                                 *int32
	limitPromotionalOffers                      *int32
	limitSubscriptionLocalizations              *int32
}

// the fields to include for returned resources of type subscriptions
func (r ApiSubscriptionsGetInstanceRequest) FieldsSubscriptions(fieldsSubscriptions []string) ApiSubscriptionsGetInstanceRequest {
	r.fieldsSubscriptions = &fieldsSubscriptions
	return r
}

// comma-separated list of relationships to include
func (r ApiSubscriptionsGetInstanceRequest) Include(include []string) ApiSubscriptionsGetInstanceRequest {
	r.include = &include
	return r
}

// the fields to include for returned resources of type promotedPurchases
func (r ApiSubscriptionsGetInstanceRequest) FieldsPromotedPurchases(fieldsPromotedPurchases []string) ApiSubscriptionsGetInstanceRequest {
	r.fieldsPromotedPurchases = &fieldsPromotedPurchases
	return r
}

// the fields to include for returned resources of type subscriptionPricePoints
func (r ApiSubscriptionsGetInstanceRequest) FieldsSubscriptionPricePoints(fieldsSubscriptionPricePoints []string) ApiSubscriptionsGetInstanceRequest {
	r.fieldsSubscriptionPricePoints = &fieldsSubscriptionPricePoints
	return r
}

// the fields to include for returned resources of type subscriptionPromotionalOffers
func (r ApiSubscriptionsGetInstanceRequest) FieldsSubscriptionPromotionalOffers(fieldsSubscriptionPromotionalOffers []string) ApiSubscriptionsGetInstanceRequest {
	r.fieldsSubscriptionPromotionalOffers = &fieldsSubscriptionPromotionalOffers
	return r
}

// the fields to include for returned resources of type subscriptionOfferCodes
func (r ApiSubscriptionsGetInstanceRequest) FieldsSubscriptionOfferCodes(fieldsSubscriptionOfferCodes []string) ApiSubscriptionsGetInstanceRequest {
	r.fieldsSubscriptionOfferCodes = &fieldsSubscriptionOfferCodes
	return r
}

// the fields to include for returned resources of type subscriptionAppStoreReviewScreenshots
func (r ApiSubscriptionsGetInstanceRequest) FieldsSubscriptionAppStoreReviewScreenshots(fieldsSubscriptionAppStoreReviewScreenshots []string) ApiSubscriptionsGetInstanceRequest {
	r.fieldsSubscriptionAppStoreReviewScreenshots = &fieldsSubscriptionAppStoreReviewScreenshots
	return r
}

// the fields to include for returned resources of type subscriptionAvailabilities
func (r ApiSubscriptionsGetInstanceRequest) FieldsSubscriptionAvailabilities(fieldsSubscriptionAvailabilities []string) ApiSubscriptionsGetInstanceRequest {
	r.fieldsSubscriptionAvailabilities = &fieldsSubscriptionAvailabilities
	return r
}

// the fields to include for returned resources of type subscriptionPrices
func (r ApiSubscriptionsGetInstanceRequest) FieldsSubscriptionPrices(fieldsSubscriptionPrices []string) ApiSubscriptionsGetInstanceRequest {
	r.fieldsSubscriptionPrices = &fieldsSubscriptionPrices
	return r
}

// the fields to include for returned resources of type subscriptionIntroductoryOffers
func (r ApiSubscriptionsGetInstanceRequest) FieldsSubscriptionIntroductoryOffers(fieldsSubscriptionIntroductoryOffers []string) ApiSubscriptionsGetInstanceRequest {
	r.fieldsSubscriptionIntroductoryOffers = &fieldsSubscriptionIntroductoryOffers
	return r
}

// the fields to include for returned resources of type subscriptionLocalizations
func (r ApiSubscriptionsGetInstanceRequest) FieldsSubscriptionLocalizations(fieldsSubscriptionLocalizations []string) ApiSubscriptionsGetInstanceRequest {
	r.fieldsSubscriptionLocalizations = &fieldsSubscriptionLocalizations
	return r
}

// maximum number of related introductoryOffers returned (when they are included)
func (r ApiSubscriptionsGetInstanceRequest) LimitIntroductoryOffers(limitIntroductoryOffers int32) ApiSubscriptionsGetInstanceRequest {
	r.limitIntroductoryOffers = &limitIntroductoryOffers
	return r
}

// maximum number of related offerCodes returned (when they are included)
func (r ApiSubscriptionsGetInstanceRequest) LimitOfferCodes(limitOfferCodes int32) ApiSubscriptionsGetInstanceRequest {
	r.limitOfferCodes = &limitOfferCodes
	return r
}

// maximum number of related prices returned (when they are included)
func (r ApiSubscriptionsGetInstanceRequest) LimitPrices(limitPrices int32) ApiSubscriptionsGetInstanceRequest {
	r.limitPrices = &limitPrices
	return r
}

// maximum number of related promotionalOffers returned (when they are included)
func (r ApiSubscriptionsGetInstanceRequest) LimitPromotionalOffers(limitPromotionalOffers int32) ApiSubscriptionsGetInstanceRequest {
	r.limitPromotionalOffers = &limitPromotionalOffers
	return r
}

// maximum number of related subscriptionLocalizations returned (when they are included)
func (r ApiSubscriptionsGetInstanceRequest) LimitSubscriptionLocalizations(limitSubscriptionLocalizations int32) ApiSubscriptionsGetInstanceRequest {
	r.limitSubscriptionLocalizations = &limitSubscriptionLocalizations
	return r
}

func (r ApiSubscriptionsGetInstanceRequest) Execute() (*SubscriptionResponse, *http.Response, error) {
	return r.ApiService.SubscriptionsGetInstanceExecute(r)
}

/*
SubscriptionsGetInstance Method for SubscriptionsGetInstance

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id the id of the requested resource
	@return ApiSubscriptionsGetInstanceRequest
*/
func (a *SubscriptionsApiService) SubscriptionsGetInstance(ctx context.Context, id string) ApiSubscriptionsGetInstanceRequest {
	return ApiSubscriptionsGetInstanceRequest{
		ApiService: a,
		ctx:        ctx,
		id:         id,
	}
}

// Execute executes the request
//
//	@return SubscriptionResponse
func (a *SubscriptionsApiService) SubscriptionsGetInstanceExecute(r ApiSubscriptionsGetInstanceRequest) (*SubscriptionResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *SubscriptionResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SubscriptionsApiService.SubscriptionsGetInstance")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/subscriptions/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.fieldsSubscriptions != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields[subscriptions]", r.fieldsSubscriptions, "csv")
	}
	if r.include != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "include", r.include, "csv")
	}
	if r.fieldsPromotedPurchases != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields[promotedPurchases]", r.fieldsPromotedPurchases, "csv")
	}
	if r.fieldsSubscriptionPricePoints != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields[subscriptionPricePoints]", r.fieldsSubscriptionPricePoints, "csv")
	}
	if r.fieldsSubscriptionPromotionalOffers != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields[subscriptionPromotionalOffers]", r.fieldsSubscriptionPromotionalOffers, "csv")
	}
	if r.fieldsSubscriptionOfferCodes != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields[subscriptionOfferCodes]", r.fieldsSubscriptionOfferCodes, "csv")
	}
	if r.fieldsSubscriptionAppStoreReviewScreenshots != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields[subscriptionAppStoreReviewScreenshots]", r.fieldsSubscriptionAppStoreReviewScreenshots, "csv")
	}
	if r.fieldsSubscriptionAvailabilities != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields[subscriptionAvailabilities]", r.fieldsSubscriptionAvailabilities, "csv")
	}
	if r.fieldsSubscriptionPrices != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields[subscriptionPrices]", r.fieldsSubscriptionPrices, "csv")
	}
	if r.fieldsSubscriptionIntroductoryOffers != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields[subscriptionIntroductoryOffers]", r.fieldsSubscriptionIntroductoryOffers, "csv")
	}
	if r.fieldsSubscriptionLocalizations != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields[subscriptionLocalizations]", r.fieldsSubscriptionLocalizations, "csv")
	}
	if r.limitIntroductoryOffers != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit[introductoryOffers]", r.limitIntroductoryOffers, "")
	}
	if r.limitOfferCodes != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit[offerCodes]", r.limitOfferCodes, "")
	}
	if r.limitPrices != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit[prices]", r.limitPrices, "")
	}
	if r.limitPromotionalOffers != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit[promotionalOffers]", r.limitPromotionalOffers, "")
	}
	if r.limitSubscriptionLocalizations != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit[subscriptionLocalizations]", r.limitSubscriptionLocalizations, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSubscriptionsIntroductoryOffersDeleteToManyRelationshipRequest struct {
	ctx                                           context.Context
	ApiService                                    *SubscriptionsApiService
	id                                            string
	subscriptionIntroductoryOffersLinkagesRequest *SubscriptionIntroductoryOffersLinkagesRequest
}

// List of related linkages
func (r ApiSubscriptionsIntroductoryOffersDeleteToManyRelationshipRequest) SubscriptionIntroductoryOffersLinkagesRequest(subscriptionIntroductoryOffersLinkagesRequest SubscriptionIntroductoryOffersLinkagesRequest) ApiSubscriptionsIntroductoryOffersDeleteToManyRelationshipRequest {
	r.subscriptionIntroductoryOffersLinkagesRequest = &subscriptionIntroductoryOffersLinkagesRequest
	return r
}

func (r ApiSubscriptionsIntroductoryOffersDeleteToManyRelationshipRequest) Execute() (*http.Response, error) {
	return r.ApiService.SubscriptionsIntroductoryOffersDeleteToManyRelationshipExecute(r)
}

/*
SubscriptionsIntroductoryOffersDeleteToManyRelationship Method for SubscriptionsIntroductoryOffersDeleteToManyRelationship

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id the id of the requested resource
	@return ApiSubscriptionsIntroductoryOffersDeleteToManyRelationshipRequest
*/
func (a *SubscriptionsApiService) SubscriptionsIntroductoryOffersDeleteToManyRelationship(ctx context.Context, id string) ApiSubscriptionsIntroductoryOffersDeleteToManyRelationshipRequest {
	return ApiSubscriptionsIntroductoryOffersDeleteToManyRelationshipRequest{
		ApiService: a,
		ctx:        ctx,
		id:         id,
	}
}

// Execute executes the request
func (a *SubscriptionsApiService) SubscriptionsIntroductoryOffersDeleteToManyRelationshipExecute(r ApiSubscriptionsIntroductoryOffersDeleteToManyRelationshipRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodDelete
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SubscriptionsApiService.SubscriptionsIntroductoryOffersDeleteToManyRelationship")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/subscriptions/{id}/relationships/introductoryOffers"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.subscriptionIntroductoryOffersLinkagesRequest == nil {
		return nil, reportError("subscriptionIntroductoryOffersLinkagesRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.subscriptionIntroductoryOffersLinkagesRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 409 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiSubscriptionsIntroductoryOffersGetToManyRelatedRequest struct {
	ctx                                  context.Context
	ApiService                           *SubscriptionsApiService
	id                                   string
	filterTerritory                      *[]string
	fieldsSubscriptionPricePoints        *[]string
	fieldsSubscriptions                  *[]string
	fieldsSubscriptionIntroductoryOffers *[]string
	fieldsTerritories                    *[]string
	limit                                *int32
	include                              *[]string
}

// filter by id(s) of related &#39;territory&#39;
func (r ApiSubscriptionsIntroductoryOffersGetToManyRelatedRequest) FilterTerritory(filterTerritory []string) ApiSubscriptionsIntroductoryOffersGetToManyRelatedRequest {
	r.filterTerritory = &filterTerritory
	return r
}

// the fields to include for returned resources of type subscriptionPricePoints
func (r ApiSubscriptionsIntroductoryOffersGetToManyRelatedRequest) FieldsSubscriptionPricePoints(fieldsSubscriptionPricePoints []string) ApiSubscriptionsIntroductoryOffersGetToManyRelatedRequest {
	r.fieldsSubscriptionPricePoints = &fieldsSubscriptionPricePoints
	return r
}

// the fields to include for returned resources of type subscriptions
func (r ApiSubscriptionsIntroductoryOffersGetToManyRelatedRequest) FieldsSubscriptions(fieldsSubscriptions []string) ApiSubscriptionsIntroductoryOffersGetToManyRelatedRequest {
	r.fieldsSubscriptions = &fieldsSubscriptions
	return r
}

// the fields to include for returned resources of type subscriptionIntroductoryOffers
func (r ApiSubscriptionsIntroductoryOffersGetToManyRelatedRequest) FieldsSubscriptionIntroductoryOffers(fieldsSubscriptionIntroductoryOffers []string) ApiSubscriptionsIntroductoryOffersGetToManyRelatedRequest {
	r.fieldsSubscriptionIntroductoryOffers = &fieldsSubscriptionIntroductoryOffers
	return r
}

// the fields to include for returned resources of type territories
func (r ApiSubscriptionsIntroductoryOffersGetToManyRelatedRequest) FieldsTerritories(fieldsTerritories []string) ApiSubscriptionsIntroductoryOffersGetToManyRelatedRequest {
	r.fieldsTerritories = &fieldsTerritories
	return r
}

// maximum resources per page
func (r ApiSubscriptionsIntroductoryOffersGetToManyRelatedRequest) Limit(limit int32) ApiSubscriptionsIntroductoryOffersGetToManyRelatedRequest {
	r.limit = &limit
	return r
}

// comma-separated list of relationships to include
func (r ApiSubscriptionsIntroductoryOffersGetToManyRelatedRequest) Include(include []string) ApiSubscriptionsIntroductoryOffersGetToManyRelatedRequest {
	r.include = &include
	return r
}

func (r ApiSubscriptionsIntroductoryOffersGetToManyRelatedRequest) Execute() (*SubscriptionIntroductoryOffersResponse, *http.Response, error) {
	return r.ApiService.SubscriptionsIntroductoryOffersGetToManyRelatedExecute(r)
}

/*
SubscriptionsIntroductoryOffersGetToManyRelated Method for SubscriptionsIntroductoryOffersGetToManyRelated

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id the id of the requested resource
	@return ApiSubscriptionsIntroductoryOffersGetToManyRelatedRequest
*/
func (a *SubscriptionsApiService) SubscriptionsIntroductoryOffersGetToManyRelated(ctx context.Context, id string) ApiSubscriptionsIntroductoryOffersGetToManyRelatedRequest {
	return ApiSubscriptionsIntroductoryOffersGetToManyRelatedRequest{
		ApiService: a,
		ctx:        ctx,
		id:         id,
	}
}

// Execute executes the request
//
//	@return SubscriptionIntroductoryOffersResponse
func (a *SubscriptionsApiService) SubscriptionsIntroductoryOffersGetToManyRelatedExecute(r ApiSubscriptionsIntroductoryOffersGetToManyRelatedRequest) (*SubscriptionIntroductoryOffersResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *SubscriptionIntroductoryOffersResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SubscriptionsApiService.SubscriptionsIntroductoryOffersGetToManyRelated")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/subscriptions/{id}/introductoryOffers"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.filterTerritory != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter[territory]", r.filterTerritory, "csv")
	}
	if r.fieldsSubscriptionPricePoints != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields[subscriptionPricePoints]", r.fieldsSubscriptionPricePoints, "csv")
	}
	if r.fieldsSubscriptions != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields[subscriptions]", r.fieldsSubscriptions, "csv")
	}
	if r.fieldsSubscriptionIntroductoryOffers != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields[subscriptionIntroductoryOffers]", r.fieldsSubscriptionIntroductoryOffers, "csv")
	}
	if r.fieldsTerritories != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields[territories]", r.fieldsTerritories, "csv")
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "")
	}
	if r.include != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "include", r.include, "csv")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSubscriptionsIntroductoryOffersGetToManyRelationshipRequest struct {
	ctx        context.Context
	ApiService *SubscriptionsApiService
	id         string
	limit      *int32
}

// maximum resources per page
func (r ApiSubscriptionsIntroductoryOffersGetToManyRelationshipRequest) Limit(limit int32) ApiSubscriptionsIntroductoryOffersGetToManyRelationshipRequest {
	r.limit = &limit
	return r
}

func (r ApiSubscriptionsIntroductoryOffersGetToManyRelationshipRequest) Execute() (*SubscriptionIntroductoryOffersLinkagesResponse, *http.Response, error) {
	return r.ApiService.SubscriptionsIntroductoryOffersGetToManyRelationshipExecute(r)
}

/*
SubscriptionsIntroductoryOffersGetToManyRelationship Method for SubscriptionsIntroductoryOffersGetToManyRelationship

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id the id of the requested resource
	@return ApiSubscriptionsIntroductoryOffersGetToManyRelationshipRequest
*/
func (a *SubscriptionsApiService) SubscriptionsIntroductoryOffersGetToManyRelationship(ctx context.Context, id string) ApiSubscriptionsIntroductoryOffersGetToManyRelationshipRequest {
	return ApiSubscriptionsIntroductoryOffersGetToManyRelationshipRequest{
		ApiService: a,
		ctx:        ctx,
		id:         id,
	}
}

// Execute executes the request
//
//	@return SubscriptionIntroductoryOffersLinkagesResponse
func (a *SubscriptionsApiService) SubscriptionsIntroductoryOffersGetToManyRelationshipExecute(r ApiSubscriptionsIntroductoryOffersGetToManyRelationshipRequest) (*SubscriptionIntroductoryOffersLinkagesResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *SubscriptionIntroductoryOffersLinkagesResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SubscriptionsApiService.SubscriptionsIntroductoryOffersGetToManyRelationship")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/subscriptions/{id}/relationships/introductoryOffers"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSubscriptionsOfferCodesGetToManyRelatedRequest struct {
	ctx                                        context.Context
	ApiService                                 *SubscriptionsApiService
	id                                         string
	filterTerritory                            *[]string
	fieldsSubscriptionOfferCodeCustomCodes     *[]string
	fieldsSubscriptionOfferCodes               *[]string
	fieldsSubscriptionOfferCodeOneTimeUseCodes *[]string
	fieldsSubscriptions                        *[]string
	fieldsSubscriptionOfferCodePrices          *[]string
	limit                                      *int32
	limitOneTimeUseCodes                       *int32
	limitCustomCodes                           *int32
	limitPrices                                *int32
	include                                    *[]string
}

// filter by territory
func (r ApiSubscriptionsOfferCodesGetToManyRelatedRequest) FilterTerritory(filterTerritory []string) ApiSubscriptionsOfferCodesGetToManyRelatedRequest {
	r.filterTerritory = &filterTerritory
	return r
}

// the fields to include for returned resources of type subscriptionOfferCodeCustomCodes
func (r ApiSubscriptionsOfferCodesGetToManyRelatedRequest) FieldsSubscriptionOfferCodeCustomCodes(fieldsSubscriptionOfferCodeCustomCodes []string) ApiSubscriptionsOfferCodesGetToManyRelatedRequest {
	r.fieldsSubscriptionOfferCodeCustomCodes = &fieldsSubscriptionOfferCodeCustomCodes
	return r
}

// the fields to include for returned resources of type subscriptionOfferCodes
func (r ApiSubscriptionsOfferCodesGetToManyRelatedRequest) FieldsSubscriptionOfferCodes(fieldsSubscriptionOfferCodes []string) ApiSubscriptionsOfferCodesGetToManyRelatedRequest {
	r.fieldsSubscriptionOfferCodes = &fieldsSubscriptionOfferCodes
	return r
}

// the fields to include for returned resources of type subscriptionOfferCodeOneTimeUseCodes
func (r ApiSubscriptionsOfferCodesGetToManyRelatedRequest) FieldsSubscriptionOfferCodeOneTimeUseCodes(fieldsSubscriptionOfferCodeOneTimeUseCodes []string) ApiSubscriptionsOfferCodesGetToManyRelatedRequest {
	r.fieldsSubscriptionOfferCodeOneTimeUseCodes = &fieldsSubscriptionOfferCodeOneTimeUseCodes
	return r
}

// the fields to include for returned resources of type subscriptions
func (r ApiSubscriptionsOfferCodesGetToManyRelatedRequest) FieldsSubscriptions(fieldsSubscriptions []string) ApiSubscriptionsOfferCodesGetToManyRelatedRequest {
	r.fieldsSubscriptions = &fieldsSubscriptions
	return r
}

// the fields to include for returned resources of type subscriptionOfferCodePrices
func (r ApiSubscriptionsOfferCodesGetToManyRelatedRequest) FieldsSubscriptionOfferCodePrices(fieldsSubscriptionOfferCodePrices []string) ApiSubscriptionsOfferCodesGetToManyRelatedRequest {
	r.fieldsSubscriptionOfferCodePrices = &fieldsSubscriptionOfferCodePrices
	return r
}

// maximum resources per page
func (r ApiSubscriptionsOfferCodesGetToManyRelatedRequest) Limit(limit int32) ApiSubscriptionsOfferCodesGetToManyRelatedRequest {
	r.limit = &limit
	return r
}

// maximum number of related oneTimeUseCodes returned (when they are included)
func (r ApiSubscriptionsOfferCodesGetToManyRelatedRequest) LimitOneTimeUseCodes(limitOneTimeUseCodes int32) ApiSubscriptionsOfferCodesGetToManyRelatedRequest {
	r.limitOneTimeUseCodes = &limitOneTimeUseCodes
	return r
}

// maximum number of related customCodes returned (when they are included)
func (r ApiSubscriptionsOfferCodesGetToManyRelatedRequest) LimitCustomCodes(limitCustomCodes int32) ApiSubscriptionsOfferCodesGetToManyRelatedRequest {
	r.limitCustomCodes = &limitCustomCodes
	return r
}

// maximum number of related prices returned (when they are included)
func (r ApiSubscriptionsOfferCodesGetToManyRelatedRequest) LimitPrices(limitPrices int32) ApiSubscriptionsOfferCodesGetToManyRelatedRequest {
	r.limitPrices = &limitPrices
	return r
}

// comma-separated list of relationships to include
func (r ApiSubscriptionsOfferCodesGetToManyRelatedRequest) Include(include []string) ApiSubscriptionsOfferCodesGetToManyRelatedRequest {
	r.include = &include
	return r
}

func (r ApiSubscriptionsOfferCodesGetToManyRelatedRequest) Execute() (*SubscriptionOfferCodesResponse, *http.Response, error) {
	return r.ApiService.SubscriptionsOfferCodesGetToManyRelatedExecute(r)
}

/*
SubscriptionsOfferCodesGetToManyRelated Method for SubscriptionsOfferCodesGetToManyRelated

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id the id of the requested resource
	@return ApiSubscriptionsOfferCodesGetToManyRelatedRequest
*/
func (a *SubscriptionsApiService) SubscriptionsOfferCodesGetToManyRelated(ctx context.Context, id string) ApiSubscriptionsOfferCodesGetToManyRelatedRequest {
	return ApiSubscriptionsOfferCodesGetToManyRelatedRequest{
		ApiService: a,
		ctx:        ctx,
		id:         id,
	}
}

// Execute executes the request
//
//	@return SubscriptionOfferCodesResponse
func (a *SubscriptionsApiService) SubscriptionsOfferCodesGetToManyRelatedExecute(r ApiSubscriptionsOfferCodesGetToManyRelatedRequest) (*SubscriptionOfferCodesResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *SubscriptionOfferCodesResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SubscriptionsApiService.SubscriptionsOfferCodesGetToManyRelated")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/subscriptions/{id}/offerCodes"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.filterTerritory != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter[territory]", r.filterTerritory, "csv")
	}
	if r.fieldsSubscriptionOfferCodeCustomCodes != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields[subscriptionOfferCodeCustomCodes]", r.fieldsSubscriptionOfferCodeCustomCodes, "csv")
	}
	if r.fieldsSubscriptionOfferCodes != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields[subscriptionOfferCodes]", r.fieldsSubscriptionOfferCodes, "csv")
	}
	if r.fieldsSubscriptionOfferCodeOneTimeUseCodes != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields[subscriptionOfferCodeOneTimeUseCodes]", r.fieldsSubscriptionOfferCodeOneTimeUseCodes, "csv")
	}
	if r.fieldsSubscriptions != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields[subscriptions]", r.fieldsSubscriptions, "csv")
	}
	if r.fieldsSubscriptionOfferCodePrices != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields[subscriptionOfferCodePrices]", r.fieldsSubscriptionOfferCodePrices, "csv")
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "")
	}
	if r.limitOneTimeUseCodes != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit[oneTimeUseCodes]", r.limitOneTimeUseCodes, "")
	}
	if r.limitCustomCodes != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit[customCodes]", r.limitCustomCodes, "")
	}
	if r.limitPrices != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit[prices]", r.limitPrices, "")
	}
	if r.include != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "include", r.include, "csv")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSubscriptionsPricePointsGetToManyRelatedRequest struct {
	ctx                           context.Context
	ApiService                    *SubscriptionsApiService
	id                            string
	filterTerritory               *[]string
	fieldsSubscriptionPricePoints *[]string
	fieldsTerritories             *[]string
	limit                         *int32
	include                       *[]string
}

// filter by id(s) of related &#39;territory&#39;
func (r ApiSubscriptionsPricePointsGetToManyRelatedRequest) FilterTerritory(filterTerritory []string) ApiSubscriptionsPricePointsGetToManyRelatedRequest {
	r.filterTerritory = &filterTerritory
	return r
}

// the fields to include for returned resources of type subscriptionPricePoints
func (r ApiSubscriptionsPricePointsGetToManyRelatedRequest) FieldsSubscriptionPricePoints(fieldsSubscriptionPricePoints []string) ApiSubscriptionsPricePointsGetToManyRelatedRequest {
	r.fieldsSubscriptionPricePoints = &fieldsSubscriptionPricePoints
	return r
}

// the fields to include for returned resources of type territories
func (r ApiSubscriptionsPricePointsGetToManyRelatedRequest) FieldsTerritories(fieldsTerritories []string) ApiSubscriptionsPricePointsGetToManyRelatedRequest {
	r.fieldsTerritories = &fieldsTerritories
	return r
}

// maximum resources per page
func (r ApiSubscriptionsPricePointsGetToManyRelatedRequest) Limit(limit int32) ApiSubscriptionsPricePointsGetToManyRelatedRequest {
	r.limit = &limit
	return r
}

// comma-separated list of relationships to include
func (r ApiSubscriptionsPricePointsGetToManyRelatedRequest) Include(include []string) ApiSubscriptionsPricePointsGetToManyRelatedRequest {
	r.include = &include
	return r
}

func (r ApiSubscriptionsPricePointsGetToManyRelatedRequest) Execute() (*SubscriptionPricePointsResponse, *http.Response, error) {
	return r.ApiService.SubscriptionsPricePointsGetToManyRelatedExecute(r)
}

/*
SubscriptionsPricePointsGetToManyRelated Method for SubscriptionsPricePointsGetToManyRelated

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id the id of the requested resource
	@return ApiSubscriptionsPricePointsGetToManyRelatedRequest
*/
func (a *SubscriptionsApiService) SubscriptionsPricePointsGetToManyRelated(ctx context.Context, id string) ApiSubscriptionsPricePointsGetToManyRelatedRequest {
	return ApiSubscriptionsPricePointsGetToManyRelatedRequest{
		ApiService: a,
		ctx:        ctx,
		id:         id,
	}
}

// Execute executes the request
//
//	@return SubscriptionPricePointsResponse
func (a *SubscriptionsApiService) SubscriptionsPricePointsGetToManyRelatedExecute(r ApiSubscriptionsPricePointsGetToManyRelatedRequest) (*SubscriptionPricePointsResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *SubscriptionPricePointsResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SubscriptionsApiService.SubscriptionsPricePointsGetToManyRelated")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/subscriptions/{id}/pricePoints"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.filterTerritory != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter[territory]", r.filterTerritory, "csv")
	}
	if r.fieldsSubscriptionPricePoints != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields[subscriptionPricePoints]", r.fieldsSubscriptionPricePoints, "csv")
	}
	if r.fieldsTerritories != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields[territories]", r.fieldsTerritories, "csv")
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "")
	}
	if r.include != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "include", r.include, "csv")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSubscriptionsPricesDeleteToManyRelationshipRequest struct {
	ctx                               context.Context
	ApiService                        *SubscriptionsApiService
	id                                string
	subscriptionPricesLinkagesRequest *SubscriptionPricesLinkagesRequest
}

// List of related linkages
func (r ApiSubscriptionsPricesDeleteToManyRelationshipRequest) SubscriptionPricesLinkagesRequest(subscriptionPricesLinkagesRequest SubscriptionPricesLinkagesRequest) ApiSubscriptionsPricesDeleteToManyRelationshipRequest {
	r.subscriptionPricesLinkagesRequest = &subscriptionPricesLinkagesRequest
	return r
}

func (r ApiSubscriptionsPricesDeleteToManyRelationshipRequest) Execute() (*http.Response, error) {
	return r.ApiService.SubscriptionsPricesDeleteToManyRelationshipExecute(r)
}

/*
SubscriptionsPricesDeleteToManyRelationship Method for SubscriptionsPricesDeleteToManyRelationship

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id the id of the requested resource
	@return ApiSubscriptionsPricesDeleteToManyRelationshipRequest
*/
func (a *SubscriptionsApiService) SubscriptionsPricesDeleteToManyRelationship(ctx context.Context, id string) ApiSubscriptionsPricesDeleteToManyRelationshipRequest {
	return ApiSubscriptionsPricesDeleteToManyRelationshipRequest{
		ApiService: a,
		ctx:        ctx,
		id:         id,
	}
}

// Execute executes the request
func (a *SubscriptionsApiService) SubscriptionsPricesDeleteToManyRelationshipExecute(r ApiSubscriptionsPricesDeleteToManyRelationshipRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodDelete
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SubscriptionsApiService.SubscriptionsPricesDeleteToManyRelationship")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/subscriptions/{id}/relationships/prices"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.subscriptionPricesLinkagesRequest == nil {
		return nil, reportError("subscriptionPricesLinkagesRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.subscriptionPricesLinkagesRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 409 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiSubscriptionsPricesGetToManyRelatedRequest struct {
	ctx                           context.Context
	ApiService                    *SubscriptionsApiService
	id                            string
	filterSubscriptionPricePoint  *[]string
	filterTerritory               *[]string
	fieldsSubscriptionPricePoints *[]string
	fieldsSubscriptionPrices      *[]string
	fieldsTerritories             *[]string
	limit                         *int32
	include                       *[]string
}

// filter by id(s) of related &#39;subscriptionPricePoint&#39;
func (r ApiSubscriptionsPricesGetToManyRelatedRequest) FilterSubscriptionPricePoint(filterSubscriptionPricePoint []string) ApiSubscriptionsPricesGetToManyRelatedRequest {
	r.filterSubscriptionPricePoint = &filterSubscriptionPricePoint
	return r
}

// filter by id(s) of related &#39;territory&#39;
func (r ApiSubscriptionsPricesGetToManyRelatedRequest) FilterTerritory(filterTerritory []string) ApiSubscriptionsPricesGetToManyRelatedRequest {
	r.filterTerritory = &filterTerritory
	return r
}

// the fields to include for returned resources of type subscriptionPricePoints
func (r ApiSubscriptionsPricesGetToManyRelatedRequest) FieldsSubscriptionPricePoints(fieldsSubscriptionPricePoints []string) ApiSubscriptionsPricesGetToManyRelatedRequest {
	r.fieldsSubscriptionPricePoints = &fieldsSubscriptionPricePoints
	return r
}

// the fields to include for returned resources of type subscriptionPrices
func (r ApiSubscriptionsPricesGetToManyRelatedRequest) FieldsSubscriptionPrices(fieldsSubscriptionPrices []string) ApiSubscriptionsPricesGetToManyRelatedRequest {
	r.fieldsSubscriptionPrices = &fieldsSubscriptionPrices
	return r
}

// the fields to include for returned resources of type territories
func (r ApiSubscriptionsPricesGetToManyRelatedRequest) FieldsTerritories(fieldsTerritories []string) ApiSubscriptionsPricesGetToManyRelatedRequest {
	r.fieldsTerritories = &fieldsTerritories
	return r
}

// maximum resources per page
func (r ApiSubscriptionsPricesGetToManyRelatedRequest) Limit(limit int32) ApiSubscriptionsPricesGetToManyRelatedRequest {
	r.limit = &limit
	return r
}

// comma-separated list of relationships to include
func (r ApiSubscriptionsPricesGetToManyRelatedRequest) Include(include []string) ApiSubscriptionsPricesGetToManyRelatedRequest {
	r.include = &include
	return r
}

func (r ApiSubscriptionsPricesGetToManyRelatedRequest) Execute() (*SubscriptionPricesResponse, *http.Response, error) {
	return r.ApiService.SubscriptionsPricesGetToManyRelatedExecute(r)
}

/*
SubscriptionsPricesGetToManyRelated Method for SubscriptionsPricesGetToManyRelated

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id the id of the requested resource
	@return ApiSubscriptionsPricesGetToManyRelatedRequest
*/
func (a *SubscriptionsApiService) SubscriptionsPricesGetToManyRelated(ctx context.Context, id string) ApiSubscriptionsPricesGetToManyRelatedRequest {
	return ApiSubscriptionsPricesGetToManyRelatedRequest{
		ApiService: a,
		ctx:        ctx,
		id:         id,
	}
}

// Execute executes the request
//
//	@return SubscriptionPricesResponse
func (a *SubscriptionsApiService) SubscriptionsPricesGetToManyRelatedExecute(r ApiSubscriptionsPricesGetToManyRelatedRequest) (*SubscriptionPricesResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *SubscriptionPricesResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SubscriptionsApiService.SubscriptionsPricesGetToManyRelated")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/subscriptions/{id}/prices"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.filterSubscriptionPricePoint != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter[subscriptionPricePoint]", r.filterSubscriptionPricePoint, "csv")
	}
	if r.filterTerritory != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter[territory]", r.filterTerritory, "csv")
	}
	if r.fieldsSubscriptionPricePoints != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields[subscriptionPricePoints]", r.fieldsSubscriptionPricePoints, "csv")
	}
	if r.fieldsSubscriptionPrices != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields[subscriptionPrices]", r.fieldsSubscriptionPrices, "csv")
	}
	if r.fieldsTerritories != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields[territories]", r.fieldsTerritories, "csv")
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "")
	}
	if r.include != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "include", r.include, "csv")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSubscriptionsPricesGetToManyRelationshipRequest struct {
	ctx        context.Context
	ApiService *SubscriptionsApiService
	id         string
	limit      *int32
}

// maximum resources per page
func (r ApiSubscriptionsPricesGetToManyRelationshipRequest) Limit(limit int32) ApiSubscriptionsPricesGetToManyRelationshipRequest {
	r.limit = &limit
	return r
}

func (r ApiSubscriptionsPricesGetToManyRelationshipRequest) Execute() (*SubscriptionPricesLinkagesResponse, *http.Response, error) {
	return r.ApiService.SubscriptionsPricesGetToManyRelationshipExecute(r)
}

/*
SubscriptionsPricesGetToManyRelationship Method for SubscriptionsPricesGetToManyRelationship

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id the id of the requested resource
	@return ApiSubscriptionsPricesGetToManyRelationshipRequest
*/
func (a *SubscriptionsApiService) SubscriptionsPricesGetToManyRelationship(ctx context.Context, id string) ApiSubscriptionsPricesGetToManyRelationshipRequest {
	return ApiSubscriptionsPricesGetToManyRelationshipRequest{
		ApiService: a,
		ctx:        ctx,
		id:         id,
	}
}

// Execute executes the request
//
//	@return SubscriptionPricesLinkagesResponse
func (a *SubscriptionsApiService) SubscriptionsPricesGetToManyRelationshipExecute(r ApiSubscriptionsPricesGetToManyRelationshipRequest) (*SubscriptionPricesLinkagesResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *SubscriptionPricesLinkagesResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SubscriptionsApiService.SubscriptionsPricesGetToManyRelationship")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/subscriptions/{id}/relationships/prices"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSubscriptionsPromotedPurchaseGetToOneRelatedRequest struct {
	ctx                          context.Context
	ApiService                   *SubscriptionsApiService
	id                           string
	fieldsPromotedPurchases      *[]string
	fieldsSubscriptions          *[]string
	fieldsInAppPurchases         *[]string
	fieldsPromotedPurchaseImages *[]string
	limitPromotionImages         *int32
	include                      *[]string
}

// the fields to include for returned resources of type promotedPurchases
func (r ApiSubscriptionsPromotedPurchaseGetToOneRelatedRequest) FieldsPromotedPurchases(fieldsPromotedPurchases []string) ApiSubscriptionsPromotedPurchaseGetToOneRelatedRequest {
	r.fieldsPromotedPurchases = &fieldsPromotedPurchases
	return r
}

// the fields to include for returned resources of type subscriptions
func (r ApiSubscriptionsPromotedPurchaseGetToOneRelatedRequest) FieldsSubscriptions(fieldsSubscriptions []string) ApiSubscriptionsPromotedPurchaseGetToOneRelatedRequest {
	r.fieldsSubscriptions = &fieldsSubscriptions
	return r
}

// the fields to include for returned resources of type inAppPurchases
func (r ApiSubscriptionsPromotedPurchaseGetToOneRelatedRequest) FieldsInAppPurchases(fieldsInAppPurchases []string) ApiSubscriptionsPromotedPurchaseGetToOneRelatedRequest {
	r.fieldsInAppPurchases = &fieldsInAppPurchases
	return r
}

// the fields to include for returned resources of type promotedPurchaseImages
func (r ApiSubscriptionsPromotedPurchaseGetToOneRelatedRequest) FieldsPromotedPurchaseImages(fieldsPromotedPurchaseImages []string) ApiSubscriptionsPromotedPurchaseGetToOneRelatedRequest {
	r.fieldsPromotedPurchaseImages = &fieldsPromotedPurchaseImages
	return r
}

// maximum number of related promotionImages returned (when they are included)
func (r ApiSubscriptionsPromotedPurchaseGetToOneRelatedRequest) LimitPromotionImages(limitPromotionImages int32) ApiSubscriptionsPromotedPurchaseGetToOneRelatedRequest {
	r.limitPromotionImages = &limitPromotionImages
	return r
}

// comma-separated list of relationships to include
func (r ApiSubscriptionsPromotedPurchaseGetToOneRelatedRequest) Include(include []string) ApiSubscriptionsPromotedPurchaseGetToOneRelatedRequest {
	r.include = &include
	return r
}

func (r ApiSubscriptionsPromotedPurchaseGetToOneRelatedRequest) Execute() (*PromotedPurchaseResponse, *http.Response, error) {
	return r.ApiService.SubscriptionsPromotedPurchaseGetToOneRelatedExecute(r)
}

/*
SubscriptionsPromotedPurchaseGetToOneRelated Method for SubscriptionsPromotedPurchaseGetToOneRelated

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id the id of the requested resource
	@return ApiSubscriptionsPromotedPurchaseGetToOneRelatedRequest
*/
func (a *SubscriptionsApiService) SubscriptionsPromotedPurchaseGetToOneRelated(ctx context.Context, id string) ApiSubscriptionsPromotedPurchaseGetToOneRelatedRequest {
	return ApiSubscriptionsPromotedPurchaseGetToOneRelatedRequest{
		ApiService: a,
		ctx:        ctx,
		id:         id,
	}
}

// Execute executes the request
//
//	@return PromotedPurchaseResponse
func (a *SubscriptionsApiService) SubscriptionsPromotedPurchaseGetToOneRelatedExecute(r ApiSubscriptionsPromotedPurchaseGetToOneRelatedRequest) (*PromotedPurchaseResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *PromotedPurchaseResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SubscriptionsApiService.SubscriptionsPromotedPurchaseGetToOneRelated")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/subscriptions/{id}/promotedPurchase"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.fieldsPromotedPurchases != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields[promotedPurchases]", r.fieldsPromotedPurchases, "csv")
	}
	if r.fieldsSubscriptions != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields[subscriptions]", r.fieldsSubscriptions, "csv")
	}
	if r.fieldsInAppPurchases != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields[inAppPurchases]", r.fieldsInAppPurchases, "csv")
	}
	if r.fieldsPromotedPurchaseImages != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields[promotedPurchaseImages]", r.fieldsPromotedPurchaseImages, "csv")
	}
	if r.limitPromotionImages != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit[promotionImages]", r.limitPromotionImages, "")
	}
	if r.include != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "include", r.include, "csv")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSubscriptionsPromotionalOffersGetToManyRelatedRequest struct {
	ctx                                      context.Context
	ApiService                               *SubscriptionsApiService
	id                                       string
	filterTerritory                          *[]string
	fieldsSubscriptionPromotionalOffers      *[]string
	fieldsSubscriptions                      *[]string
	fieldsSubscriptionPromotionalOfferPrices *[]string
	limit                                    *int32
	limitPrices                              *int32
	include                                  *[]string
}

// filter by territory
func (r ApiSubscriptionsPromotionalOffersGetToManyRelatedRequest) FilterTerritory(filterTerritory []string) ApiSubscriptionsPromotionalOffersGetToManyRelatedRequest {
	r.filterTerritory = &filterTerritory
	return r
}

// the fields to include for returned resources of type subscriptionPromotionalOffers
func (r ApiSubscriptionsPromotionalOffersGetToManyRelatedRequest) FieldsSubscriptionPromotionalOffers(fieldsSubscriptionPromotionalOffers []string) ApiSubscriptionsPromotionalOffersGetToManyRelatedRequest {
	r.fieldsSubscriptionPromotionalOffers = &fieldsSubscriptionPromotionalOffers
	return r
}

// the fields to include for returned resources of type subscriptions
func (r ApiSubscriptionsPromotionalOffersGetToManyRelatedRequest) FieldsSubscriptions(fieldsSubscriptions []string) ApiSubscriptionsPromotionalOffersGetToManyRelatedRequest {
	r.fieldsSubscriptions = &fieldsSubscriptions
	return r
}

// the fields to include for returned resources of type subscriptionPromotionalOfferPrices
func (r ApiSubscriptionsPromotionalOffersGetToManyRelatedRequest) FieldsSubscriptionPromotionalOfferPrices(fieldsSubscriptionPromotionalOfferPrices []string) ApiSubscriptionsPromotionalOffersGetToManyRelatedRequest {
	r.fieldsSubscriptionPromotionalOfferPrices = &fieldsSubscriptionPromotionalOfferPrices
	return r
}

// maximum resources per page
func (r ApiSubscriptionsPromotionalOffersGetToManyRelatedRequest) Limit(limit int32) ApiSubscriptionsPromotionalOffersGetToManyRelatedRequest {
	r.limit = &limit
	return r
}

// maximum number of related prices returned (when they are included)
func (r ApiSubscriptionsPromotionalOffersGetToManyRelatedRequest) LimitPrices(limitPrices int32) ApiSubscriptionsPromotionalOffersGetToManyRelatedRequest {
	r.limitPrices = &limitPrices
	return r
}

// comma-separated list of relationships to include
func (r ApiSubscriptionsPromotionalOffersGetToManyRelatedRequest) Include(include []string) ApiSubscriptionsPromotionalOffersGetToManyRelatedRequest {
	r.include = &include
	return r
}

func (r ApiSubscriptionsPromotionalOffersGetToManyRelatedRequest) Execute() (*SubscriptionPromotionalOffersResponse, *http.Response, error) {
	return r.ApiService.SubscriptionsPromotionalOffersGetToManyRelatedExecute(r)
}

/*
SubscriptionsPromotionalOffersGetToManyRelated Method for SubscriptionsPromotionalOffersGetToManyRelated

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id the id of the requested resource
	@return ApiSubscriptionsPromotionalOffersGetToManyRelatedRequest
*/
func (a *SubscriptionsApiService) SubscriptionsPromotionalOffersGetToManyRelated(ctx context.Context, id string) ApiSubscriptionsPromotionalOffersGetToManyRelatedRequest {
	return ApiSubscriptionsPromotionalOffersGetToManyRelatedRequest{
		ApiService: a,
		ctx:        ctx,
		id:         id,
	}
}

// Execute executes the request
//
//	@return SubscriptionPromotionalOffersResponse
func (a *SubscriptionsApiService) SubscriptionsPromotionalOffersGetToManyRelatedExecute(r ApiSubscriptionsPromotionalOffersGetToManyRelatedRequest) (*SubscriptionPromotionalOffersResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *SubscriptionPromotionalOffersResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SubscriptionsApiService.SubscriptionsPromotionalOffersGetToManyRelated")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/subscriptions/{id}/promotionalOffers"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.filterTerritory != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter[territory]", r.filterTerritory, "csv")
	}
	if r.fieldsSubscriptionPromotionalOffers != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields[subscriptionPromotionalOffers]", r.fieldsSubscriptionPromotionalOffers, "csv")
	}
	if r.fieldsSubscriptions != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields[subscriptions]", r.fieldsSubscriptions, "csv")
	}
	if r.fieldsSubscriptionPromotionalOfferPrices != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields[subscriptionPromotionalOfferPrices]", r.fieldsSubscriptionPromotionalOfferPrices, "csv")
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "")
	}
	if r.limitPrices != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit[prices]", r.limitPrices, "")
	}
	if r.include != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "include", r.include, "csv")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSubscriptionsSubscriptionAvailabilityGetToOneRelatedRequest struct {
	ctx                              context.Context
	ApiService                       *SubscriptionsApiService
	id                               string
	fieldsSubscriptionAvailabilities *[]string
	fieldsSubscriptions              *[]string
	fieldsTerritories                *[]string
	limitAvailableTerritories        *int32
	include                          *[]string
}

// the fields to include for returned resources of type subscriptionAvailabilities
func (r ApiSubscriptionsSubscriptionAvailabilityGetToOneRelatedRequest) FieldsSubscriptionAvailabilities(fieldsSubscriptionAvailabilities []string) ApiSubscriptionsSubscriptionAvailabilityGetToOneRelatedRequest {
	r.fieldsSubscriptionAvailabilities = &fieldsSubscriptionAvailabilities
	return r
}

// the fields to include for returned resources of type subscriptions
func (r ApiSubscriptionsSubscriptionAvailabilityGetToOneRelatedRequest) FieldsSubscriptions(fieldsSubscriptions []string) ApiSubscriptionsSubscriptionAvailabilityGetToOneRelatedRequest {
	r.fieldsSubscriptions = &fieldsSubscriptions
	return r
}

// the fields to include for returned resources of type territories
func (r ApiSubscriptionsSubscriptionAvailabilityGetToOneRelatedRequest) FieldsTerritories(fieldsTerritories []string) ApiSubscriptionsSubscriptionAvailabilityGetToOneRelatedRequest {
	r.fieldsTerritories = &fieldsTerritories
	return r
}

// maximum number of related availableTerritories returned (when they are included)
func (r ApiSubscriptionsSubscriptionAvailabilityGetToOneRelatedRequest) LimitAvailableTerritories(limitAvailableTerritories int32) ApiSubscriptionsSubscriptionAvailabilityGetToOneRelatedRequest {
	r.limitAvailableTerritories = &limitAvailableTerritories
	return r
}

// comma-separated list of relationships to include
func (r ApiSubscriptionsSubscriptionAvailabilityGetToOneRelatedRequest) Include(include []string) ApiSubscriptionsSubscriptionAvailabilityGetToOneRelatedRequest {
	r.include = &include
	return r
}

func (r ApiSubscriptionsSubscriptionAvailabilityGetToOneRelatedRequest) Execute() (*SubscriptionAvailabilityResponse, *http.Response, error) {
	return r.ApiService.SubscriptionsSubscriptionAvailabilityGetToOneRelatedExecute(r)
}

/*
SubscriptionsSubscriptionAvailabilityGetToOneRelated Method for SubscriptionsSubscriptionAvailabilityGetToOneRelated

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id the id of the requested resource
	@return ApiSubscriptionsSubscriptionAvailabilityGetToOneRelatedRequest
*/
func (a *SubscriptionsApiService) SubscriptionsSubscriptionAvailabilityGetToOneRelated(ctx context.Context, id string) ApiSubscriptionsSubscriptionAvailabilityGetToOneRelatedRequest {
	return ApiSubscriptionsSubscriptionAvailabilityGetToOneRelatedRequest{
		ApiService: a,
		ctx:        ctx,
		id:         id,
	}
}

// Execute executes the request
//
//	@return SubscriptionAvailabilityResponse
func (a *SubscriptionsApiService) SubscriptionsSubscriptionAvailabilityGetToOneRelatedExecute(r ApiSubscriptionsSubscriptionAvailabilityGetToOneRelatedRequest) (*SubscriptionAvailabilityResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *SubscriptionAvailabilityResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SubscriptionsApiService.SubscriptionsSubscriptionAvailabilityGetToOneRelated")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/subscriptions/{id}/subscriptionAvailability"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.fieldsSubscriptionAvailabilities != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields[subscriptionAvailabilities]", r.fieldsSubscriptionAvailabilities, "csv")
	}
	if r.fieldsSubscriptions != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields[subscriptions]", r.fieldsSubscriptions, "csv")
	}
	if r.fieldsTerritories != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields[territories]", r.fieldsTerritories, "csv")
	}
	if r.limitAvailableTerritories != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit[availableTerritories]", r.limitAvailableTerritories, "")
	}
	if r.include != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "include", r.include, "csv")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSubscriptionsSubscriptionLocalizationsGetToManyRelatedRequest struct {
	ctx                             context.Context
	ApiService                      *SubscriptionsApiService
	id                              string
	fieldsSubscriptions             *[]string
	fieldsSubscriptionLocalizations *[]string
	limit                           *int32
	include                         *[]string
}

// the fields to include for returned resources of type subscriptions
func (r ApiSubscriptionsSubscriptionLocalizationsGetToManyRelatedRequest) FieldsSubscriptions(fieldsSubscriptions []string) ApiSubscriptionsSubscriptionLocalizationsGetToManyRelatedRequest {
	r.fieldsSubscriptions = &fieldsSubscriptions
	return r
}

// the fields to include for returned resources of type subscriptionLocalizations
func (r ApiSubscriptionsSubscriptionLocalizationsGetToManyRelatedRequest) FieldsSubscriptionLocalizations(fieldsSubscriptionLocalizations []string) ApiSubscriptionsSubscriptionLocalizationsGetToManyRelatedRequest {
	r.fieldsSubscriptionLocalizations = &fieldsSubscriptionLocalizations
	return r
}

// maximum resources per page
func (r ApiSubscriptionsSubscriptionLocalizationsGetToManyRelatedRequest) Limit(limit int32) ApiSubscriptionsSubscriptionLocalizationsGetToManyRelatedRequest {
	r.limit = &limit
	return r
}

// comma-separated list of relationships to include
func (r ApiSubscriptionsSubscriptionLocalizationsGetToManyRelatedRequest) Include(include []string) ApiSubscriptionsSubscriptionLocalizationsGetToManyRelatedRequest {
	r.include = &include
	return r
}

func (r ApiSubscriptionsSubscriptionLocalizationsGetToManyRelatedRequest) Execute() (*SubscriptionLocalizationsResponse, *http.Response, error) {
	return r.ApiService.SubscriptionsSubscriptionLocalizationsGetToManyRelatedExecute(r)
}

/*
SubscriptionsSubscriptionLocalizationsGetToManyRelated Method for SubscriptionsSubscriptionLocalizationsGetToManyRelated

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id the id of the requested resource
	@return ApiSubscriptionsSubscriptionLocalizationsGetToManyRelatedRequest
*/
func (a *SubscriptionsApiService) SubscriptionsSubscriptionLocalizationsGetToManyRelated(ctx context.Context, id string) ApiSubscriptionsSubscriptionLocalizationsGetToManyRelatedRequest {
	return ApiSubscriptionsSubscriptionLocalizationsGetToManyRelatedRequest{
		ApiService: a,
		ctx:        ctx,
		id:         id,
	}
}

// Execute executes the request
//
//	@return SubscriptionLocalizationsResponse
func (a *SubscriptionsApiService) SubscriptionsSubscriptionLocalizationsGetToManyRelatedExecute(r ApiSubscriptionsSubscriptionLocalizationsGetToManyRelatedRequest) (*SubscriptionLocalizationsResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *SubscriptionLocalizationsResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SubscriptionsApiService.SubscriptionsSubscriptionLocalizationsGetToManyRelated")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/subscriptions/{id}/subscriptionLocalizations"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.fieldsSubscriptions != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields[subscriptions]", r.fieldsSubscriptions, "csv")
	}
	if r.fieldsSubscriptionLocalizations != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields[subscriptionLocalizations]", r.fieldsSubscriptionLocalizations, "csv")
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "")
	}
	if r.include != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "include", r.include, "csv")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSubscriptionsUpdateInstanceRequest struct {
	ctx                       context.Context
	ApiService                *SubscriptionsApiService
	id                        string
	subscriptionUpdateRequest *SubscriptionUpdateRequest
}

// Subscription representation
func (r ApiSubscriptionsUpdateInstanceRequest) SubscriptionUpdateRequest(subscriptionUpdateRequest SubscriptionUpdateRequest) ApiSubscriptionsUpdateInstanceRequest {
	r.subscriptionUpdateRequest = &subscriptionUpdateRequest
	return r
}

func (r ApiSubscriptionsUpdateInstanceRequest) Execute() (*SubscriptionResponse, *http.Response, error) {
	return r.ApiService.SubscriptionsUpdateInstanceExecute(r)
}

/*
SubscriptionsUpdateInstance Method for SubscriptionsUpdateInstance

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id the id of the requested resource
	@return ApiSubscriptionsUpdateInstanceRequest
*/
func (a *SubscriptionsApiService) SubscriptionsUpdateInstance(ctx context.Context, id string) ApiSubscriptionsUpdateInstanceRequest {
	return ApiSubscriptionsUpdateInstanceRequest{
		ApiService: a,
		ctx:        ctx,
		id:         id,
	}
}

// Execute executes the request
//
//	@return SubscriptionResponse
func (a *SubscriptionsApiService) SubscriptionsUpdateInstanceExecute(r ApiSubscriptionsUpdateInstanceRequest) (*SubscriptionResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPatch
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *SubscriptionResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SubscriptionsApiService.SubscriptionsUpdateInstance")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/subscriptions/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.subscriptionUpdateRequest == nil {
		return localVarReturnValue, nil, reportError("subscriptionUpdateRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.subscriptionUpdateRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 409 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
