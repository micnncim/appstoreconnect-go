/*
App Store Connect API

No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)

API version: 3.0
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package appstoreconnect

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"strings"
)

// BetaTestersApiService BetaTestersApi service
type BetaTestersApiService service

type ApiBetaTestersAppsDeleteToManyRelationshipRequest struct {
	ctx                           context.Context
	ApiService                    *BetaTestersApiService
	id                            string
	betaTesterAppsLinkagesRequest *BetaTesterAppsLinkagesRequest
}

// List of related linkages
func (r ApiBetaTestersAppsDeleteToManyRelationshipRequest) BetaTesterAppsLinkagesRequest(betaTesterAppsLinkagesRequest BetaTesterAppsLinkagesRequest) ApiBetaTestersAppsDeleteToManyRelationshipRequest {
	r.betaTesterAppsLinkagesRequest = &betaTesterAppsLinkagesRequest
	return r
}

func (r ApiBetaTestersAppsDeleteToManyRelationshipRequest) Execute() (*http.Response, error) {
	return r.ApiService.BetaTestersAppsDeleteToManyRelationshipExecute(r)
}

/*
BetaTestersAppsDeleteToManyRelationship Method for BetaTestersAppsDeleteToManyRelationship

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id the id of the requested resource
	@return ApiBetaTestersAppsDeleteToManyRelationshipRequest
*/
func (a *BetaTestersApiService) BetaTestersAppsDeleteToManyRelationship(ctx context.Context, id string) ApiBetaTestersAppsDeleteToManyRelationshipRequest {
	return ApiBetaTestersAppsDeleteToManyRelationshipRequest{
		ApiService: a,
		ctx:        ctx,
		id:         id,
	}
}

// Execute executes the request
func (a *BetaTestersApiService) BetaTestersAppsDeleteToManyRelationshipExecute(r ApiBetaTestersAppsDeleteToManyRelationshipRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodDelete
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BetaTestersApiService.BetaTestersAppsDeleteToManyRelationship")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/betaTesters/{id}/relationships/apps"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.betaTesterAppsLinkagesRequest == nil {
		return nil, reportError("betaTesterAppsLinkagesRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.betaTesterAppsLinkagesRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 409 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiBetaTestersAppsGetToManyRelatedRequest struct {
	ctx        context.Context
	ApiService *BetaTestersApiService
	id         string
	fieldsApps *[]string
	limit      *int32
}

// the fields to include for returned resources of type apps
func (r ApiBetaTestersAppsGetToManyRelatedRequest) FieldsApps(fieldsApps []string) ApiBetaTestersAppsGetToManyRelatedRequest {
	r.fieldsApps = &fieldsApps
	return r
}

// maximum resources per page
func (r ApiBetaTestersAppsGetToManyRelatedRequest) Limit(limit int32) ApiBetaTestersAppsGetToManyRelatedRequest {
	r.limit = &limit
	return r
}

func (r ApiBetaTestersAppsGetToManyRelatedRequest) Execute() (*AppsWithoutIncludesResponse, *http.Response, error) {
	return r.ApiService.BetaTestersAppsGetToManyRelatedExecute(r)
}

/*
BetaTestersAppsGetToManyRelated Method for BetaTestersAppsGetToManyRelated

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id the id of the requested resource
	@return ApiBetaTestersAppsGetToManyRelatedRequest
*/
func (a *BetaTestersApiService) BetaTestersAppsGetToManyRelated(ctx context.Context, id string) ApiBetaTestersAppsGetToManyRelatedRequest {
	return ApiBetaTestersAppsGetToManyRelatedRequest{
		ApiService: a,
		ctx:        ctx,
		id:         id,
	}
}

// Execute executes the request
//
//	@return AppsWithoutIncludesResponse
func (a *BetaTestersApiService) BetaTestersAppsGetToManyRelatedExecute(r ApiBetaTestersAppsGetToManyRelatedRequest) (*AppsWithoutIncludesResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *AppsWithoutIncludesResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BetaTestersApiService.BetaTestersAppsGetToManyRelated")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/betaTesters/{id}/apps"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.fieldsApps != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields[apps]", r.fieldsApps, "csv")
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiBetaTestersAppsGetToManyRelationshipRequest struct {
	ctx        context.Context
	ApiService *BetaTestersApiService
	id         string
	limit      *int32
}

// maximum resources per page
func (r ApiBetaTestersAppsGetToManyRelationshipRequest) Limit(limit int32) ApiBetaTestersAppsGetToManyRelationshipRequest {
	r.limit = &limit
	return r
}

func (r ApiBetaTestersAppsGetToManyRelationshipRequest) Execute() (*BetaTesterAppsLinkagesResponse, *http.Response, error) {
	return r.ApiService.BetaTestersAppsGetToManyRelationshipExecute(r)
}

/*
BetaTestersAppsGetToManyRelationship Method for BetaTestersAppsGetToManyRelationship

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id the id of the requested resource
	@return ApiBetaTestersAppsGetToManyRelationshipRequest
*/
func (a *BetaTestersApiService) BetaTestersAppsGetToManyRelationship(ctx context.Context, id string) ApiBetaTestersAppsGetToManyRelationshipRequest {
	return ApiBetaTestersAppsGetToManyRelationshipRequest{
		ApiService: a,
		ctx:        ctx,
		id:         id,
	}
}

// Execute executes the request
//
//	@return BetaTesterAppsLinkagesResponse
func (a *BetaTestersApiService) BetaTestersAppsGetToManyRelationshipExecute(r ApiBetaTestersAppsGetToManyRelationshipRequest) (*BetaTesterAppsLinkagesResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *BetaTesterAppsLinkagesResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BetaTestersApiService.BetaTestersAppsGetToManyRelationship")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/betaTesters/{id}/relationships/apps"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiBetaTestersBetaGroupsCreateToManyRelationshipRequest struct {
	ctx                                 context.Context
	ApiService                          *BetaTestersApiService
	id                                  string
	betaTesterBetaGroupsLinkagesRequest *BetaTesterBetaGroupsLinkagesRequest
}

// List of related linkages
func (r ApiBetaTestersBetaGroupsCreateToManyRelationshipRequest) BetaTesterBetaGroupsLinkagesRequest(betaTesterBetaGroupsLinkagesRequest BetaTesterBetaGroupsLinkagesRequest) ApiBetaTestersBetaGroupsCreateToManyRelationshipRequest {
	r.betaTesterBetaGroupsLinkagesRequest = &betaTesterBetaGroupsLinkagesRequest
	return r
}

func (r ApiBetaTestersBetaGroupsCreateToManyRelationshipRequest) Execute() (*http.Response, error) {
	return r.ApiService.BetaTestersBetaGroupsCreateToManyRelationshipExecute(r)
}

/*
BetaTestersBetaGroupsCreateToManyRelationship Method for BetaTestersBetaGroupsCreateToManyRelationship

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id the id of the requested resource
	@return ApiBetaTestersBetaGroupsCreateToManyRelationshipRequest
*/
func (a *BetaTestersApiService) BetaTestersBetaGroupsCreateToManyRelationship(ctx context.Context, id string) ApiBetaTestersBetaGroupsCreateToManyRelationshipRequest {
	return ApiBetaTestersBetaGroupsCreateToManyRelationshipRequest{
		ApiService: a,
		ctx:        ctx,
		id:         id,
	}
}

// Execute executes the request
func (a *BetaTestersApiService) BetaTestersBetaGroupsCreateToManyRelationshipExecute(r ApiBetaTestersBetaGroupsCreateToManyRelationshipRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodPost
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BetaTestersApiService.BetaTestersBetaGroupsCreateToManyRelationship")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/betaTesters/{id}/relationships/betaGroups"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.betaTesterBetaGroupsLinkagesRequest == nil {
		return nil, reportError("betaTesterBetaGroupsLinkagesRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.betaTesterBetaGroupsLinkagesRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 409 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiBetaTestersBetaGroupsDeleteToManyRelationshipRequest struct {
	ctx                                 context.Context
	ApiService                          *BetaTestersApiService
	id                                  string
	betaTesterBetaGroupsLinkagesRequest *BetaTesterBetaGroupsLinkagesRequest
}

// List of related linkages
func (r ApiBetaTestersBetaGroupsDeleteToManyRelationshipRequest) BetaTesterBetaGroupsLinkagesRequest(betaTesterBetaGroupsLinkagesRequest BetaTesterBetaGroupsLinkagesRequest) ApiBetaTestersBetaGroupsDeleteToManyRelationshipRequest {
	r.betaTesterBetaGroupsLinkagesRequest = &betaTesterBetaGroupsLinkagesRequest
	return r
}

func (r ApiBetaTestersBetaGroupsDeleteToManyRelationshipRequest) Execute() (*http.Response, error) {
	return r.ApiService.BetaTestersBetaGroupsDeleteToManyRelationshipExecute(r)
}

/*
BetaTestersBetaGroupsDeleteToManyRelationship Method for BetaTestersBetaGroupsDeleteToManyRelationship

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id the id of the requested resource
	@return ApiBetaTestersBetaGroupsDeleteToManyRelationshipRequest
*/
func (a *BetaTestersApiService) BetaTestersBetaGroupsDeleteToManyRelationship(ctx context.Context, id string) ApiBetaTestersBetaGroupsDeleteToManyRelationshipRequest {
	return ApiBetaTestersBetaGroupsDeleteToManyRelationshipRequest{
		ApiService: a,
		ctx:        ctx,
		id:         id,
	}
}

// Execute executes the request
func (a *BetaTestersApiService) BetaTestersBetaGroupsDeleteToManyRelationshipExecute(r ApiBetaTestersBetaGroupsDeleteToManyRelationshipRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodDelete
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BetaTestersApiService.BetaTestersBetaGroupsDeleteToManyRelationship")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/betaTesters/{id}/relationships/betaGroups"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.betaTesterBetaGroupsLinkagesRequest == nil {
		return nil, reportError("betaTesterBetaGroupsLinkagesRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.betaTesterBetaGroupsLinkagesRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 409 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiBetaTestersBetaGroupsGetToManyRelatedRequest struct {
	ctx              context.Context
	ApiService       *BetaTestersApiService
	id               string
	fieldsBetaGroups *[]string
	limit            *int32
}

// the fields to include for returned resources of type betaGroups
func (r ApiBetaTestersBetaGroupsGetToManyRelatedRequest) FieldsBetaGroups(fieldsBetaGroups []string) ApiBetaTestersBetaGroupsGetToManyRelatedRequest {
	r.fieldsBetaGroups = &fieldsBetaGroups
	return r
}

// maximum resources per page
func (r ApiBetaTestersBetaGroupsGetToManyRelatedRequest) Limit(limit int32) ApiBetaTestersBetaGroupsGetToManyRelatedRequest {
	r.limit = &limit
	return r
}

func (r ApiBetaTestersBetaGroupsGetToManyRelatedRequest) Execute() (*BetaGroupsWithoutIncludesResponse, *http.Response, error) {
	return r.ApiService.BetaTestersBetaGroupsGetToManyRelatedExecute(r)
}

/*
BetaTestersBetaGroupsGetToManyRelated Method for BetaTestersBetaGroupsGetToManyRelated

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id the id of the requested resource
	@return ApiBetaTestersBetaGroupsGetToManyRelatedRequest
*/
func (a *BetaTestersApiService) BetaTestersBetaGroupsGetToManyRelated(ctx context.Context, id string) ApiBetaTestersBetaGroupsGetToManyRelatedRequest {
	return ApiBetaTestersBetaGroupsGetToManyRelatedRequest{
		ApiService: a,
		ctx:        ctx,
		id:         id,
	}
}

// Execute executes the request
//
//	@return BetaGroupsWithoutIncludesResponse
func (a *BetaTestersApiService) BetaTestersBetaGroupsGetToManyRelatedExecute(r ApiBetaTestersBetaGroupsGetToManyRelatedRequest) (*BetaGroupsWithoutIncludesResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *BetaGroupsWithoutIncludesResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BetaTestersApiService.BetaTestersBetaGroupsGetToManyRelated")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/betaTesters/{id}/betaGroups"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.fieldsBetaGroups != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields[betaGroups]", r.fieldsBetaGroups, "csv")
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiBetaTestersBetaGroupsGetToManyRelationshipRequest struct {
	ctx        context.Context
	ApiService *BetaTestersApiService
	id         string
	limit      *int32
}

// maximum resources per page
func (r ApiBetaTestersBetaGroupsGetToManyRelationshipRequest) Limit(limit int32) ApiBetaTestersBetaGroupsGetToManyRelationshipRequest {
	r.limit = &limit
	return r
}

func (r ApiBetaTestersBetaGroupsGetToManyRelationshipRequest) Execute() (*BetaTesterBetaGroupsLinkagesResponse, *http.Response, error) {
	return r.ApiService.BetaTestersBetaGroupsGetToManyRelationshipExecute(r)
}

/*
BetaTestersBetaGroupsGetToManyRelationship Method for BetaTestersBetaGroupsGetToManyRelationship

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id the id of the requested resource
	@return ApiBetaTestersBetaGroupsGetToManyRelationshipRequest
*/
func (a *BetaTestersApiService) BetaTestersBetaGroupsGetToManyRelationship(ctx context.Context, id string) ApiBetaTestersBetaGroupsGetToManyRelationshipRequest {
	return ApiBetaTestersBetaGroupsGetToManyRelationshipRequest{
		ApiService: a,
		ctx:        ctx,
		id:         id,
	}
}

// Execute executes the request
//
//	@return BetaTesterBetaGroupsLinkagesResponse
func (a *BetaTestersApiService) BetaTestersBetaGroupsGetToManyRelationshipExecute(r ApiBetaTestersBetaGroupsGetToManyRelationshipRequest) (*BetaTesterBetaGroupsLinkagesResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *BetaTesterBetaGroupsLinkagesResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BetaTestersApiService.BetaTestersBetaGroupsGetToManyRelationship")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/betaTesters/{id}/relationships/betaGroups"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiBetaTestersBuildsCreateToManyRelationshipRequest struct {
	ctx                             context.Context
	ApiService                      *BetaTestersApiService
	id                              string
	betaTesterBuildsLinkagesRequest *BetaTesterBuildsLinkagesRequest
}

// List of related linkages
func (r ApiBetaTestersBuildsCreateToManyRelationshipRequest) BetaTesterBuildsLinkagesRequest(betaTesterBuildsLinkagesRequest BetaTesterBuildsLinkagesRequest) ApiBetaTestersBuildsCreateToManyRelationshipRequest {
	r.betaTesterBuildsLinkagesRequest = &betaTesterBuildsLinkagesRequest
	return r
}

func (r ApiBetaTestersBuildsCreateToManyRelationshipRequest) Execute() (*http.Response, error) {
	return r.ApiService.BetaTestersBuildsCreateToManyRelationshipExecute(r)
}

/*
BetaTestersBuildsCreateToManyRelationship Method for BetaTestersBuildsCreateToManyRelationship

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id the id of the requested resource
	@return ApiBetaTestersBuildsCreateToManyRelationshipRequest
*/
func (a *BetaTestersApiService) BetaTestersBuildsCreateToManyRelationship(ctx context.Context, id string) ApiBetaTestersBuildsCreateToManyRelationshipRequest {
	return ApiBetaTestersBuildsCreateToManyRelationshipRequest{
		ApiService: a,
		ctx:        ctx,
		id:         id,
	}
}

// Execute executes the request
func (a *BetaTestersApiService) BetaTestersBuildsCreateToManyRelationshipExecute(r ApiBetaTestersBuildsCreateToManyRelationshipRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodPost
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BetaTestersApiService.BetaTestersBuildsCreateToManyRelationship")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/betaTesters/{id}/relationships/builds"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.betaTesterBuildsLinkagesRequest == nil {
		return nil, reportError("betaTesterBuildsLinkagesRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.betaTesterBuildsLinkagesRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 409 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiBetaTestersBuildsDeleteToManyRelationshipRequest struct {
	ctx                             context.Context
	ApiService                      *BetaTestersApiService
	id                              string
	betaTesterBuildsLinkagesRequest *BetaTesterBuildsLinkagesRequest
}

// List of related linkages
func (r ApiBetaTestersBuildsDeleteToManyRelationshipRequest) BetaTesterBuildsLinkagesRequest(betaTesterBuildsLinkagesRequest BetaTesterBuildsLinkagesRequest) ApiBetaTestersBuildsDeleteToManyRelationshipRequest {
	r.betaTesterBuildsLinkagesRequest = &betaTesterBuildsLinkagesRequest
	return r
}

func (r ApiBetaTestersBuildsDeleteToManyRelationshipRequest) Execute() (*http.Response, error) {
	return r.ApiService.BetaTestersBuildsDeleteToManyRelationshipExecute(r)
}

/*
BetaTestersBuildsDeleteToManyRelationship Method for BetaTestersBuildsDeleteToManyRelationship

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id the id of the requested resource
	@return ApiBetaTestersBuildsDeleteToManyRelationshipRequest
*/
func (a *BetaTestersApiService) BetaTestersBuildsDeleteToManyRelationship(ctx context.Context, id string) ApiBetaTestersBuildsDeleteToManyRelationshipRequest {
	return ApiBetaTestersBuildsDeleteToManyRelationshipRequest{
		ApiService: a,
		ctx:        ctx,
		id:         id,
	}
}

// Execute executes the request
func (a *BetaTestersApiService) BetaTestersBuildsDeleteToManyRelationshipExecute(r ApiBetaTestersBuildsDeleteToManyRelationshipRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodDelete
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BetaTestersApiService.BetaTestersBuildsDeleteToManyRelationship")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/betaTesters/{id}/relationships/builds"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.betaTesterBuildsLinkagesRequest == nil {
		return nil, reportError("betaTesterBuildsLinkagesRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.betaTesterBuildsLinkagesRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 409 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiBetaTestersBuildsGetToManyRelatedRequest struct {
	ctx          context.Context
	ApiService   *BetaTestersApiService
	id           string
	fieldsBuilds *[]string
	limit        *int32
}

// the fields to include for returned resources of type builds
func (r ApiBetaTestersBuildsGetToManyRelatedRequest) FieldsBuilds(fieldsBuilds []string) ApiBetaTestersBuildsGetToManyRelatedRequest {
	r.fieldsBuilds = &fieldsBuilds
	return r
}

// maximum resources per page
func (r ApiBetaTestersBuildsGetToManyRelatedRequest) Limit(limit int32) ApiBetaTestersBuildsGetToManyRelatedRequest {
	r.limit = &limit
	return r
}

func (r ApiBetaTestersBuildsGetToManyRelatedRequest) Execute() (*BuildsWithoutIncludesResponse, *http.Response, error) {
	return r.ApiService.BetaTestersBuildsGetToManyRelatedExecute(r)
}

/*
BetaTestersBuildsGetToManyRelated Method for BetaTestersBuildsGetToManyRelated

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id the id of the requested resource
	@return ApiBetaTestersBuildsGetToManyRelatedRequest
*/
func (a *BetaTestersApiService) BetaTestersBuildsGetToManyRelated(ctx context.Context, id string) ApiBetaTestersBuildsGetToManyRelatedRequest {
	return ApiBetaTestersBuildsGetToManyRelatedRequest{
		ApiService: a,
		ctx:        ctx,
		id:         id,
	}
}

// Execute executes the request
//
//	@return BuildsWithoutIncludesResponse
func (a *BetaTestersApiService) BetaTestersBuildsGetToManyRelatedExecute(r ApiBetaTestersBuildsGetToManyRelatedRequest) (*BuildsWithoutIncludesResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *BuildsWithoutIncludesResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BetaTestersApiService.BetaTestersBuildsGetToManyRelated")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/betaTesters/{id}/builds"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.fieldsBuilds != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields[builds]", r.fieldsBuilds, "csv")
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiBetaTestersBuildsGetToManyRelationshipRequest struct {
	ctx        context.Context
	ApiService *BetaTestersApiService
	id         string
	limit      *int32
}

// maximum resources per page
func (r ApiBetaTestersBuildsGetToManyRelationshipRequest) Limit(limit int32) ApiBetaTestersBuildsGetToManyRelationshipRequest {
	r.limit = &limit
	return r
}

func (r ApiBetaTestersBuildsGetToManyRelationshipRequest) Execute() (*BetaTesterBuildsLinkagesResponse, *http.Response, error) {
	return r.ApiService.BetaTestersBuildsGetToManyRelationshipExecute(r)
}

/*
BetaTestersBuildsGetToManyRelationship Method for BetaTestersBuildsGetToManyRelationship

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id the id of the requested resource
	@return ApiBetaTestersBuildsGetToManyRelationshipRequest
*/
func (a *BetaTestersApiService) BetaTestersBuildsGetToManyRelationship(ctx context.Context, id string) ApiBetaTestersBuildsGetToManyRelationshipRequest {
	return ApiBetaTestersBuildsGetToManyRelationshipRequest{
		ApiService: a,
		ctx:        ctx,
		id:         id,
	}
}

// Execute executes the request
//
//	@return BetaTesterBuildsLinkagesResponse
func (a *BetaTestersApiService) BetaTestersBuildsGetToManyRelationshipExecute(r ApiBetaTestersBuildsGetToManyRelationshipRequest) (*BetaTesterBuildsLinkagesResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *BetaTesterBuildsLinkagesResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BetaTestersApiService.BetaTestersBuildsGetToManyRelationship")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/betaTesters/{id}/relationships/builds"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiBetaTestersCreateInstanceRequest struct {
	ctx                     context.Context
	ApiService              *BetaTestersApiService
	betaTesterCreateRequest *BetaTesterCreateRequest
}

// BetaTester representation
func (r ApiBetaTestersCreateInstanceRequest) BetaTesterCreateRequest(betaTesterCreateRequest BetaTesterCreateRequest) ApiBetaTestersCreateInstanceRequest {
	r.betaTesterCreateRequest = &betaTesterCreateRequest
	return r
}

func (r ApiBetaTestersCreateInstanceRequest) Execute() (*BetaTesterResponse, *http.Response, error) {
	return r.ApiService.BetaTestersCreateInstanceExecute(r)
}

/*
BetaTestersCreateInstance Method for BetaTestersCreateInstance

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiBetaTestersCreateInstanceRequest
*/
func (a *BetaTestersApiService) BetaTestersCreateInstance(ctx context.Context) ApiBetaTestersCreateInstanceRequest {
	return ApiBetaTestersCreateInstanceRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return BetaTesterResponse
func (a *BetaTestersApiService) BetaTestersCreateInstanceExecute(r ApiBetaTestersCreateInstanceRequest) (*BetaTesterResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *BetaTesterResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BetaTestersApiService.BetaTestersCreateInstance")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/betaTesters"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.betaTesterCreateRequest == nil {
		return localVarReturnValue, nil, reportError("betaTesterCreateRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.betaTesterCreateRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 409 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiBetaTestersDeleteInstanceRequest struct {
	ctx        context.Context
	ApiService *BetaTestersApiService
	id         string
}

func (r ApiBetaTestersDeleteInstanceRequest) Execute() (*http.Response, error) {
	return r.ApiService.BetaTestersDeleteInstanceExecute(r)
}

/*
BetaTestersDeleteInstance Method for BetaTestersDeleteInstance

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id the id of the requested resource
	@return ApiBetaTestersDeleteInstanceRequest
*/
func (a *BetaTestersApiService) BetaTestersDeleteInstance(ctx context.Context, id string) ApiBetaTestersDeleteInstanceRequest {
	return ApiBetaTestersDeleteInstanceRequest{
		ApiService: a,
		ctx:        ctx,
		id:         id,
	}
}

// Execute executes the request
func (a *BetaTestersApiService) BetaTestersDeleteInstanceExecute(r ApiBetaTestersDeleteInstanceRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodDelete
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BetaTestersApiService.BetaTestersDeleteInstance")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/betaTesters/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 409 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiBetaTestersGetCollectionRequest struct {
	ctx               context.Context
	ApiService        *BetaTestersApiService
	filterEmail       *[]string
	filterFirstName   *[]string
	filterInviteType  *[]string
	filterLastName    *[]string
	filterApps        *[]string
	filterBetaGroups  *[]string
	filterBuilds      *[]string
	filterId          *[]string
	sort              *[]string
	fieldsBetaTesters *[]string
	limit             *int32
	include           *[]string
	fieldsApps        *[]string
	fieldsBuilds      *[]string
	fieldsBetaGroups  *[]string
	limitApps         *int32
	limitBetaGroups   *int32
	limitBuilds       *int32
}

// filter by attribute &#39;email&#39;
func (r ApiBetaTestersGetCollectionRequest) FilterEmail(filterEmail []string) ApiBetaTestersGetCollectionRequest {
	r.filterEmail = &filterEmail
	return r
}

// filter by attribute &#39;firstName&#39;
func (r ApiBetaTestersGetCollectionRequest) FilterFirstName(filterFirstName []string) ApiBetaTestersGetCollectionRequest {
	r.filterFirstName = &filterFirstName
	return r
}

// filter by attribute &#39;inviteType&#39;
func (r ApiBetaTestersGetCollectionRequest) FilterInviteType(filterInviteType []string) ApiBetaTestersGetCollectionRequest {
	r.filterInviteType = &filterInviteType
	return r
}

// filter by attribute &#39;lastName&#39;
func (r ApiBetaTestersGetCollectionRequest) FilterLastName(filterLastName []string) ApiBetaTestersGetCollectionRequest {
	r.filterLastName = &filterLastName
	return r
}

// filter by id(s) of related &#39;apps&#39;
func (r ApiBetaTestersGetCollectionRequest) FilterApps(filterApps []string) ApiBetaTestersGetCollectionRequest {
	r.filterApps = &filterApps
	return r
}

// filter by id(s) of related &#39;betaGroups&#39;
func (r ApiBetaTestersGetCollectionRequest) FilterBetaGroups(filterBetaGroups []string) ApiBetaTestersGetCollectionRequest {
	r.filterBetaGroups = &filterBetaGroups
	return r
}

// filter by id(s) of related &#39;builds&#39;
func (r ApiBetaTestersGetCollectionRequest) FilterBuilds(filterBuilds []string) ApiBetaTestersGetCollectionRequest {
	r.filterBuilds = &filterBuilds
	return r
}

// filter by id(s)
func (r ApiBetaTestersGetCollectionRequest) FilterId(filterId []string) ApiBetaTestersGetCollectionRequest {
	r.filterId = &filterId
	return r
}

// comma-separated list of sort expressions; resources will be sorted as specified
func (r ApiBetaTestersGetCollectionRequest) Sort(sort []string) ApiBetaTestersGetCollectionRequest {
	r.sort = &sort
	return r
}

// the fields to include for returned resources of type betaTesters
func (r ApiBetaTestersGetCollectionRequest) FieldsBetaTesters(fieldsBetaTesters []string) ApiBetaTestersGetCollectionRequest {
	r.fieldsBetaTesters = &fieldsBetaTesters
	return r
}

// maximum resources per page
func (r ApiBetaTestersGetCollectionRequest) Limit(limit int32) ApiBetaTestersGetCollectionRequest {
	r.limit = &limit
	return r
}

// comma-separated list of relationships to include
func (r ApiBetaTestersGetCollectionRequest) Include(include []string) ApiBetaTestersGetCollectionRequest {
	r.include = &include
	return r
}

// the fields to include for returned resources of type apps
func (r ApiBetaTestersGetCollectionRequest) FieldsApps(fieldsApps []string) ApiBetaTestersGetCollectionRequest {
	r.fieldsApps = &fieldsApps
	return r
}

// the fields to include for returned resources of type builds
func (r ApiBetaTestersGetCollectionRequest) FieldsBuilds(fieldsBuilds []string) ApiBetaTestersGetCollectionRequest {
	r.fieldsBuilds = &fieldsBuilds
	return r
}

// the fields to include for returned resources of type betaGroups
func (r ApiBetaTestersGetCollectionRequest) FieldsBetaGroups(fieldsBetaGroups []string) ApiBetaTestersGetCollectionRequest {
	r.fieldsBetaGroups = &fieldsBetaGroups
	return r
}

// maximum number of related apps returned (when they are included)
func (r ApiBetaTestersGetCollectionRequest) LimitApps(limitApps int32) ApiBetaTestersGetCollectionRequest {
	r.limitApps = &limitApps
	return r
}

// maximum number of related betaGroups returned (when they are included)
func (r ApiBetaTestersGetCollectionRequest) LimitBetaGroups(limitBetaGroups int32) ApiBetaTestersGetCollectionRequest {
	r.limitBetaGroups = &limitBetaGroups
	return r
}

// maximum number of related builds returned (when they are included)
func (r ApiBetaTestersGetCollectionRequest) LimitBuilds(limitBuilds int32) ApiBetaTestersGetCollectionRequest {
	r.limitBuilds = &limitBuilds
	return r
}

func (r ApiBetaTestersGetCollectionRequest) Execute() (*BetaTestersResponse, *http.Response, error) {
	return r.ApiService.BetaTestersGetCollectionExecute(r)
}

/*
BetaTestersGetCollection Method for BetaTestersGetCollection

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiBetaTestersGetCollectionRequest
*/
func (a *BetaTestersApiService) BetaTestersGetCollection(ctx context.Context) ApiBetaTestersGetCollectionRequest {
	return ApiBetaTestersGetCollectionRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return BetaTestersResponse
func (a *BetaTestersApiService) BetaTestersGetCollectionExecute(r ApiBetaTestersGetCollectionRequest) (*BetaTestersResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *BetaTestersResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BetaTestersApiService.BetaTestersGetCollection")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/betaTesters"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.filterEmail != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter[email]", r.filterEmail, "csv")
	}
	if r.filterFirstName != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter[firstName]", r.filterFirstName, "csv")
	}
	if r.filterInviteType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter[inviteType]", r.filterInviteType, "csv")
	}
	if r.filterLastName != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter[lastName]", r.filterLastName, "csv")
	}
	if r.filterApps != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter[apps]", r.filterApps, "csv")
	}
	if r.filterBetaGroups != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter[betaGroups]", r.filterBetaGroups, "csv")
	}
	if r.filterBuilds != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter[builds]", r.filterBuilds, "csv")
	}
	if r.filterId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter[id]", r.filterId, "csv")
	}
	if r.sort != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "sort", r.sort, "csv")
	}
	if r.fieldsBetaTesters != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields[betaTesters]", r.fieldsBetaTesters, "csv")
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "")
	}
	if r.include != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "include", r.include, "csv")
	}
	if r.fieldsApps != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields[apps]", r.fieldsApps, "csv")
	}
	if r.fieldsBuilds != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields[builds]", r.fieldsBuilds, "csv")
	}
	if r.fieldsBetaGroups != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields[betaGroups]", r.fieldsBetaGroups, "csv")
	}
	if r.limitApps != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit[apps]", r.limitApps, "")
	}
	if r.limitBetaGroups != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit[betaGroups]", r.limitBetaGroups, "")
	}
	if r.limitBuilds != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit[builds]", r.limitBuilds, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiBetaTestersGetInstanceRequest struct {
	ctx               context.Context
	ApiService        *BetaTestersApiService
	id                string
	fieldsBetaTesters *[]string
	include           *[]string
	fieldsApps        *[]string
	fieldsBuilds      *[]string
	fieldsBetaGroups  *[]string
	limitApps         *int32
	limitBetaGroups   *int32
	limitBuilds       *int32
}

// the fields to include for returned resources of type betaTesters
func (r ApiBetaTestersGetInstanceRequest) FieldsBetaTesters(fieldsBetaTesters []string) ApiBetaTestersGetInstanceRequest {
	r.fieldsBetaTesters = &fieldsBetaTesters
	return r
}

// comma-separated list of relationships to include
func (r ApiBetaTestersGetInstanceRequest) Include(include []string) ApiBetaTestersGetInstanceRequest {
	r.include = &include
	return r
}

// the fields to include for returned resources of type apps
func (r ApiBetaTestersGetInstanceRequest) FieldsApps(fieldsApps []string) ApiBetaTestersGetInstanceRequest {
	r.fieldsApps = &fieldsApps
	return r
}

// the fields to include for returned resources of type builds
func (r ApiBetaTestersGetInstanceRequest) FieldsBuilds(fieldsBuilds []string) ApiBetaTestersGetInstanceRequest {
	r.fieldsBuilds = &fieldsBuilds
	return r
}

// the fields to include for returned resources of type betaGroups
func (r ApiBetaTestersGetInstanceRequest) FieldsBetaGroups(fieldsBetaGroups []string) ApiBetaTestersGetInstanceRequest {
	r.fieldsBetaGroups = &fieldsBetaGroups
	return r
}

// maximum number of related apps returned (when they are included)
func (r ApiBetaTestersGetInstanceRequest) LimitApps(limitApps int32) ApiBetaTestersGetInstanceRequest {
	r.limitApps = &limitApps
	return r
}

// maximum number of related betaGroups returned (when they are included)
func (r ApiBetaTestersGetInstanceRequest) LimitBetaGroups(limitBetaGroups int32) ApiBetaTestersGetInstanceRequest {
	r.limitBetaGroups = &limitBetaGroups
	return r
}

// maximum number of related builds returned (when they are included)
func (r ApiBetaTestersGetInstanceRequest) LimitBuilds(limitBuilds int32) ApiBetaTestersGetInstanceRequest {
	r.limitBuilds = &limitBuilds
	return r
}

func (r ApiBetaTestersGetInstanceRequest) Execute() (*BetaTesterResponse, *http.Response, error) {
	return r.ApiService.BetaTestersGetInstanceExecute(r)
}

/*
BetaTestersGetInstance Method for BetaTestersGetInstance

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id the id of the requested resource
	@return ApiBetaTestersGetInstanceRequest
*/
func (a *BetaTestersApiService) BetaTestersGetInstance(ctx context.Context, id string) ApiBetaTestersGetInstanceRequest {
	return ApiBetaTestersGetInstanceRequest{
		ApiService: a,
		ctx:        ctx,
		id:         id,
	}
}

// Execute executes the request
//
//	@return BetaTesterResponse
func (a *BetaTestersApiService) BetaTestersGetInstanceExecute(r ApiBetaTestersGetInstanceRequest) (*BetaTesterResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *BetaTesterResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BetaTestersApiService.BetaTestersGetInstance")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/betaTesters/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.fieldsBetaTesters != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields[betaTesters]", r.fieldsBetaTesters, "csv")
	}
	if r.include != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "include", r.include, "csv")
	}
	if r.fieldsApps != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields[apps]", r.fieldsApps, "csv")
	}
	if r.fieldsBuilds != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields[builds]", r.fieldsBuilds, "csv")
	}
	if r.fieldsBetaGroups != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields[betaGroups]", r.fieldsBetaGroups, "csv")
	}
	if r.limitApps != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit[apps]", r.limitApps, "")
	}
	if r.limitBetaGroups != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit[betaGroups]", r.limitBetaGroups, "")
	}
	if r.limitBuilds != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit[builds]", r.limitBuilds, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
