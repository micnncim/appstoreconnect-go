/*
App Store Connect API

No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)

API version: 3.0
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package appstoreconnect

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"strings"
)

// AppsApiService AppsApi service
type AppsApiService service

type ApiAppsAppAvailabilityGetToOneRelatedRequest struct {
	ctx                       context.Context
	ApiService                *AppsApiService
	id                        string
	fieldsAppAvailabilities   *[]string
	fieldsApps                *[]string
	fieldsTerritories         *[]string
	limitAvailableTerritories *int32
	include                   *[]string
}

// the fields to include for returned resources of type appAvailabilities
func (r ApiAppsAppAvailabilityGetToOneRelatedRequest) FieldsAppAvailabilities(fieldsAppAvailabilities []string) ApiAppsAppAvailabilityGetToOneRelatedRequest {
	r.fieldsAppAvailabilities = &fieldsAppAvailabilities
	return r
}

// the fields to include for returned resources of type apps
func (r ApiAppsAppAvailabilityGetToOneRelatedRequest) FieldsApps(fieldsApps []string) ApiAppsAppAvailabilityGetToOneRelatedRequest {
	r.fieldsApps = &fieldsApps
	return r
}

// the fields to include for returned resources of type territories
func (r ApiAppsAppAvailabilityGetToOneRelatedRequest) FieldsTerritories(fieldsTerritories []string) ApiAppsAppAvailabilityGetToOneRelatedRequest {
	r.fieldsTerritories = &fieldsTerritories
	return r
}

// maximum number of related availableTerritories returned (when they are included)
func (r ApiAppsAppAvailabilityGetToOneRelatedRequest) LimitAvailableTerritories(limitAvailableTerritories int32) ApiAppsAppAvailabilityGetToOneRelatedRequest {
	r.limitAvailableTerritories = &limitAvailableTerritories
	return r
}

// comma-separated list of relationships to include
func (r ApiAppsAppAvailabilityGetToOneRelatedRequest) Include(include []string) ApiAppsAppAvailabilityGetToOneRelatedRequest {
	r.include = &include
	return r
}

func (r ApiAppsAppAvailabilityGetToOneRelatedRequest) Execute() (*AppAvailabilityResponse, *http.Response, error) {
	return r.ApiService.AppsAppAvailabilityGetToOneRelatedExecute(r)
}

/*
AppsAppAvailabilityGetToOneRelated Method for AppsAppAvailabilityGetToOneRelated

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id the id of the requested resource
	@return ApiAppsAppAvailabilityGetToOneRelatedRequest
*/
func (a *AppsApiService) AppsAppAvailabilityGetToOneRelated(ctx context.Context, id string) ApiAppsAppAvailabilityGetToOneRelatedRequest {
	return ApiAppsAppAvailabilityGetToOneRelatedRequest{
		ApiService: a,
		ctx:        ctx,
		id:         id,
	}
}

// Execute executes the request
//
//	@return AppAvailabilityResponse
func (a *AppsApiService) AppsAppAvailabilityGetToOneRelatedExecute(r ApiAppsAppAvailabilityGetToOneRelatedRequest) (*AppAvailabilityResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *AppAvailabilityResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AppsApiService.AppsAppAvailabilityGetToOneRelated")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/apps/{id}/appAvailability"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.fieldsAppAvailabilities != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields[appAvailabilities]", r.fieldsAppAvailabilities, "csv")
	}
	if r.fieldsApps != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields[apps]", r.fieldsApps, "csv")
	}
	if r.fieldsTerritories != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields[territories]", r.fieldsTerritories, "csv")
	}
	if r.limitAvailableTerritories != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit[availableTerritories]", r.limitAvailableTerritories, "")
	}
	if r.include != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "include", r.include, "csv")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiAppsAppClipsGetToManyRelatedRequest struct {
	ctx                             context.Context
	ApiService                      *AppsApiService
	id                              string
	filterBundleId                  *[]string
	fieldsAppClips                  *[]string
	fieldsApps                      *[]string
	fieldsAppClipDefaultExperiences *[]string
	limit                           *int32
	limitAppClipDefaultExperiences  *int32
	include                         *[]string
}

// filter by attribute &#39;bundleId&#39;
func (r ApiAppsAppClipsGetToManyRelatedRequest) FilterBundleId(filterBundleId []string) ApiAppsAppClipsGetToManyRelatedRequest {
	r.filterBundleId = &filterBundleId
	return r
}

// the fields to include for returned resources of type appClips
func (r ApiAppsAppClipsGetToManyRelatedRequest) FieldsAppClips(fieldsAppClips []string) ApiAppsAppClipsGetToManyRelatedRequest {
	r.fieldsAppClips = &fieldsAppClips
	return r
}

// the fields to include for returned resources of type apps
func (r ApiAppsAppClipsGetToManyRelatedRequest) FieldsApps(fieldsApps []string) ApiAppsAppClipsGetToManyRelatedRequest {
	r.fieldsApps = &fieldsApps
	return r
}

// the fields to include for returned resources of type appClipDefaultExperiences
func (r ApiAppsAppClipsGetToManyRelatedRequest) FieldsAppClipDefaultExperiences(fieldsAppClipDefaultExperiences []string) ApiAppsAppClipsGetToManyRelatedRequest {
	r.fieldsAppClipDefaultExperiences = &fieldsAppClipDefaultExperiences
	return r
}

// maximum resources per page
func (r ApiAppsAppClipsGetToManyRelatedRequest) Limit(limit int32) ApiAppsAppClipsGetToManyRelatedRequest {
	r.limit = &limit
	return r
}

// maximum number of related appClipDefaultExperiences returned (when they are included)
func (r ApiAppsAppClipsGetToManyRelatedRequest) LimitAppClipDefaultExperiences(limitAppClipDefaultExperiences int32) ApiAppsAppClipsGetToManyRelatedRequest {
	r.limitAppClipDefaultExperiences = &limitAppClipDefaultExperiences
	return r
}

// comma-separated list of relationships to include
func (r ApiAppsAppClipsGetToManyRelatedRequest) Include(include []string) ApiAppsAppClipsGetToManyRelatedRequest {
	r.include = &include
	return r
}

func (r ApiAppsAppClipsGetToManyRelatedRequest) Execute() (*AppClipsResponse, *http.Response, error) {
	return r.ApiService.AppsAppClipsGetToManyRelatedExecute(r)
}

/*
AppsAppClipsGetToManyRelated Method for AppsAppClipsGetToManyRelated

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id the id of the requested resource
	@return ApiAppsAppClipsGetToManyRelatedRequest
*/
func (a *AppsApiService) AppsAppClipsGetToManyRelated(ctx context.Context, id string) ApiAppsAppClipsGetToManyRelatedRequest {
	return ApiAppsAppClipsGetToManyRelatedRequest{
		ApiService: a,
		ctx:        ctx,
		id:         id,
	}
}

// Execute executes the request
//
//	@return AppClipsResponse
func (a *AppsApiService) AppsAppClipsGetToManyRelatedExecute(r ApiAppsAppClipsGetToManyRelatedRequest) (*AppClipsResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *AppClipsResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AppsApiService.AppsAppClipsGetToManyRelated")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/apps/{id}/appClips"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.filterBundleId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter[bundleId]", r.filterBundleId, "csv")
	}
	if r.fieldsAppClips != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields[appClips]", r.fieldsAppClips, "csv")
	}
	if r.fieldsApps != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields[apps]", r.fieldsApps, "csv")
	}
	if r.fieldsAppClipDefaultExperiences != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields[appClipDefaultExperiences]", r.fieldsAppClipDefaultExperiences, "csv")
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "")
	}
	if r.limitAppClipDefaultExperiences != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit[appClipDefaultExperiences]", r.limitAppClipDefaultExperiences, "")
	}
	if r.include != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "include", r.include, "csv")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiAppsAppCustomProductPagesGetToManyRelatedRequest struct {
	ctx                                context.Context
	ApiService                         *AppsApiService
	id                                 string
	filterVisible                      *[]string
	fieldsAppCustomProductPages        *[]string
	fieldsAppCustomProductPageVersions *[]string
	fieldsApps                         *[]string
	limit                              *int32
	limitAppCustomProductPageVersions  *int32
	include                            *[]string
}

// filter by attribute &#39;visible&#39;
func (r ApiAppsAppCustomProductPagesGetToManyRelatedRequest) FilterVisible(filterVisible []string) ApiAppsAppCustomProductPagesGetToManyRelatedRequest {
	r.filterVisible = &filterVisible
	return r
}

// the fields to include for returned resources of type appCustomProductPages
func (r ApiAppsAppCustomProductPagesGetToManyRelatedRequest) FieldsAppCustomProductPages(fieldsAppCustomProductPages []string) ApiAppsAppCustomProductPagesGetToManyRelatedRequest {
	r.fieldsAppCustomProductPages = &fieldsAppCustomProductPages
	return r
}

// the fields to include for returned resources of type appCustomProductPageVersions
func (r ApiAppsAppCustomProductPagesGetToManyRelatedRequest) FieldsAppCustomProductPageVersions(fieldsAppCustomProductPageVersions []string) ApiAppsAppCustomProductPagesGetToManyRelatedRequest {
	r.fieldsAppCustomProductPageVersions = &fieldsAppCustomProductPageVersions
	return r
}

// the fields to include for returned resources of type apps
func (r ApiAppsAppCustomProductPagesGetToManyRelatedRequest) FieldsApps(fieldsApps []string) ApiAppsAppCustomProductPagesGetToManyRelatedRequest {
	r.fieldsApps = &fieldsApps
	return r
}

// maximum resources per page
func (r ApiAppsAppCustomProductPagesGetToManyRelatedRequest) Limit(limit int32) ApiAppsAppCustomProductPagesGetToManyRelatedRequest {
	r.limit = &limit
	return r
}

// maximum number of related appCustomProductPageVersions returned (when they are included)
func (r ApiAppsAppCustomProductPagesGetToManyRelatedRequest) LimitAppCustomProductPageVersions(limitAppCustomProductPageVersions int32) ApiAppsAppCustomProductPagesGetToManyRelatedRequest {
	r.limitAppCustomProductPageVersions = &limitAppCustomProductPageVersions
	return r
}

// comma-separated list of relationships to include
func (r ApiAppsAppCustomProductPagesGetToManyRelatedRequest) Include(include []string) ApiAppsAppCustomProductPagesGetToManyRelatedRequest {
	r.include = &include
	return r
}

func (r ApiAppsAppCustomProductPagesGetToManyRelatedRequest) Execute() (*AppCustomProductPagesResponse, *http.Response, error) {
	return r.ApiService.AppsAppCustomProductPagesGetToManyRelatedExecute(r)
}

/*
AppsAppCustomProductPagesGetToManyRelated Method for AppsAppCustomProductPagesGetToManyRelated

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id the id of the requested resource
	@return ApiAppsAppCustomProductPagesGetToManyRelatedRequest
*/
func (a *AppsApiService) AppsAppCustomProductPagesGetToManyRelated(ctx context.Context, id string) ApiAppsAppCustomProductPagesGetToManyRelatedRequest {
	return ApiAppsAppCustomProductPagesGetToManyRelatedRequest{
		ApiService: a,
		ctx:        ctx,
		id:         id,
	}
}

// Execute executes the request
//
//	@return AppCustomProductPagesResponse
func (a *AppsApiService) AppsAppCustomProductPagesGetToManyRelatedExecute(r ApiAppsAppCustomProductPagesGetToManyRelatedRequest) (*AppCustomProductPagesResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *AppCustomProductPagesResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AppsApiService.AppsAppCustomProductPagesGetToManyRelated")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/apps/{id}/appCustomProductPages"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.filterVisible != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter[visible]", r.filterVisible, "csv")
	}
	if r.fieldsAppCustomProductPages != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields[appCustomProductPages]", r.fieldsAppCustomProductPages, "csv")
	}
	if r.fieldsAppCustomProductPageVersions != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields[appCustomProductPageVersions]", r.fieldsAppCustomProductPageVersions, "csv")
	}
	if r.fieldsApps != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields[apps]", r.fieldsApps, "csv")
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "")
	}
	if r.limitAppCustomProductPageVersions != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit[appCustomProductPageVersions]", r.limitAppCustomProductPageVersions, "")
	}
	if r.include != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "include", r.include, "csv")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiAppsAppEncryptionDeclarationsGetToManyRelatedRequest struct {
	ctx                                     context.Context
	ApiService                              *AppsApiService
	id                                      string
	filterPlatform                          *[]string
	filterBuilds                            *[]string
	fieldsAppEncryptionDeclarations         *[]string
	fieldsApps                              *[]string
	fieldsAppEncryptionDeclarationDocuments *[]string
	fieldsBuilds                            *[]string
	limit                                   *int32
	limitBuilds                             *int32
	include                                 *[]string
}

// filter by attribute &#39;platform&#39;
func (r ApiAppsAppEncryptionDeclarationsGetToManyRelatedRequest) FilterPlatform(filterPlatform []string) ApiAppsAppEncryptionDeclarationsGetToManyRelatedRequest {
	r.filterPlatform = &filterPlatform
	return r
}

// filter by id(s) of related &#39;builds&#39;
func (r ApiAppsAppEncryptionDeclarationsGetToManyRelatedRequest) FilterBuilds(filterBuilds []string) ApiAppsAppEncryptionDeclarationsGetToManyRelatedRequest {
	r.filterBuilds = &filterBuilds
	return r
}

// the fields to include for returned resources of type appEncryptionDeclarations
func (r ApiAppsAppEncryptionDeclarationsGetToManyRelatedRequest) FieldsAppEncryptionDeclarations(fieldsAppEncryptionDeclarations []string) ApiAppsAppEncryptionDeclarationsGetToManyRelatedRequest {
	r.fieldsAppEncryptionDeclarations = &fieldsAppEncryptionDeclarations
	return r
}

// the fields to include for returned resources of type apps
func (r ApiAppsAppEncryptionDeclarationsGetToManyRelatedRequest) FieldsApps(fieldsApps []string) ApiAppsAppEncryptionDeclarationsGetToManyRelatedRequest {
	r.fieldsApps = &fieldsApps
	return r
}

// the fields to include for returned resources of type appEncryptionDeclarationDocuments
func (r ApiAppsAppEncryptionDeclarationsGetToManyRelatedRequest) FieldsAppEncryptionDeclarationDocuments(fieldsAppEncryptionDeclarationDocuments []string) ApiAppsAppEncryptionDeclarationsGetToManyRelatedRequest {
	r.fieldsAppEncryptionDeclarationDocuments = &fieldsAppEncryptionDeclarationDocuments
	return r
}

// the fields to include for returned resources of type builds
func (r ApiAppsAppEncryptionDeclarationsGetToManyRelatedRequest) FieldsBuilds(fieldsBuilds []string) ApiAppsAppEncryptionDeclarationsGetToManyRelatedRequest {
	r.fieldsBuilds = &fieldsBuilds
	return r
}

// maximum resources per page
func (r ApiAppsAppEncryptionDeclarationsGetToManyRelatedRequest) Limit(limit int32) ApiAppsAppEncryptionDeclarationsGetToManyRelatedRequest {
	r.limit = &limit
	return r
}

// maximum number of related builds returned (when they are included)
func (r ApiAppsAppEncryptionDeclarationsGetToManyRelatedRequest) LimitBuilds(limitBuilds int32) ApiAppsAppEncryptionDeclarationsGetToManyRelatedRequest {
	r.limitBuilds = &limitBuilds
	return r
}

// comma-separated list of relationships to include
func (r ApiAppsAppEncryptionDeclarationsGetToManyRelatedRequest) Include(include []string) ApiAppsAppEncryptionDeclarationsGetToManyRelatedRequest {
	r.include = &include
	return r
}

func (r ApiAppsAppEncryptionDeclarationsGetToManyRelatedRequest) Execute() (*AppEncryptionDeclarationsResponse, *http.Response, error) {
	return r.ApiService.AppsAppEncryptionDeclarationsGetToManyRelatedExecute(r)
}

/*
AppsAppEncryptionDeclarationsGetToManyRelated Method for AppsAppEncryptionDeclarationsGetToManyRelated

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id the id of the requested resource
	@return ApiAppsAppEncryptionDeclarationsGetToManyRelatedRequest
*/
func (a *AppsApiService) AppsAppEncryptionDeclarationsGetToManyRelated(ctx context.Context, id string) ApiAppsAppEncryptionDeclarationsGetToManyRelatedRequest {
	return ApiAppsAppEncryptionDeclarationsGetToManyRelatedRequest{
		ApiService: a,
		ctx:        ctx,
		id:         id,
	}
}

// Execute executes the request
//
//	@return AppEncryptionDeclarationsResponse
func (a *AppsApiService) AppsAppEncryptionDeclarationsGetToManyRelatedExecute(r ApiAppsAppEncryptionDeclarationsGetToManyRelatedRequest) (*AppEncryptionDeclarationsResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *AppEncryptionDeclarationsResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AppsApiService.AppsAppEncryptionDeclarationsGetToManyRelated")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/apps/{id}/appEncryptionDeclarations"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.filterPlatform != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter[platform]", r.filterPlatform, "csv")
	}
	if r.filterBuilds != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter[builds]", r.filterBuilds, "csv")
	}
	if r.fieldsAppEncryptionDeclarations != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields[appEncryptionDeclarations]", r.fieldsAppEncryptionDeclarations, "csv")
	}
	if r.fieldsApps != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields[apps]", r.fieldsApps, "csv")
	}
	if r.fieldsAppEncryptionDeclarationDocuments != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields[appEncryptionDeclarationDocuments]", r.fieldsAppEncryptionDeclarationDocuments, "csv")
	}
	if r.fieldsBuilds != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields[builds]", r.fieldsBuilds, "csv")
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "")
	}
	if r.limitBuilds != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit[builds]", r.limitBuilds, "")
	}
	if r.include != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "include", r.include, "csv")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiAppsAppEventsGetToManyRelatedRequest struct {
	ctx                         context.Context
	ApiService                  *AppsApiService
	id                          string
	filterEventState            *[]string
	filterId                    *[]string
	fieldsAppEventLocalizations *[]string
	fieldsAppEvents             *[]string
	limit                       *int32
	limitLocalizations          *int32
	include                     *[]string
}

// filter by attribute &#39;eventState&#39;
func (r ApiAppsAppEventsGetToManyRelatedRequest) FilterEventState(filterEventState []string) ApiAppsAppEventsGetToManyRelatedRequest {
	r.filterEventState = &filterEventState
	return r
}

// filter by id(s)
func (r ApiAppsAppEventsGetToManyRelatedRequest) FilterId(filterId []string) ApiAppsAppEventsGetToManyRelatedRequest {
	r.filterId = &filterId
	return r
}

// the fields to include for returned resources of type appEventLocalizations
func (r ApiAppsAppEventsGetToManyRelatedRequest) FieldsAppEventLocalizations(fieldsAppEventLocalizations []string) ApiAppsAppEventsGetToManyRelatedRequest {
	r.fieldsAppEventLocalizations = &fieldsAppEventLocalizations
	return r
}

// the fields to include for returned resources of type appEvents
func (r ApiAppsAppEventsGetToManyRelatedRequest) FieldsAppEvents(fieldsAppEvents []string) ApiAppsAppEventsGetToManyRelatedRequest {
	r.fieldsAppEvents = &fieldsAppEvents
	return r
}

// maximum resources per page
func (r ApiAppsAppEventsGetToManyRelatedRequest) Limit(limit int32) ApiAppsAppEventsGetToManyRelatedRequest {
	r.limit = &limit
	return r
}

// maximum number of related localizations returned (when they are included)
func (r ApiAppsAppEventsGetToManyRelatedRequest) LimitLocalizations(limitLocalizations int32) ApiAppsAppEventsGetToManyRelatedRequest {
	r.limitLocalizations = &limitLocalizations
	return r
}

// comma-separated list of relationships to include
func (r ApiAppsAppEventsGetToManyRelatedRequest) Include(include []string) ApiAppsAppEventsGetToManyRelatedRequest {
	r.include = &include
	return r
}

func (r ApiAppsAppEventsGetToManyRelatedRequest) Execute() (*AppEventsResponse, *http.Response, error) {
	return r.ApiService.AppsAppEventsGetToManyRelatedExecute(r)
}

/*
AppsAppEventsGetToManyRelated Method for AppsAppEventsGetToManyRelated

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id the id of the requested resource
	@return ApiAppsAppEventsGetToManyRelatedRequest
*/
func (a *AppsApiService) AppsAppEventsGetToManyRelated(ctx context.Context, id string) ApiAppsAppEventsGetToManyRelatedRequest {
	return ApiAppsAppEventsGetToManyRelatedRequest{
		ApiService: a,
		ctx:        ctx,
		id:         id,
	}
}

// Execute executes the request
//
//	@return AppEventsResponse
func (a *AppsApiService) AppsAppEventsGetToManyRelatedExecute(r ApiAppsAppEventsGetToManyRelatedRequest) (*AppEventsResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *AppEventsResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AppsApiService.AppsAppEventsGetToManyRelated")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/apps/{id}/appEvents"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.filterEventState != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter[eventState]", r.filterEventState, "csv")
	}
	if r.filterId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter[id]", r.filterId, "csv")
	}
	if r.fieldsAppEventLocalizations != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields[appEventLocalizations]", r.fieldsAppEventLocalizations, "csv")
	}
	if r.fieldsAppEvents != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields[appEvents]", r.fieldsAppEvents, "csv")
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "")
	}
	if r.limitLocalizations != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit[localizations]", r.limitLocalizations, "")
	}
	if r.include != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "include", r.include, "csv")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiAppsAppInfosGetToManyRelatedRequest struct {
	ctx                         context.Context
	ApiService                  *AppsApiService
	id                          string
	fieldsAgeRatingDeclarations *[]string
	fieldsAppInfos              *[]string
	fieldsAppInfoLocalizations  *[]string
	fieldsAppCategories         *[]string
	fieldsApps                  *[]string
	limit                       *int32
	limitAppInfoLocalizations   *int32
	include                     *[]string
}

// the fields to include for returned resources of type ageRatingDeclarations
func (r ApiAppsAppInfosGetToManyRelatedRequest) FieldsAgeRatingDeclarations(fieldsAgeRatingDeclarations []string) ApiAppsAppInfosGetToManyRelatedRequest {
	r.fieldsAgeRatingDeclarations = &fieldsAgeRatingDeclarations
	return r
}

// the fields to include for returned resources of type appInfos
func (r ApiAppsAppInfosGetToManyRelatedRequest) FieldsAppInfos(fieldsAppInfos []string) ApiAppsAppInfosGetToManyRelatedRequest {
	r.fieldsAppInfos = &fieldsAppInfos
	return r
}

// the fields to include for returned resources of type appInfoLocalizations
func (r ApiAppsAppInfosGetToManyRelatedRequest) FieldsAppInfoLocalizations(fieldsAppInfoLocalizations []string) ApiAppsAppInfosGetToManyRelatedRequest {
	r.fieldsAppInfoLocalizations = &fieldsAppInfoLocalizations
	return r
}

// the fields to include for returned resources of type appCategories
func (r ApiAppsAppInfosGetToManyRelatedRequest) FieldsAppCategories(fieldsAppCategories []string) ApiAppsAppInfosGetToManyRelatedRequest {
	r.fieldsAppCategories = &fieldsAppCategories
	return r
}

// the fields to include for returned resources of type apps
func (r ApiAppsAppInfosGetToManyRelatedRequest) FieldsApps(fieldsApps []string) ApiAppsAppInfosGetToManyRelatedRequest {
	r.fieldsApps = &fieldsApps
	return r
}

// maximum resources per page
func (r ApiAppsAppInfosGetToManyRelatedRequest) Limit(limit int32) ApiAppsAppInfosGetToManyRelatedRequest {
	r.limit = &limit
	return r
}

// maximum number of related appInfoLocalizations returned (when they are included)
func (r ApiAppsAppInfosGetToManyRelatedRequest) LimitAppInfoLocalizations(limitAppInfoLocalizations int32) ApiAppsAppInfosGetToManyRelatedRequest {
	r.limitAppInfoLocalizations = &limitAppInfoLocalizations
	return r
}

// comma-separated list of relationships to include
func (r ApiAppsAppInfosGetToManyRelatedRequest) Include(include []string) ApiAppsAppInfosGetToManyRelatedRequest {
	r.include = &include
	return r
}

func (r ApiAppsAppInfosGetToManyRelatedRequest) Execute() (*AppInfosResponse, *http.Response, error) {
	return r.ApiService.AppsAppInfosGetToManyRelatedExecute(r)
}

/*
AppsAppInfosGetToManyRelated Method for AppsAppInfosGetToManyRelated

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id the id of the requested resource
	@return ApiAppsAppInfosGetToManyRelatedRequest
*/
func (a *AppsApiService) AppsAppInfosGetToManyRelated(ctx context.Context, id string) ApiAppsAppInfosGetToManyRelatedRequest {
	return ApiAppsAppInfosGetToManyRelatedRequest{
		ApiService: a,
		ctx:        ctx,
		id:         id,
	}
}

// Execute executes the request
//
//	@return AppInfosResponse
func (a *AppsApiService) AppsAppInfosGetToManyRelatedExecute(r ApiAppsAppInfosGetToManyRelatedRequest) (*AppInfosResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *AppInfosResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AppsApiService.AppsAppInfosGetToManyRelated")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/apps/{id}/appInfos"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.fieldsAgeRatingDeclarations != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields[ageRatingDeclarations]", r.fieldsAgeRatingDeclarations, "csv")
	}
	if r.fieldsAppInfos != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields[appInfos]", r.fieldsAppInfos, "csv")
	}
	if r.fieldsAppInfoLocalizations != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields[appInfoLocalizations]", r.fieldsAppInfoLocalizations, "csv")
	}
	if r.fieldsAppCategories != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields[appCategories]", r.fieldsAppCategories, "csv")
	}
	if r.fieldsApps != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields[apps]", r.fieldsApps, "csv")
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "")
	}
	if r.limitAppInfoLocalizations != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit[appInfoLocalizations]", r.limitAppInfoLocalizations, "")
	}
	if r.include != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "include", r.include, "csv")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiAppsAppPricePointsGetToManyRelatedRequest struct {
	ctx                  context.Context
	ApiService           *AppsApiService
	id                   string
	filterTerritory      *[]string
	fieldsAppPricePoints *[]string
	fieldsApps           *[]string
	fieldsTerritories    *[]string
	limit                *int32
	include              *[]string
}

// filter by id(s) of related &#39;territory&#39;
func (r ApiAppsAppPricePointsGetToManyRelatedRequest) FilterTerritory(filterTerritory []string) ApiAppsAppPricePointsGetToManyRelatedRequest {
	r.filterTerritory = &filterTerritory
	return r
}

// the fields to include for returned resources of type appPricePoints
func (r ApiAppsAppPricePointsGetToManyRelatedRequest) FieldsAppPricePoints(fieldsAppPricePoints []string) ApiAppsAppPricePointsGetToManyRelatedRequest {
	r.fieldsAppPricePoints = &fieldsAppPricePoints
	return r
}

// the fields to include for returned resources of type apps
func (r ApiAppsAppPricePointsGetToManyRelatedRequest) FieldsApps(fieldsApps []string) ApiAppsAppPricePointsGetToManyRelatedRequest {
	r.fieldsApps = &fieldsApps
	return r
}

// the fields to include for returned resources of type territories
func (r ApiAppsAppPricePointsGetToManyRelatedRequest) FieldsTerritories(fieldsTerritories []string) ApiAppsAppPricePointsGetToManyRelatedRequest {
	r.fieldsTerritories = &fieldsTerritories
	return r
}

// maximum resources per page
func (r ApiAppsAppPricePointsGetToManyRelatedRequest) Limit(limit int32) ApiAppsAppPricePointsGetToManyRelatedRequest {
	r.limit = &limit
	return r
}

// comma-separated list of relationships to include
func (r ApiAppsAppPricePointsGetToManyRelatedRequest) Include(include []string) ApiAppsAppPricePointsGetToManyRelatedRequest {
	r.include = &include
	return r
}

func (r ApiAppsAppPricePointsGetToManyRelatedRequest) Execute() (*AppPricePointsV3Response, *http.Response, error) {
	return r.ApiService.AppsAppPricePointsGetToManyRelatedExecute(r)
}

/*
AppsAppPricePointsGetToManyRelated Method for AppsAppPricePointsGetToManyRelated

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id the id of the requested resource
	@return ApiAppsAppPricePointsGetToManyRelatedRequest
*/
func (a *AppsApiService) AppsAppPricePointsGetToManyRelated(ctx context.Context, id string) ApiAppsAppPricePointsGetToManyRelatedRequest {
	return ApiAppsAppPricePointsGetToManyRelatedRequest{
		ApiService: a,
		ctx:        ctx,
		id:         id,
	}
}

// Execute executes the request
//
//	@return AppPricePointsV3Response
func (a *AppsApiService) AppsAppPricePointsGetToManyRelatedExecute(r ApiAppsAppPricePointsGetToManyRelatedRequest) (*AppPricePointsV3Response, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *AppPricePointsV3Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AppsApiService.AppsAppPricePointsGetToManyRelated")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/apps/{id}/appPricePoints"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.filterTerritory != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter[territory]", r.filterTerritory, "csv")
	}
	if r.fieldsAppPricePoints != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields[appPricePoints]", r.fieldsAppPricePoints, "csv")
	}
	if r.fieldsApps != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields[apps]", r.fieldsApps, "csv")
	}
	if r.fieldsTerritories != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields[territories]", r.fieldsTerritories, "csv")
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "")
	}
	if r.include != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "include", r.include, "csv")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiAppsAppPriceScheduleGetToOneRelatedRequest struct {
	ctx                     context.Context
	ApiService              *AppsApiService
	id                      string
	fieldsAppPrices         *[]string
	fieldsAppPriceSchedules *[]string
	fieldsApps              *[]string
	fieldsTerritories       *[]string
	limitManualPrices       *int32
	limitAutomaticPrices    *int32
	include                 *[]string
}

// the fields to include for returned resources of type appPrices
func (r ApiAppsAppPriceScheduleGetToOneRelatedRequest) FieldsAppPrices(fieldsAppPrices []string) ApiAppsAppPriceScheduleGetToOneRelatedRequest {
	r.fieldsAppPrices = &fieldsAppPrices
	return r
}

// the fields to include for returned resources of type appPriceSchedules
func (r ApiAppsAppPriceScheduleGetToOneRelatedRequest) FieldsAppPriceSchedules(fieldsAppPriceSchedules []string) ApiAppsAppPriceScheduleGetToOneRelatedRequest {
	r.fieldsAppPriceSchedules = &fieldsAppPriceSchedules
	return r
}

// the fields to include for returned resources of type apps
func (r ApiAppsAppPriceScheduleGetToOneRelatedRequest) FieldsApps(fieldsApps []string) ApiAppsAppPriceScheduleGetToOneRelatedRequest {
	r.fieldsApps = &fieldsApps
	return r
}

// the fields to include for returned resources of type territories
func (r ApiAppsAppPriceScheduleGetToOneRelatedRequest) FieldsTerritories(fieldsTerritories []string) ApiAppsAppPriceScheduleGetToOneRelatedRequest {
	r.fieldsTerritories = &fieldsTerritories
	return r
}

// maximum number of related manualPrices returned (when they are included)
func (r ApiAppsAppPriceScheduleGetToOneRelatedRequest) LimitManualPrices(limitManualPrices int32) ApiAppsAppPriceScheduleGetToOneRelatedRequest {
	r.limitManualPrices = &limitManualPrices
	return r
}

// maximum number of related automaticPrices returned (when they are included)
func (r ApiAppsAppPriceScheduleGetToOneRelatedRequest) LimitAutomaticPrices(limitAutomaticPrices int32) ApiAppsAppPriceScheduleGetToOneRelatedRequest {
	r.limitAutomaticPrices = &limitAutomaticPrices
	return r
}

// comma-separated list of relationships to include
func (r ApiAppsAppPriceScheduleGetToOneRelatedRequest) Include(include []string) ApiAppsAppPriceScheduleGetToOneRelatedRequest {
	r.include = &include
	return r
}

func (r ApiAppsAppPriceScheduleGetToOneRelatedRequest) Execute() (*AppPriceScheduleResponse, *http.Response, error) {
	return r.ApiService.AppsAppPriceScheduleGetToOneRelatedExecute(r)
}

/*
AppsAppPriceScheduleGetToOneRelated Method for AppsAppPriceScheduleGetToOneRelated

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id the id of the requested resource
	@return ApiAppsAppPriceScheduleGetToOneRelatedRequest
*/
func (a *AppsApiService) AppsAppPriceScheduleGetToOneRelated(ctx context.Context, id string) ApiAppsAppPriceScheduleGetToOneRelatedRequest {
	return ApiAppsAppPriceScheduleGetToOneRelatedRequest{
		ApiService: a,
		ctx:        ctx,
		id:         id,
	}
}

// Execute executes the request
//
//	@return AppPriceScheduleResponse
func (a *AppsApiService) AppsAppPriceScheduleGetToOneRelatedExecute(r ApiAppsAppPriceScheduleGetToOneRelatedRequest) (*AppPriceScheduleResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *AppPriceScheduleResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AppsApiService.AppsAppPriceScheduleGetToOneRelated")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/apps/{id}/appPriceSchedule"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.fieldsAppPrices != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields[appPrices]", r.fieldsAppPrices, "csv")
	}
	if r.fieldsAppPriceSchedules != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields[appPriceSchedules]", r.fieldsAppPriceSchedules, "csv")
	}
	if r.fieldsApps != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields[apps]", r.fieldsApps, "csv")
	}
	if r.fieldsTerritories != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields[territories]", r.fieldsTerritories, "csv")
	}
	if r.limitManualPrices != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit[manualPrices]", r.limitManualPrices, "")
	}
	if r.limitAutomaticPrices != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit[automaticPrices]", r.limitAutomaticPrices, "")
	}
	if r.include != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "include", r.include, "csv")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiAppsAppStoreVersionExperimentsV2GetToManyRelatedRequest struct {
	ctx                                       context.Context
	ApiService                                *AppsApiService
	id                                        string
	filterState                               *[]string
	fieldsAppStoreVersionExperiments          *[]string
	fieldsAppStoreVersionExperimentTreatments *[]string
	fieldsAppStoreVersions                    *[]string
	fieldsApps                                *[]string
	limit                                     *int32
	limitControlVersions                      *int32
	limitAppStoreVersionExperimentTreatments  *int32
	include                                   *[]string
}

// filter by attribute &#39;state&#39;
func (r ApiAppsAppStoreVersionExperimentsV2GetToManyRelatedRequest) FilterState(filterState []string) ApiAppsAppStoreVersionExperimentsV2GetToManyRelatedRequest {
	r.filterState = &filterState
	return r
}

// the fields to include for returned resources of type appStoreVersionExperiments
func (r ApiAppsAppStoreVersionExperimentsV2GetToManyRelatedRequest) FieldsAppStoreVersionExperiments(fieldsAppStoreVersionExperiments []string) ApiAppsAppStoreVersionExperimentsV2GetToManyRelatedRequest {
	r.fieldsAppStoreVersionExperiments = &fieldsAppStoreVersionExperiments
	return r
}

// the fields to include for returned resources of type appStoreVersionExperimentTreatments
func (r ApiAppsAppStoreVersionExperimentsV2GetToManyRelatedRequest) FieldsAppStoreVersionExperimentTreatments(fieldsAppStoreVersionExperimentTreatments []string) ApiAppsAppStoreVersionExperimentsV2GetToManyRelatedRequest {
	r.fieldsAppStoreVersionExperimentTreatments = &fieldsAppStoreVersionExperimentTreatments
	return r
}

// the fields to include for returned resources of type appStoreVersions
func (r ApiAppsAppStoreVersionExperimentsV2GetToManyRelatedRequest) FieldsAppStoreVersions(fieldsAppStoreVersions []string) ApiAppsAppStoreVersionExperimentsV2GetToManyRelatedRequest {
	r.fieldsAppStoreVersions = &fieldsAppStoreVersions
	return r
}

// the fields to include for returned resources of type apps
func (r ApiAppsAppStoreVersionExperimentsV2GetToManyRelatedRequest) FieldsApps(fieldsApps []string) ApiAppsAppStoreVersionExperimentsV2GetToManyRelatedRequest {
	r.fieldsApps = &fieldsApps
	return r
}

// maximum resources per page
func (r ApiAppsAppStoreVersionExperimentsV2GetToManyRelatedRequest) Limit(limit int32) ApiAppsAppStoreVersionExperimentsV2GetToManyRelatedRequest {
	r.limit = &limit
	return r
}

// maximum number of related controlVersions returned (when they are included)
func (r ApiAppsAppStoreVersionExperimentsV2GetToManyRelatedRequest) LimitControlVersions(limitControlVersions int32) ApiAppsAppStoreVersionExperimentsV2GetToManyRelatedRequest {
	r.limitControlVersions = &limitControlVersions
	return r
}

// maximum number of related appStoreVersionExperimentTreatments returned (when they are included)
func (r ApiAppsAppStoreVersionExperimentsV2GetToManyRelatedRequest) LimitAppStoreVersionExperimentTreatments(limitAppStoreVersionExperimentTreatments int32) ApiAppsAppStoreVersionExperimentsV2GetToManyRelatedRequest {
	r.limitAppStoreVersionExperimentTreatments = &limitAppStoreVersionExperimentTreatments
	return r
}

// comma-separated list of relationships to include
func (r ApiAppsAppStoreVersionExperimentsV2GetToManyRelatedRequest) Include(include []string) ApiAppsAppStoreVersionExperimentsV2GetToManyRelatedRequest {
	r.include = &include
	return r
}

func (r ApiAppsAppStoreVersionExperimentsV2GetToManyRelatedRequest) Execute() (*AppStoreVersionExperimentsV2Response, *http.Response, error) {
	return r.ApiService.AppsAppStoreVersionExperimentsV2GetToManyRelatedExecute(r)
}

/*
AppsAppStoreVersionExperimentsV2GetToManyRelated Method for AppsAppStoreVersionExperimentsV2GetToManyRelated

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id the id of the requested resource
	@return ApiAppsAppStoreVersionExperimentsV2GetToManyRelatedRequest
*/
func (a *AppsApiService) AppsAppStoreVersionExperimentsV2GetToManyRelated(ctx context.Context, id string) ApiAppsAppStoreVersionExperimentsV2GetToManyRelatedRequest {
	return ApiAppsAppStoreVersionExperimentsV2GetToManyRelatedRequest{
		ApiService: a,
		ctx:        ctx,
		id:         id,
	}
}

// Execute executes the request
//
//	@return AppStoreVersionExperimentsV2Response
func (a *AppsApiService) AppsAppStoreVersionExperimentsV2GetToManyRelatedExecute(r ApiAppsAppStoreVersionExperimentsV2GetToManyRelatedRequest) (*AppStoreVersionExperimentsV2Response, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *AppStoreVersionExperimentsV2Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AppsApiService.AppsAppStoreVersionExperimentsV2GetToManyRelated")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/apps/{id}/appStoreVersionExperimentsV2"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.filterState != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter[state]", r.filterState, "csv")
	}
	if r.fieldsAppStoreVersionExperiments != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields[appStoreVersionExperiments]", r.fieldsAppStoreVersionExperiments, "csv")
	}
	if r.fieldsAppStoreVersionExperimentTreatments != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields[appStoreVersionExperimentTreatments]", r.fieldsAppStoreVersionExperimentTreatments, "csv")
	}
	if r.fieldsAppStoreVersions != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields[appStoreVersions]", r.fieldsAppStoreVersions, "csv")
	}
	if r.fieldsApps != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields[apps]", r.fieldsApps, "csv")
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "")
	}
	if r.limitControlVersions != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit[controlVersions]", r.limitControlVersions, "")
	}
	if r.limitAppStoreVersionExperimentTreatments != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit[appStoreVersionExperimentTreatments]", r.limitAppStoreVersionExperimentTreatments, "")
	}
	if r.include != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "include", r.include, "csv")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiAppsAppStoreVersionsGetToManyRelatedRequest struct {
	ctx                                 context.Context
	ApiService                          *AppsApiService
	id                                  string
	filterAppStoreState                 *[]string
	filterPlatform                      *[]string
	filterVersionString                 *[]string
	filterId                            *[]string
	fieldsAppStoreVersionExperiments    *[]string
	fieldsAgeRatingDeclarations         *[]string
	fieldsAppStoreVersionSubmissions    *[]string
	fieldsAppStoreReviewDetails         *[]string
	fieldsAppStoreVersions              *[]string
	fieldsApps                          *[]string
	fieldsRoutingAppCoverages           *[]string
	fieldsAppClipDefaultExperiences     *[]string
	fieldsAppStoreVersionPhasedReleases *[]string
	fieldsBuilds                        *[]string
	fieldsAppStoreVersionLocalizations  *[]string
	limit                               *int32
	limitAppStoreVersionLocalizations   *int32
	limitAppStoreVersionExperiments     *int32
	limitAppStoreVersionExperimentsV2   *int32
	include                             *[]string
}

// filter by attribute &#39;appStoreState&#39;
func (r ApiAppsAppStoreVersionsGetToManyRelatedRequest) FilterAppStoreState(filterAppStoreState []string) ApiAppsAppStoreVersionsGetToManyRelatedRequest {
	r.filterAppStoreState = &filterAppStoreState
	return r
}

// filter by attribute &#39;platform&#39;
func (r ApiAppsAppStoreVersionsGetToManyRelatedRequest) FilterPlatform(filterPlatform []string) ApiAppsAppStoreVersionsGetToManyRelatedRequest {
	r.filterPlatform = &filterPlatform
	return r
}

// filter by attribute &#39;versionString&#39;
func (r ApiAppsAppStoreVersionsGetToManyRelatedRequest) FilterVersionString(filterVersionString []string) ApiAppsAppStoreVersionsGetToManyRelatedRequest {
	r.filterVersionString = &filterVersionString
	return r
}

// filter by id(s)
func (r ApiAppsAppStoreVersionsGetToManyRelatedRequest) FilterId(filterId []string) ApiAppsAppStoreVersionsGetToManyRelatedRequest {
	r.filterId = &filterId
	return r
}

// the fields to include for returned resources of type appStoreVersionExperiments
func (r ApiAppsAppStoreVersionsGetToManyRelatedRequest) FieldsAppStoreVersionExperiments(fieldsAppStoreVersionExperiments []string) ApiAppsAppStoreVersionsGetToManyRelatedRequest {
	r.fieldsAppStoreVersionExperiments = &fieldsAppStoreVersionExperiments
	return r
}

// the fields to include for returned resources of type ageRatingDeclarations
func (r ApiAppsAppStoreVersionsGetToManyRelatedRequest) FieldsAgeRatingDeclarations(fieldsAgeRatingDeclarations []string) ApiAppsAppStoreVersionsGetToManyRelatedRequest {
	r.fieldsAgeRatingDeclarations = &fieldsAgeRatingDeclarations
	return r
}

// the fields to include for returned resources of type appStoreVersionSubmissions
func (r ApiAppsAppStoreVersionsGetToManyRelatedRequest) FieldsAppStoreVersionSubmissions(fieldsAppStoreVersionSubmissions []string) ApiAppsAppStoreVersionsGetToManyRelatedRequest {
	r.fieldsAppStoreVersionSubmissions = &fieldsAppStoreVersionSubmissions
	return r
}

// the fields to include for returned resources of type appStoreReviewDetails
func (r ApiAppsAppStoreVersionsGetToManyRelatedRequest) FieldsAppStoreReviewDetails(fieldsAppStoreReviewDetails []string) ApiAppsAppStoreVersionsGetToManyRelatedRequest {
	r.fieldsAppStoreReviewDetails = &fieldsAppStoreReviewDetails
	return r
}

// the fields to include for returned resources of type appStoreVersions
func (r ApiAppsAppStoreVersionsGetToManyRelatedRequest) FieldsAppStoreVersions(fieldsAppStoreVersions []string) ApiAppsAppStoreVersionsGetToManyRelatedRequest {
	r.fieldsAppStoreVersions = &fieldsAppStoreVersions
	return r
}

// the fields to include for returned resources of type apps
func (r ApiAppsAppStoreVersionsGetToManyRelatedRequest) FieldsApps(fieldsApps []string) ApiAppsAppStoreVersionsGetToManyRelatedRequest {
	r.fieldsApps = &fieldsApps
	return r
}

// the fields to include for returned resources of type routingAppCoverages
func (r ApiAppsAppStoreVersionsGetToManyRelatedRequest) FieldsRoutingAppCoverages(fieldsRoutingAppCoverages []string) ApiAppsAppStoreVersionsGetToManyRelatedRequest {
	r.fieldsRoutingAppCoverages = &fieldsRoutingAppCoverages
	return r
}

// the fields to include for returned resources of type appClipDefaultExperiences
func (r ApiAppsAppStoreVersionsGetToManyRelatedRequest) FieldsAppClipDefaultExperiences(fieldsAppClipDefaultExperiences []string) ApiAppsAppStoreVersionsGetToManyRelatedRequest {
	r.fieldsAppClipDefaultExperiences = &fieldsAppClipDefaultExperiences
	return r
}

// the fields to include for returned resources of type appStoreVersionPhasedReleases
func (r ApiAppsAppStoreVersionsGetToManyRelatedRequest) FieldsAppStoreVersionPhasedReleases(fieldsAppStoreVersionPhasedReleases []string) ApiAppsAppStoreVersionsGetToManyRelatedRequest {
	r.fieldsAppStoreVersionPhasedReleases = &fieldsAppStoreVersionPhasedReleases
	return r
}

// the fields to include for returned resources of type builds
func (r ApiAppsAppStoreVersionsGetToManyRelatedRequest) FieldsBuilds(fieldsBuilds []string) ApiAppsAppStoreVersionsGetToManyRelatedRequest {
	r.fieldsBuilds = &fieldsBuilds
	return r
}

// the fields to include for returned resources of type appStoreVersionLocalizations
func (r ApiAppsAppStoreVersionsGetToManyRelatedRequest) FieldsAppStoreVersionLocalizations(fieldsAppStoreVersionLocalizations []string) ApiAppsAppStoreVersionsGetToManyRelatedRequest {
	r.fieldsAppStoreVersionLocalizations = &fieldsAppStoreVersionLocalizations
	return r
}

// maximum resources per page
func (r ApiAppsAppStoreVersionsGetToManyRelatedRequest) Limit(limit int32) ApiAppsAppStoreVersionsGetToManyRelatedRequest {
	r.limit = &limit
	return r
}

// maximum number of related appStoreVersionLocalizations returned (when they are included)
func (r ApiAppsAppStoreVersionsGetToManyRelatedRequest) LimitAppStoreVersionLocalizations(limitAppStoreVersionLocalizations int32) ApiAppsAppStoreVersionsGetToManyRelatedRequest {
	r.limitAppStoreVersionLocalizations = &limitAppStoreVersionLocalizations
	return r
}

// maximum number of related appStoreVersionExperiments returned (when they are included)
// Deprecated
func (r ApiAppsAppStoreVersionsGetToManyRelatedRequest) LimitAppStoreVersionExperiments(limitAppStoreVersionExperiments int32) ApiAppsAppStoreVersionsGetToManyRelatedRequest {
	r.limitAppStoreVersionExperiments = &limitAppStoreVersionExperiments
	return r
}

// maximum number of related appStoreVersionExperimentsV2 returned (when they are included)
func (r ApiAppsAppStoreVersionsGetToManyRelatedRequest) LimitAppStoreVersionExperimentsV2(limitAppStoreVersionExperimentsV2 int32) ApiAppsAppStoreVersionsGetToManyRelatedRequest {
	r.limitAppStoreVersionExperimentsV2 = &limitAppStoreVersionExperimentsV2
	return r
}

// comma-separated list of relationships to include
func (r ApiAppsAppStoreVersionsGetToManyRelatedRequest) Include(include []string) ApiAppsAppStoreVersionsGetToManyRelatedRequest {
	r.include = &include
	return r
}

func (r ApiAppsAppStoreVersionsGetToManyRelatedRequest) Execute() (*AppStoreVersionsResponse, *http.Response, error) {
	return r.ApiService.AppsAppStoreVersionsGetToManyRelatedExecute(r)
}

/*
AppsAppStoreVersionsGetToManyRelated Method for AppsAppStoreVersionsGetToManyRelated

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id the id of the requested resource
	@return ApiAppsAppStoreVersionsGetToManyRelatedRequest
*/
func (a *AppsApiService) AppsAppStoreVersionsGetToManyRelated(ctx context.Context, id string) ApiAppsAppStoreVersionsGetToManyRelatedRequest {
	return ApiAppsAppStoreVersionsGetToManyRelatedRequest{
		ApiService: a,
		ctx:        ctx,
		id:         id,
	}
}

// Execute executes the request
//
//	@return AppStoreVersionsResponse
func (a *AppsApiService) AppsAppStoreVersionsGetToManyRelatedExecute(r ApiAppsAppStoreVersionsGetToManyRelatedRequest) (*AppStoreVersionsResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *AppStoreVersionsResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AppsApiService.AppsAppStoreVersionsGetToManyRelated")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/apps/{id}/appStoreVersions"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.filterAppStoreState != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter[appStoreState]", r.filterAppStoreState, "csv")
	}
	if r.filterPlatform != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter[platform]", r.filterPlatform, "csv")
	}
	if r.filterVersionString != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter[versionString]", r.filterVersionString, "csv")
	}
	if r.filterId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter[id]", r.filterId, "csv")
	}
	if r.fieldsAppStoreVersionExperiments != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields[appStoreVersionExperiments]", r.fieldsAppStoreVersionExperiments, "csv")
	}
	if r.fieldsAgeRatingDeclarations != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields[ageRatingDeclarations]", r.fieldsAgeRatingDeclarations, "csv")
	}
	if r.fieldsAppStoreVersionSubmissions != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields[appStoreVersionSubmissions]", r.fieldsAppStoreVersionSubmissions, "csv")
	}
	if r.fieldsAppStoreReviewDetails != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields[appStoreReviewDetails]", r.fieldsAppStoreReviewDetails, "csv")
	}
	if r.fieldsAppStoreVersions != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields[appStoreVersions]", r.fieldsAppStoreVersions, "csv")
	}
	if r.fieldsApps != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields[apps]", r.fieldsApps, "csv")
	}
	if r.fieldsRoutingAppCoverages != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields[routingAppCoverages]", r.fieldsRoutingAppCoverages, "csv")
	}
	if r.fieldsAppClipDefaultExperiences != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields[appClipDefaultExperiences]", r.fieldsAppClipDefaultExperiences, "csv")
	}
	if r.fieldsAppStoreVersionPhasedReleases != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields[appStoreVersionPhasedReleases]", r.fieldsAppStoreVersionPhasedReleases, "csv")
	}
	if r.fieldsBuilds != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields[builds]", r.fieldsBuilds, "csv")
	}
	if r.fieldsAppStoreVersionLocalizations != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields[appStoreVersionLocalizations]", r.fieldsAppStoreVersionLocalizations, "csv")
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "")
	}
	if r.limitAppStoreVersionLocalizations != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit[appStoreVersionLocalizations]", r.limitAppStoreVersionLocalizations, "")
	}
	if r.limitAppStoreVersionExperiments != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit[appStoreVersionExperiments]", r.limitAppStoreVersionExperiments, "")
	}
	if r.limitAppStoreVersionExperimentsV2 != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit[appStoreVersionExperimentsV2]", r.limitAppStoreVersionExperimentsV2, "")
	}
	if r.include != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "include", r.include, "csv")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiAppsAvailableTerritoriesGetToManyRelatedRequest struct {
	ctx               context.Context
	ApiService        *AppsApiService
	id                string
	fieldsTerritories *[]string
	limit             *int32
}

// the fields to include for returned resources of type territories
func (r ApiAppsAvailableTerritoriesGetToManyRelatedRequest) FieldsTerritories(fieldsTerritories []string) ApiAppsAvailableTerritoriesGetToManyRelatedRequest {
	r.fieldsTerritories = &fieldsTerritories
	return r
}

// maximum resources per page
func (r ApiAppsAvailableTerritoriesGetToManyRelatedRequest) Limit(limit int32) ApiAppsAvailableTerritoriesGetToManyRelatedRequest {
	r.limit = &limit
	return r
}

func (r ApiAppsAvailableTerritoriesGetToManyRelatedRequest) Execute() (*TerritoriesResponse, *http.Response, error) {
	return r.ApiService.AppsAvailableTerritoriesGetToManyRelatedExecute(r)
}

/*
AppsAvailableTerritoriesGetToManyRelated Method for AppsAvailableTerritoriesGetToManyRelated

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id the id of the requested resource
	@return ApiAppsAvailableTerritoriesGetToManyRelatedRequest

Deprecated
*/
func (a *AppsApiService) AppsAvailableTerritoriesGetToManyRelated(ctx context.Context, id string) ApiAppsAvailableTerritoriesGetToManyRelatedRequest {
	return ApiAppsAvailableTerritoriesGetToManyRelatedRequest{
		ApiService: a,
		ctx:        ctx,
		id:         id,
	}
}

// Execute executes the request
//
//	@return TerritoriesResponse
//
// Deprecated
func (a *AppsApiService) AppsAvailableTerritoriesGetToManyRelatedExecute(r ApiAppsAvailableTerritoriesGetToManyRelatedRequest) (*TerritoriesResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *TerritoriesResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AppsApiService.AppsAvailableTerritoriesGetToManyRelated")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/apps/{id}/availableTerritories"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.fieldsTerritories != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields[territories]", r.fieldsTerritories, "csv")
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiAppsBetaAppLocalizationsGetToManyRelatedRequest struct {
	ctx                        context.Context
	ApiService                 *AppsApiService
	id                         string
	fieldsBetaAppLocalizations *[]string
	limit                      *int32
}

// the fields to include for returned resources of type betaAppLocalizations
func (r ApiAppsBetaAppLocalizationsGetToManyRelatedRequest) FieldsBetaAppLocalizations(fieldsBetaAppLocalizations []string) ApiAppsBetaAppLocalizationsGetToManyRelatedRequest {
	r.fieldsBetaAppLocalizations = &fieldsBetaAppLocalizations
	return r
}

// maximum resources per page
func (r ApiAppsBetaAppLocalizationsGetToManyRelatedRequest) Limit(limit int32) ApiAppsBetaAppLocalizationsGetToManyRelatedRequest {
	r.limit = &limit
	return r
}

func (r ApiAppsBetaAppLocalizationsGetToManyRelatedRequest) Execute() (*BetaAppLocalizationsWithoutIncludesResponse, *http.Response, error) {
	return r.ApiService.AppsBetaAppLocalizationsGetToManyRelatedExecute(r)
}

/*
AppsBetaAppLocalizationsGetToManyRelated Method for AppsBetaAppLocalizationsGetToManyRelated

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id the id of the requested resource
	@return ApiAppsBetaAppLocalizationsGetToManyRelatedRequest
*/
func (a *AppsApiService) AppsBetaAppLocalizationsGetToManyRelated(ctx context.Context, id string) ApiAppsBetaAppLocalizationsGetToManyRelatedRequest {
	return ApiAppsBetaAppLocalizationsGetToManyRelatedRequest{
		ApiService: a,
		ctx:        ctx,
		id:         id,
	}
}

// Execute executes the request
//
//	@return BetaAppLocalizationsWithoutIncludesResponse
func (a *AppsApiService) AppsBetaAppLocalizationsGetToManyRelatedExecute(r ApiAppsBetaAppLocalizationsGetToManyRelatedRequest) (*BetaAppLocalizationsWithoutIncludesResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *BetaAppLocalizationsWithoutIncludesResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AppsApiService.AppsBetaAppLocalizationsGetToManyRelated")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/apps/{id}/betaAppLocalizations"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.fieldsBetaAppLocalizations != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields[betaAppLocalizations]", r.fieldsBetaAppLocalizations, "csv")
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiAppsBetaAppReviewDetailGetToOneRelatedRequest struct {
	ctx                        context.Context
	ApiService                 *AppsApiService
	id                         string
	fieldsBetaAppReviewDetails *[]string
}

// the fields to include for returned resources of type betaAppReviewDetails
func (r ApiAppsBetaAppReviewDetailGetToOneRelatedRequest) FieldsBetaAppReviewDetails(fieldsBetaAppReviewDetails []string) ApiAppsBetaAppReviewDetailGetToOneRelatedRequest {
	r.fieldsBetaAppReviewDetails = &fieldsBetaAppReviewDetails
	return r
}

func (r ApiAppsBetaAppReviewDetailGetToOneRelatedRequest) Execute() (*BetaAppReviewDetailWithoutIncludesResponse, *http.Response, error) {
	return r.ApiService.AppsBetaAppReviewDetailGetToOneRelatedExecute(r)
}

/*
AppsBetaAppReviewDetailGetToOneRelated Method for AppsBetaAppReviewDetailGetToOneRelated

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id the id of the requested resource
	@return ApiAppsBetaAppReviewDetailGetToOneRelatedRequest
*/
func (a *AppsApiService) AppsBetaAppReviewDetailGetToOneRelated(ctx context.Context, id string) ApiAppsBetaAppReviewDetailGetToOneRelatedRequest {
	return ApiAppsBetaAppReviewDetailGetToOneRelatedRequest{
		ApiService: a,
		ctx:        ctx,
		id:         id,
	}
}

// Execute executes the request
//
//	@return BetaAppReviewDetailWithoutIncludesResponse
func (a *AppsApiService) AppsBetaAppReviewDetailGetToOneRelatedExecute(r ApiAppsBetaAppReviewDetailGetToOneRelatedRequest) (*BetaAppReviewDetailWithoutIncludesResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *BetaAppReviewDetailWithoutIncludesResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AppsApiService.AppsBetaAppReviewDetailGetToOneRelated")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/apps/{id}/betaAppReviewDetail"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.fieldsBetaAppReviewDetails != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields[betaAppReviewDetails]", r.fieldsBetaAppReviewDetails, "csv")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiAppsBetaGroupsGetToManyRelatedRequest struct {
	ctx              context.Context
	ApiService       *AppsApiService
	id               string
	fieldsBetaGroups *[]string
	limit            *int32
}

// the fields to include for returned resources of type betaGroups
func (r ApiAppsBetaGroupsGetToManyRelatedRequest) FieldsBetaGroups(fieldsBetaGroups []string) ApiAppsBetaGroupsGetToManyRelatedRequest {
	r.fieldsBetaGroups = &fieldsBetaGroups
	return r
}

// maximum resources per page
func (r ApiAppsBetaGroupsGetToManyRelatedRequest) Limit(limit int32) ApiAppsBetaGroupsGetToManyRelatedRequest {
	r.limit = &limit
	return r
}

func (r ApiAppsBetaGroupsGetToManyRelatedRequest) Execute() (*BetaGroupsWithoutIncludesResponse, *http.Response, error) {
	return r.ApiService.AppsBetaGroupsGetToManyRelatedExecute(r)
}

/*
AppsBetaGroupsGetToManyRelated Method for AppsBetaGroupsGetToManyRelated

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id the id of the requested resource
	@return ApiAppsBetaGroupsGetToManyRelatedRequest
*/
func (a *AppsApiService) AppsBetaGroupsGetToManyRelated(ctx context.Context, id string) ApiAppsBetaGroupsGetToManyRelatedRequest {
	return ApiAppsBetaGroupsGetToManyRelatedRequest{
		ApiService: a,
		ctx:        ctx,
		id:         id,
	}
}

// Execute executes the request
//
//	@return BetaGroupsWithoutIncludesResponse
func (a *AppsApiService) AppsBetaGroupsGetToManyRelatedExecute(r ApiAppsBetaGroupsGetToManyRelatedRequest) (*BetaGroupsWithoutIncludesResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *BetaGroupsWithoutIncludesResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AppsApiService.AppsBetaGroupsGetToManyRelated")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/apps/{id}/betaGroups"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.fieldsBetaGroups != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields[betaGroups]", r.fieldsBetaGroups, "csv")
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiAppsBetaLicenseAgreementGetToOneRelatedRequest struct {
	ctx                         context.Context
	ApiService                  *AppsApiService
	id                          string
	fieldsBetaLicenseAgreements *[]string
}

// the fields to include for returned resources of type betaLicenseAgreements
func (r ApiAppsBetaLicenseAgreementGetToOneRelatedRequest) FieldsBetaLicenseAgreements(fieldsBetaLicenseAgreements []string) ApiAppsBetaLicenseAgreementGetToOneRelatedRequest {
	r.fieldsBetaLicenseAgreements = &fieldsBetaLicenseAgreements
	return r
}

func (r ApiAppsBetaLicenseAgreementGetToOneRelatedRequest) Execute() (*BetaLicenseAgreementWithoutIncludesResponse, *http.Response, error) {
	return r.ApiService.AppsBetaLicenseAgreementGetToOneRelatedExecute(r)
}

/*
AppsBetaLicenseAgreementGetToOneRelated Method for AppsBetaLicenseAgreementGetToOneRelated

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id the id of the requested resource
	@return ApiAppsBetaLicenseAgreementGetToOneRelatedRequest
*/
func (a *AppsApiService) AppsBetaLicenseAgreementGetToOneRelated(ctx context.Context, id string) ApiAppsBetaLicenseAgreementGetToOneRelatedRequest {
	return ApiAppsBetaLicenseAgreementGetToOneRelatedRequest{
		ApiService: a,
		ctx:        ctx,
		id:         id,
	}
}

// Execute executes the request
//
//	@return BetaLicenseAgreementWithoutIncludesResponse
func (a *AppsApiService) AppsBetaLicenseAgreementGetToOneRelatedExecute(r ApiAppsBetaLicenseAgreementGetToOneRelatedRequest) (*BetaLicenseAgreementWithoutIncludesResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *BetaLicenseAgreementWithoutIncludesResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AppsApiService.AppsBetaLicenseAgreementGetToOneRelated")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/apps/{id}/betaLicenseAgreement"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.fieldsBetaLicenseAgreements != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields[betaLicenseAgreements]", r.fieldsBetaLicenseAgreements, "csv")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiAppsBetaTestersDeleteToManyRelationshipRequest struct {
	ctx                           context.Context
	ApiService                    *AppsApiService
	id                            string
	appBetaTestersLinkagesRequest *AppBetaTestersLinkagesRequest
}

// List of related linkages
func (r ApiAppsBetaTestersDeleteToManyRelationshipRequest) AppBetaTestersLinkagesRequest(appBetaTestersLinkagesRequest AppBetaTestersLinkagesRequest) ApiAppsBetaTestersDeleteToManyRelationshipRequest {
	r.appBetaTestersLinkagesRequest = &appBetaTestersLinkagesRequest
	return r
}

func (r ApiAppsBetaTestersDeleteToManyRelationshipRequest) Execute() (*http.Response, error) {
	return r.ApiService.AppsBetaTestersDeleteToManyRelationshipExecute(r)
}

/*
AppsBetaTestersDeleteToManyRelationship Method for AppsBetaTestersDeleteToManyRelationship

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id the id of the requested resource
	@return ApiAppsBetaTestersDeleteToManyRelationshipRequest
*/
func (a *AppsApiService) AppsBetaTestersDeleteToManyRelationship(ctx context.Context, id string) ApiAppsBetaTestersDeleteToManyRelationshipRequest {
	return ApiAppsBetaTestersDeleteToManyRelationshipRequest{
		ApiService: a,
		ctx:        ctx,
		id:         id,
	}
}

// Execute executes the request
func (a *AppsApiService) AppsBetaTestersDeleteToManyRelationshipExecute(r ApiAppsBetaTestersDeleteToManyRelationshipRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodDelete
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AppsApiService.AppsBetaTestersDeleteToManyRelationship")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/apps/{id}/relationships/betaTesters"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.appBetaTestersLinkagesRequest == nil {
		return nil, reportError("appBetaTestersLinkagesRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.appBetaTestersLinkagesRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 409 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiAppsBuildsGetToManyRelatedRequest struct {
	ctx          context.Context
	ApiService   *AppsApiService
	id           string
	fieldsBuilds *[]string
	limit        *int32
}

// the fields to include for returned resources of type builds
func (r ApiAppsBuildsGetToManyRelatedRequest) FieldsBuilds(fieldsBuilds []string) ApiAppsBuildsGetToManyRelatedRequest {
	r.fieldsBuilds = &fieldsBuilds
	return r
}

// maximum resources per page
func (r ApiAppsBuildsGetToManyRelatedRequest) Limit(limit int32) ApiAppsBuildsGetToManyRelatedRequest {
	r.limit = &limit
	return r
}

func (r ApiAppsBuildsGetToManyRelatedRequest) Execute() (*BuildsWithoutIncludesResponse, *http.Response, error) {
	return r.ApiService.AppsBuildsGetToManyRelatedExecute(r)
}

/*
AppsBuildsGetToManyRelated Method for AppsBuildsGetToManyRelated

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id the id of the requested resource
	@return ApiAppsBuildsGetToManyRelatedRequest
*/
func (a *AppsApiService) AppsBuildsGetToManyRelated(ctx context.Context, id string) ApiAppsBuildsGetToManyRelatedRequest {
	return ApiAppsBuildsGetToManyRelatedRequest{
		ApiService: a,
		ctx:        ctx,
		id:         id,
	}
}

// Execute executes the request
//
//	@return BuildsWithoutIncludesResponse
func (a *AppsApiService) AppsBuildsGetToManyRelatedExecute(r ApiAppsBuildsGetToManyRelatedRequest) (*BuildsWithoutIncludesResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *BuildsWithoutIncludesResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AppsApiService.AppsBuildsGetToManyRelated")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/apps/{id}/builds"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.fieldsBuilds != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields[builds]", r.fieldsBuilds, "csv")
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiAppsCiProductGetToOneRelatedRequest struct {
	ctx                      context.Context
	ApiService               *AppsApiService
	id                       string
	fieldsCiProducts         *[]string
	fieldsApps               *[]string
	fieldsScmRepositories    *[]string
	fieldsBundleIds          *[]string
	limitPrimaryRepositories *int32
	include                  *[]string
}

// the fields to include for returned resources of type ciProducts
func (r ApiAppsCiProductGetToOneRelatedRequest) FieldsCiProducts(fieldsCiProducts []string) ApiAppsCiProductGetToOneRelatedRequest {
	r.fieldsCiProducts = &fieldsCiProducts
	return r
}

// the fields to include for returned resources of type apps
func (r ApiAppsCiProductGetToOneRelatedRequest) FieldsApps(fieldsApps []string) ApiAppsCiProductGetToOneRelatedRequest {
	r.fieldsApps = &fieldsApps
	return r
}

// the fields to include for returned resources of type scmRepositories
func (r ApiAppsCiProductGetToOneRelatedRequest) FieldsScmRepositories(fieldsScmRepositories []string) ApiAppsCiProductGetToOneRelatedRequest {
	r.fieldsScmRepositories = &fieldsScmRepositories
	return r
}

// the fields to include for returned resources of type bundleIds
func (r ApiAppsCiProductGetToOneRelatedRequest) FieldsBundleIds(fieldsBundleIds []string) ApiAppsCiProductGetToOneRelatedRequest {
	r.fieldsBundleIds = &fieldsBundleIds
	return r
}

// maximum number of related primaryRepositories returned (when they are included)
func (r ApiAppsCiProductGetToOneRelatedRequest) LimitPrimaryRepositories(limitPrimaryRepositories int32) ApiAppsCiProductGetToOneRelatedRequest {
	r.limitPrimaryRepositories = &limitPrimaryRepositories
	return r
}

// comma-separated list of relationships to include
func (r ApiAppsCiProductGetToOneRelatedRequest) Include(include []string) ApiAppsCiProductGetToOneRelatedRequest {
	r.include = &include
	return r
}

func (r ApiAppsCiProductGetToOneRelatedRequest) Execute() (*CiProductResponse, *http.Response, error) {
	return r.ApiService.AppsCiProductGetToOneRelatedExecute(r)
}

/*
AppsCiProductGetToOneRelated Method for AppsCiProductGetToOneRelated

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id the id of the requested resource
	@return ApiAppsCiProductGetToOneRelatedRequest
*/
func (a *AppsApiService) AppsCiProductGetToOneRelated(ctx context.Context, id string) ApiAppsCiProductGetToOneRelatedRequest {
	return ApiAppsCiProductGetToOneRelatedRequest{
		ApiService: a,
		ctx:        ctx,
		id:         id,
	}
}

// Execute executes the request
//
//	@return CiProductResponse
func (a *AppsApiService) AppsCiProductGetToOneRelatedExecute(r ApiAppsCiProductGetToOneRelatedRequest) (*CiProductResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *CiProductResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AppsApiService.AppsCiProductGetToOneRelated")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/apps/{id}/ciProduct"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.fieldsCiProducts != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields[ciProducts]", r.fieldsCiProducts, "csv")
	}
	if r.fieldsApps != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields[apps]", r.fieldsApps, "csv")
	}
	if r.fieldsScmRepositories != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields[scmRepositories]", r.fieldsScmRepositories, "csv")
	}
	if r.fieldsBundleIds != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields[bundleIds]", r.fieldsBundleIds, "csv")
	}
	if r.limitPrimaryRepositories != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit[primaryRepositories]", r.limitPrimaryRepositories, "")
	}
	if r.include != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "include", r.include, "csv")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiAppsCustomerReviewsGetToManyRelatedRequest struct {
	ctx                           context.Context
	ApiService                    *AppsApiService
	id                            string
	filterRating                  *[]string
	filterTerritory               *[]string
	existsPublishedResponse       *bool
	sort                          *[]string
	fieldsCustomerReviews         *[]string
	fieldsCustomerReviewResponses *[]string
	limit                         *int32
	include                       *[]string
}

// filter by attribute &#39;rating&#39;
func (r ApiAppsCustomerReviewsGetToManyRelatedRequest) FilterRating(filterRating []string) ApiAppsCustomerReviewsGetToManyRelatedRequest {
	r.filterRating = &filterRating
	return r
}

// filter by attribute &#39;territory&#39;
func (r ApiAppsCustomerReviewsGetToManyRelatedRequest) FilterTerritory(filterTerritory []string) ApiAppsCustomerReviewsGetToManyRelatedRequest {
	r.filterTerritory = &filterTerritory
	return r
}

// filter by publishedResponse
func (r ApiAppsCustomerReviewsGetToManyRelatedRequest) ExistsPublishedResponse(existsPublishedResponse bool) ApiAppsCustomerReviewsGetToManyRelatedRequest {
	r.existsPublishedResponse = &existsPublishedResponse
	return r
}

// comma-separated list of sort expressions; resources will be sorted as specified
func (r ApiAppsCustomerReviewsGetToManyRelatedRequest) Sort(sort []string) ApiAppsCustomerReviewsGetToManyRelatedRequest {
	r.sort = &sort
	return r
}

// the fields to include for returned resources of type customerReviews
func (r ApiAppsCustomerReviewsGetToManyRelatedRequest) FieldsCustomerReviews(fieldsCustomerReviews []string) ApiAppsCustomerReviewsGetToManyRelatedRequest {
	r.fieldsCustomerReviews = &fieldsCustomerReviews
	return r
}

// the fields to include for returned resources of type customerReviewResponses
func (r ApiAppsCustomerReviewsGetToManyRelatedRequest) FieldsCustomerReviewResponses(fieldsCustomerReviewResponses []string) ApiAppsCustomerReviewsGetToManyRelatedRequest {
	r.fieldsCustomerReviewResponses = &fieldsCustomerReviewResponses
	return r
}

// maximum resources per page
func (r ApiAppsCustomerReviewsGetToManyRelatedRequest) Limit(limit int32) ApiAppsCustomerReviewsGetToManyRelatedRequest {
	r.limit = &limit
	return r
}

// comma-separated list of relationships to include
func (r ApiAppsCustomerReviewsGetToManyRelatedRequest) Include(include []string) ApiAppsCustomerReviewsGetToManyRelatedRequest {
	r.include = &include
	return r
}

func (r ApiAppsCustomerReviewsGetToManyRelatedRequest) Execute() (*CustomerReviewsResponse, *http.Response, error) {
	return r.ApiService.AppsCustomerReviewsGetToManyRelatedExecute(r)
}

/*
AppsCustomerReviewsGetToManyRelated Method for AppsCustomerReviewsGetToManyRelated

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id the id of the requested resource
	@return ApiAppsCustomerReviewsGetToManyRelatedRequest
*/
func (a *AppsApiService) AppsCustomerReviewsGetToManyRelated(ctx context.Context, id string) ApiAppsCustomerReviewsGetToManyRelatedRequest {
	return ApiAppsCustomerReviewsGetToManyRelatedRequest{
		ApiService: a,
		ctx:        ctx,
		id:         id,
	}
}

// Execute executes the request
//
//	@return CustomerReviewsResponse
func (a *AppsApiService) AppsCustomerReviewsGetToManyRelatedExecute(r ApiAppsCustomerReviewsGetToManyRelatedRequest) (*CustomerReviewsResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *CustomerReviewsResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AppsApiService.AppsCustomerReviewsGetToManyRelated")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/apps/{id}/customerReviews"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.filterRating != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter[rating]", r.filterRating, "csv")
	}
	if r.filterTerritory != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter[territory]", r.filterTerritory, "csv")
	}
	if r.existsPublishedResponse != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "exists[publishedResponse]", r.existsPublishedResponse, "")
	}
	if r.sort != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "sort", r.sort, "csv")
	}
	if r.fieldsCustomerReviews != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields[customerReviews]", r.fieldsCustomerReviews, "csv")
	}
	if r.fieldsCustomerReviewResponses != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields[customerReviewResponses]", r.fieldsCustomerReviewResponses, "csv")
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "")
	}
	if r.include != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "include", r.include, "csv")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiAppsEndUserLicenseAgreementGetToOneRelatedRequest struct {
	ctx                            context.Context
	ApiService                     *AppsApiService
	id                             string
	fieldsEndUserLicenseAgreements *[]string
}

// the fields to include for returned resources of type endUserLicenseAgreements
func (r ApiAppsEndUserLicenseAgreementGetToOneRelatedRequest) FieldsEndUserLicenseAgreements(fieldsEndUserLicenseAgreements []string) ApiAppsEndUserLicenseAgreementGetToOneRelatedRequest {
	r.fieldsEndUserLicenseAgreements = &fieldsEndUserLicenseAgreements
	return r
}

func (r ApiAppsEndUserLicenseAgreementGetToOneRelatedRequest) Execute() (*EndUserLicenseAgreementWithoutIncludesResponse, *http.Response, error) {
	return r.ApiService.AppsEndUserLicenseAgreementGetToOneRelatedExecute(r)
}

/*
AppsEndUserLicenseAgreementGetToOneRelated Method for AppsEndUserLicenseAgreementGetToOneRelated

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id the id of the requested resource
	@return ApiAppsEndUserLicenseAgreementGetToOneRelatedRequest
*/
func (a *AppsApiService) AppsEndUserLicenseAgreementGetToOneRelated(ctx context.Context, id string) ApiAppsEndUserLicenseAgreementGetToOneRelatedRequest {
	return ApiAppsEndUserLicenseAgreementGetToOneRelatedRequest{
		ApiService: a,
		ctx:        ctx,
		id:         id,
	}
}

// Execute executes the request
//
//	@return EndUserLicenseAgreementWithoutIncludesResponse
func (a *AppsApiService) AppsEndUserLicenseAgreementGetToOneRelatedExecute(r ApiAppsEndUserLicenseAgreementGetToOneRelatedRequest) (*EndUserLicenseAgreementWithoutIncludesResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *EndUserLicenseAgreementWithoutIncludesResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AppsApiService.AppsEndUserLicenseAgreementGetToOneRelated")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/apps/{id}/endUserLicenseAgreement"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.fieldsEndUserLicenseAgreements != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields[endUserLicenseAgreements]", r.fieldsEndUserLicenseAgreements, "csv")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiAppsGameCenterDetailGetToOneRelatedRequest struct {
	ctx                                    context.Context
	ApiService                             *AppsApiService
	id                                     string
	fieldsGameCenterAchievementReleases    *[]string
	fieldsGameCenterLeaderboardSetReleases *[]string
	fieldsGameCenterLeaderboardSets        *[]string
	fieldsGameCenterGroups                 *[]string
	fieldsGameCenterDetails                *[]string
	fieldsGameCenterLeaderboards           *[]string
	fieldsGameCenterAppVersions            *[]string
	fieldsGameCenterAchievements           *[]string
	fieldsApps                             *[]string
	fieldsGameCenterLeaderboardReleases    *[]string
	limitGameCenterAppVersions             *int32
	limitGameCenterLeaderboards            *int32
	limitGameCenterLeaderboardSets         *int32
	limitGameCenterAchievements            *int32
	limitAchievementReleases               *int32
	limitLeaderboardReleases               *int32
	limitLeaderboardSetReleases            *int32
	include                                *[]string
}

// the fields to include for returned resources of type gameCenterAchievementReleases
func (r ApiAppsGameCenterDetailGetToOneRelatedRequest) FieldsGameCenterAchievementReleases(fieldsGameCenterAchievementReleases []string) ApiAppsGameCenterDetailGetToOneRelatedRequest {
	r.fieldsGameCenterAchievementReleases = &fieldsGameCenterAchievementReleases
	return r
}

// the fields to include for returned resources of type gameCenterLeaderboardSetReleases
func (r ApiAppsGameCenterDetailGetToOneRelatedRequest) FieldsGameCenterLeaderboardSetReleases(fieldsGameCenterLeaderboardSetReleases []string) ApiAppsGameCenterDetailGetToOneRelatedRequest {
	r.fieldsGameCenterLeaderboardSetReleases = &fieldsGameCenterLeaderboardSetReleases
	return r
}

// the fields to include for returned resources of type gameCenterLeaderboardSets
func (r ApiAppsGameCenterDetailGetToOneRelatedRequest) FieldsGameCenterLeaderboardSets(fieldsGameCenterLeaderboardSets []string) ApiAppsGameCenterDetailGetToOneRelatedRequest {
	r.fieldsGameCenterLeaderboardSets = &fieldsGameCenterLeaderboardSets
	return r
}

// the fields to include for returned resources of type gameCenterGroups
func (r ApiAppsGameCenterDetailGetToOneRelatedRequest) FieldsGameCenterGroups(fieldsGameCenterGroups []string) ApiAppsGameCenterDetailGetToOneRelatedRequest {
	r.fieldsGameCenterGroups = &fieldsGameCenterGroups
	return r
}

// the fields to include for returned resources of type gameCenterDetails
func (r ApiAppsGameCenterDetailGetToOneRelatedRequest) FieldsGameCenterDetails(fieldsGameCenterDetails []string) ApiAppsGameCenterDetailGetToOneRelatedRequest {
	r.fieldsGameCenterDetails = &fieldsGameCenterDetails
	return r
}

// the fields to include for returned resources of type gameCenterLeaderboards
func (r ApiAppsGameCenterDetailGetToOneRelatedRequest) FieldsGameCenterLeaderboards(fieldsGameCenterLeaderboards []string) ApiAppsGameCenterDetailGetToOneRelatedRequest {
	r.fieldsGameCenterLeaderboards = &fieldsGameCenterLeaderboards
	return r
}

// the fields to include for returned resources of type gameCenterAppVersions
func (r ApiAppsGameCenterDetailGetToOneRelatedRequest) FieldsGameCenterAppVersions(fieldsGameCenterAppVersions []string) ApiAppsGameCenterDetailGetToOneRelatedRequest {
	r.fieldsGameCenterAppVersions = &fieldsGameCenterAppVersions
	return r
}

// the fields to include for returned resources of type gameCenterAchievements
func (r ApiAppsGameCenterDetailGetToOneRelatedRequest) FieldsGameCenterAchievements(fieldsGameCenterAchievements []string) ApiAppsGameCenterDetailGetToOneRelatedRequest {
	r.fieldsGameCenterAchievements = &fieldsGameCenterAchievements
	return r
}

// the fields to include for returned resources of type apps
func (r ApiAppsGameCenterDetailGetToOneRelatedRequest) FieldsApps(fieldsApps []string) ApiAppsGameCenterDetailGetToOneRelatedRequest {
	r.fieldsApps = &fieldsApps
	return r
}

// the fields to include for returned resources of type gameCenterLeaderboardReleases
func (r ApiAppsGameCenterDetailGetToOneRelatedRequest) FieldsGameCenterLeaderboardReleases(fieldsGameCenterLeaderboardReleases []string) ApiAppsGameCenterDetailGetToOneRelatedRequest {
	r.fieldsGameCenterLeaderboardReleases = &fieldsGameCenterLeaderboardReleases
	return r
}

// maximum number of related gameCenterAppVersions returned (when they are included)
func (r ApiAppsGameCenterDetailGetToOneRelatedRequest) LimitGameCenterAppVersions(limitGameCenterAppVersions int32) ApiAppsGameCenterDetailGetToOneRelatedRequest {
	r.limitGameCenterAppVersions = &limitGameCenterAppVersions
	return r
}

// maximum number of related gameCenterLeaderboards returned (when they are included)
func (r ApiAppsGameCenterDetailGetToOneRelatedRequest) LimitGameCenterLeaderboards(limitGameCenterLeaderboards int32) ApiAppsGameCenterDetailGetToOneRelatedRequest {
	r.limitGameCenterLeaderboards = &limitGameCenterLeaderboards
	return r
}

// maximum number of related gameCenterLeaderboardSets returned (when they are included)
func (r ApiAppsGameCenterDetailGetToOneRelatedRequest) LimitGameCenterLeaderboardSets(limitGameCenterLeaderboardSets int32) ApiAppsGameCenterDetailGetToOneRelatedRequest {
	r.limitGameCenterLeaderboardSets = &limitGameCenterLeaderboardSets
	return r
}

// maximum number of related gameCenterAchievements returned (when they are included)
func (r ApiAppsGameCenterDetailGetToOneRelatedRequest) LimitGameCenterAchievements(limitGameCenterAchievements int32) ApiAppsGameCenterDetailGetToOneRelatedRequest {
	r.limitGameCenterAchievements = &limitGameCenterAchievements
	return r
}

// maximum number of related achievementReleases returned (when they are included)
func (r ApiAppsGameCenterDetailGetToOneRelatedRequest) LimitAchievementReleases(limitAchievementReleases int32) ApiAppsGameCenterDetailGetToOneRelatedRequest {
	r.limitAchievementReleases = &limitAchievementReleases
	return r
}

// maximum number of related leaderboardReleases returned (when they are included)
func (r ApiAppsGameCenterDetailGetToOneRelatedRequest) LimitLeaderboardReleases(limitLeaderboardReleases int32) ApiAppsGameCenterDetailGetToOneRelatedRequest {
	r.limitLeaderboardReleases = &limitLeaderboardReleases
	return r
}

// maximum number of related leaderboardSetReleases returned (when they are included)
func (r ApiAppsGameCenterDetailGetToOneRelatedRequest) LimitLeaderboardSetReleases(limitLeaderboardSetReleases int32) ApiAppsGameCenterDetailGetToOneRelatedRequest {
	r.limitLeaderboardSetReleases = &limitLeaderboardSetReleases
	return r
}

// comma-separated list of relationships to include
func (r ApiAppsGameCenterDetailGetToOneRelatedRequest) Include(include []string) ApiAppsGameCenterDetailGetToOneRelatedRequest {
	r.include = &include
	return r
}

func (r ApiAppsGameCenterDetailGetToOneRelatedRequest) Execute() (*GameCenterDetailResponse, *http.Response, error) {
	return r.ApiService.AppsGameCenterDetailGetToOneRelatedExecute(r)
}

/*
AppsGameCenterDetailGetToOneRelated Method for AppsGameCenterDetailGetToOneRelated

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id the id of the requested resource
	@return ApiAppsGameCenterDetailGetToOneRelatedRequest
*/
func (a *AppsApiService) AppsGameCenterDetailGetToOneRelated(ctx context.Context, id string) ApiAppsGameCenterDetailGetToOneRelatedRequest {
	return ApiAppsGameCenterDetailGetToOneRelatedRequest{
		ApiService: a,
		ctx:        ctx,
		id:         id,
	}
}

// Execute executes the request
//
//	@return GameCenterDetailResponse
func (a *AppsApiService) AppsGameCenterDetailGetToOneRelatedExecute(r ApiAppsGameCenterDetailGetToOneRelatedRequest) (*GameCenterDetailResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *GameCenterDetailResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AppsApiService.AppsGameCenterDetailGetToOneRelated")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/apps/{id}/gameCenterDetail"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.fieldsGameCenterAchievementReleases != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields[gameCenterAchievementReleases]", r.fieldsGameCenterAchievementReleases, "csv")
	}
	if r.fieldsGameCenterLeaderboardSetReleases != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields[gameCenterLeaderboardSetReleases]", r.fieldsGameCenterLeaderboardSetReleases, "csv")
	}
	if r.fieldsGameCenterLeaderboardSets != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields[gameCenterLeaderboardSets]", r.fieldsGameCenterLeaderboardSets, "csv")
	}
	if r.fieldsGameCenterGroups != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields[gameCenterGroups]", r.fieldsGameCenterGroups, "csv")
	}
	if r.fieldsGameCenterDetails != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields[gameCenterDetails]", r.fieldsGameCenterDetails, "csv")
	}
	if r.fieldsGameCenterLeaderboards != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields[gameCenterLeaderboards]", r.fieldsGameCenterLeaderboards, "csv")
	}
	if r.fieldsGameCenterAppVersions != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields[gameCenterAppVersions]", r.fieldsGameCenterAppVersions, "csv")
	}
	if r.fieldsGameCenterAchievements != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields[gameCenterAchievements]", r.fieldsGameCenterAchievements, "csv")
	}
	if r.fieldsApps != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields[apps]", r.fieldsApps, "csv")
	}
	if r.fieldsGameCenterLeaderboardReleases != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields[gameCenterLeaderboardReleases]", r.fieldsGameCenterLeaderboardReleases, "csv")
	}
	if r.limitGameCenterAppVersions != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit[gameCenterAppVersions]", r.limitGameCenterAppVersions, "")
	}
	if r.limitGameCenterLeaderboards != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit[gameCenterLeaderboards]", r.limitGameCenterLeaderboards, "")
	}
	if r.limitGameCenterLeaderboardSets != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit[gameCenterLeaderboardSets]", r.limitGameCenterLeaderboardSets, "")
	}
	if r.limitGameCenterAchievements != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit[gameCenterAchievements]", r.limitGameCenterAchievements, "")
	}
	if r.limitAchievementReleases != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit[achievementReleases]", r.limitAchievementReleases, "")
	}
	if r.limitLeaderboardReleases != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit[leaderboardReleases]", r.limitLeaderboardReleases, "")
	}
	if r.limitLeaderboardSetReleases != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit[leaderboardSetReleases]", r.limitLeaderboardSetReleases, "")
	}
	if r.include != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "include", r.include, "csv")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiAppsGameCenterEnabledVersionsGetToManyRelatedRequest struct {
	ctx                             context.Context
	ApiService                      *AppsApiService
	id                              string
	filterPlatform                  *[]string
	filterVersionString             *[]string
	filterId                        *[]string
	sort                            *[]string
	fieldsGameCenterEnabledVersions *[]string
	fieldsApps                      *[]string
	limit                           *int32
	limitCompatibleVersions         *int32
	include                         *[]string
}

// filter by attribute &#39;platform&#39;
func (r ApiAppsGameCenterEnabledVersionsGetToManyRelatedRequest) FilterPlatform(filterPlatform []string) ApiAppsGameCenterEnabledVersionsGetToManyRelatedRequest {
	r.filterPlatform = &filterPlatform
	return r
}

// filter by attribute &#39;versionString&#39;
func (r ApiAppsGameCenterEnabledVersionsGetToManyRelatedRequest) FilterVersionString(filterVersionString []string) ApiAppsGameCenterEnabledVersionsGetToManyRelatedRequest {
	r.filterVersionString = &filterVersionString
	return r
}

// filter by id(s)
func (r ApiAppsGameCenterEnabledVersionsGetToManyRelatedRequest) FilterId(filterId []string) ApiAppsGameCenterEnabledVersionsGetToManyRelatedRequest {
	r.filterId = &filterId
	return r
}

// comma-separated list of sort expressions; resources will be sorted as specified
func (r ApiAppsGameCenterEnabledVersionsGetToManyRelatedRequest) Sort(sort []string) ApiAppsGameCenterEnabledVersionsGetToManyRelatedRequest {
	r.sort = &sort
	return r
}

// the fields to include for returned resources of type gameCenterEnabledVersions
func (r ApiAppsGameCenterEnabledVersionsGetToManyRelatedRequest) FieldsGameCenterEnabledVersions(fieldsGameCenterEnabledVersions []string) ApiAppsGameCenterEnabledVersionsGetToManyRelatedRequest {
	r.fieldsGameCenterEnabledVersions = &fieldsGameCenterEnabledVersions
	return r
}

// the fields to include for returned resources of type apps
func (r ApiAppsGameCenterEnabledVersionsGetToManyRelatedRequest) FieldsApps(fieldsApps []string) ApiAppsGameCenterEnabledVersionsGetToManyRelatedRequest {
	r.fieldsApps = &fieldsApps
	return r
}

// maximum resources per page
func (r ApiAppsGameCenterEnabledVersionsGetToManyRelatedRequest) Limit(limit int32) ApiAppsGameCenterEnabledVersionsGetToManyRelatedRequest {
	r.limit = &limit
	return r
}

// maximum number of related compatibleVersions returned (when they are included)
// Deprecated
func (r ApiAppsGameCenterEnabledVersionsGetToManyRelatedRequest) LimitCompatibleVersions(limitCompatibleVersions int32) ApiAppsGameCenterEnabledVersionsGetToManyRelatedRequest {
	r.limitCompatibleVersions = &limitCompatibleVersions
	return r
}

// comma-separated list of relationships to include
func (r ApiAppsGameCenterEnabledVersionsGetToManyRelatedRequest) Include(include []string) ApiAppsGameCenterEnabledVersionsGetToManyRelatedRequest {
	r.include = &include
	return r
}

func (r ApiAppsGameCenterEnabledVersionsGetToManyRelatedRequest) Execute() (*GameCenterEnabledVersionsResponse, *http.Response, error) {
	return r.ApiService.AppsGameCenterEnabledVersionsGetToManyRelatedExecute(r)
}

/*
AppsGameCenterEnabledVersionsGetToManyRelated Method for AppsGameCenterEnabledVersionsGetToManyRelated

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id the id of the requested resource
	@return ApiAppsGameCenterEnabledVersionsGetToManyRelatedRequest

Deprecated
*/
func (a *AppsApiService) AppsGameCenterEnabledVersionsGetToManyRelated(ctx context.Context, id string) ApiAppsGameCenterEnabledVersionsGetToManyRelatedRequest {
	return ApiAppsGameCenterEnabledVersionsGetToManyRelatedRequest{
		ApiService: a,
		ctx:        ctx,
		id:         id,
	}
}

// Execute executes the request
//
//	@return GameCenterEnabledVersionsResponse
//
// Deprecated
func (a *AppsApiService) AppsGameCenterEnabledVersionsGetToManyRelatedExecute(r ApiAppsGameCenterEnabledVersionsGetToManyRelatedRequest) (*GameCenterEnabledVersionsResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *GameCenterEnabledVersionsResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AppsApiService.AppsGameCenterEnabledVersionsGetToManyRelated")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/apps/{id}/gameCenterEnabledVersions"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.filterPlatform != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter[platform]", r.filterPlatform, "csv")
	}
	if r.filterVersionString != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter[versionString]", r.filterVersionString, "csv")
	}
	if r.filterId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter[id]", r.filterId, "csv")
	}
	if r.sort != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "sort", r.sort, "csv")
	}
	if r.fieldsGameCenterEnabledVersions != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields[gameCenterEnabledVersions]", r.fieldsGameCenterEnabledVersions, "csv")
	}
	if r.fieldsApps != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields[apps]", r.fieldsApps, "csv")
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "")
	}
	if r.limitCompatibleVersions != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit[compatibleVersions]", r.limitCompatibleVersions, "")
	}
	if r.include != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "include", r.include, "csv")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiAppsGetCollectionRequest struct {
	ctx                                 context.Context
	ApiService                          *AppsApiService
	filterAppStoreVersionsAppStoreState *[]string
	filterAppStoreVersionsPlatform      *[]string
	filterBundleId                      *[]string
	filterName                          *[]string
	filterSku                           *[]string
	filterAppStoreVersions              *[]string
	filterId                            *[]string
	existsGameCenterEnabledVersions     *bool
	sort                                *[]string
	fieldsApps                          *[]string
	limit                               *int32
	include                             *[]string
	fieldsBetaAppReviewDetails          *[]string
	fieldsGameCenterDetails             *[]string
	fieldsAppPriceSchedules             *[]string
	fieldsCiProducts                    *[]string
	fieldsReviewSubmissions             *[]string
	fieldsBetaGroups                    *[]string
	fieldsPromotedPurchases             *[]string
	fieldsAppAvailabilities             *[]string
	fieldsCustomerReviews               *[]string
	fieldsAppEvents                     *[]string
	fieldsBuilds                        *[]string
	fieldsBetaLicenseAgreements         *[]string
	fieldsAppClips                      *[]string
	fieldsAppInfos                      *[]string
	fieldsBetaAppLocalizations          *[]string
	fieldsAppPricePoints                *[]string
	fieldsInAppPurchases                *[]string
	fieldsPreReleaseVersions            *[]string
	fieldsSubscriptionGroups            *[]string
	fieldsAppPrices                     *[]string
	fieldsAppPreOrders                  *[]string
	fieldsAppStoreVersionExperiments    *[]string
	fieldsGameCenterEnabledVersions     *[]string
	fieldsSubscriptionGracePeriods      *[]string
	fieldsEndUserLicenseAgreements      *[]string
	fieldsAppStoreVersions              *[]string
	fieldsAppCustomProductPages         *[]string
	fieldsAppEncryptionDeclarations     *[]string
	fieldsTerritories                   *[]string
	fieldsPerfPowerMetrics              *[]string
	limitAppClips                       *int32
	limitAppCustomProductPages          *int32
	limitAppEncryptionDeclarations      *int32
	limitAppEvents                      *int32
	limitAppInfos                       *int32
	limitAppStoreVersionExperimentsV2   *int32
	limitAppStoreVersions               *int32
	limitAvailableTerritories           *int32
	limitBetaAppLocalizations           *int32
	limitBetaGroups                     *int32
	limitBuilds                         *int32
	limitGameCenterEnabledVersions      *int32
	limitInAppPurchases                 *int32
	limitInAppPurchasesV2               *int32
	limitPreReleaseVersions             *int32
	limitPrices                         *int32
	limitPromotedPurchases              *int32
	limitReviewSubmissions              *int32
	limitSubscriptionGroups             *int32
}

// filter by attribute &#39;appStoreVersions.appStoreState&#39;
func (r ApiAppsGetCollectionRequest) FilterAppStoreVersionsAppStoreState(filterAppStoreVersionsAppStoreState []string) ApiAppsGetCollectionRequest {
	r.filterAppStoreVersionsAppStoreState = &filterAppStoreVersionsAppStoreState
	return r
}

// filter by attribute &#39;appStoreVersions.platform&#39;
func (r ApiAppsGetCollectionRequest) FilterAppStoreVersionsPlatform(filterAppStoreVersionsPlatform []string) ApiAppsGetCollectionRequest {
	r.filterAppStoreVersionsPlatform = &filterAppStoreVersionsPlatform
	return r
}

// filter by attribute &#39;bundleId&#39;
func (r ApiAppsGetCollectionRequest) FilterBundleId(filterBundleId []string) ApiAppsGetCollectionRequest {
	r.filterBundleId = &filterBundleId
	return r
}

// filter by attribute &#39;name&#39;
func (r ApiAppsGetCollectionRequest) FilterName(filterName []string) ApiAppsGetCollectionRequest {
	r.filterName = &filterName
	return r
}

// filter by attribute &#39;sku&#39;
func (r ApiAppsGetCollectionRequest) FilterSku(filterSku []string) ApiAppsGetCollectionRequest {
	r.filterSku = &filterSku
	return r
}

// filter by id(s) of related &#39;appStoreVersions&#39;
func (r ApiAppsGetCollectionRequest) FilterAppStoreVersions(filterAppStoreVersions []string) ApiAppsGetCollectionRequest {
	r.filterAppStoreVersions = &filterAppStoreVersions
	return r
}

// filter by id(s)
func (r ApiAppsGetCollectionRequest) FilterId(filterId []string) ApiAppsGetCollectionRequest {
	r.filterId = &filterId
	return r
}

// filter by existence or non-existence of related &#39;gameCenterEnabledVersions&#39;
// Deprecated
func (r ApiAppsGetCollectionRequest) ExistsGameCenterEnabledVersions(existsGameCenterEnabledVersions bool) ApiAppsGetCollectionRequest {
	r.existsGameCenterEnabledVersions = &existsGameCenterEnabledVersions
	return r
}

// comma-separated list of sort expressions; resources will be sorted as specified
func (r ApiAppsGetCollectionRequest) Sort(sort []string) ApiAppsGetCollectionRequest {
	r.sort = &sort
	return r
}

// the fields to include for returned resources of type apps
func (r ApiAppsGetCollectionRequest) FieldsApps(fieldsApps []string) ApiAppsGetCollectionRequest {
	r.fieldsApps = &fieldsApps
	return r
}

// maximum resources per page
func (r ApiAppsGetCollectionRequest) Limit(limit int32) ApiAppsGetCollectionRequest {
	r.limit = &limit
	return r
}

// comma-separated list of relationships to include
func (r ApiAppsGetCollectionRequest) Include(include []string) ApiAppsGetCollectionRequest {
	r.include = &include
	return r
}

// the fields to include for returned resources of type betaAppReviewDetails
func (r ApiAppsGetCollectionRequest) FieldsBetaAppReviewDetails(fieldsBetaAppReviewDetails []string) ApiAppsGetCollectionRequest {
	r.fieldsBetaAppReviewDetails = &fieldsBetaAppReviewDetails
	return r
}

// the fields to include for returned resources of type gameCenterDetails
func (r ApiAppsGetCollectionRequest) FieldsGameCenterDetails(fieldsGameCenterDetails []string) ApiAppsGetCollectionRequest {
	r.fieldsGameCenterDetails = &fieldsGameCenterDetails
	return r
}

// the fields to include for returned resources of type appPriceSchedules
func (r ApiAppsGetCollectionRequest) FieldsAppPriceSchedules(fieldsAppPriceSchedules []string) ApiAppsGetCollectionRequest {
	r.fieldsAppPriceSchedules = &fieldsAppPriceSchedules
	return r
}

// the fields to include for returned resources of type ciProducts
func (r ApiAppsGetCollectionRequest) FieldsCiProducts(fieldsCiProducts []string) ApiAppsGetCollectionRequest {
	r.fieldsCiProducts = &fieldsCiProducts
	return r
}

// the fields to include for returned resources of type reviewSubmissions
func (r ApiAppsGetCollectionRequest) FieldsReviewSubmissions(fieldsReviewSubmissions []string) ApiAppsGetCollectionRequest {
	r.fieldsReviewSubmissions = &fieldsReviewSubmissions
	return r
}

// the fields to include for returned resources of type betaGroups
func (r ApiAppsGetCollectionRequest) FieldsBetaGroups(fieldsBetaGroups []string) ApiAppsGetCollectionRequest {
	r.fieldsBetaGroups = &fieldsBetaGroups
	return r
}

// the fields to include for returned resources of type promotedPurchases
func (r ApiAppsGetCollectionRequest) FieldsPromotedPurchases(fieldsPromotedPurchases []string) ApiAppsGetCollectionRequest {
	r.fieldsPromotedPurchases = &fieldsPromotedPurchases
	return r
}

// the fields to include for returned resources of type appAvailabilities
func (r ApiAppsGetCollectionRequest) FieldsAppAvailabilities(fieldsAppAvailabilities []string) ApiAppsGetCollectionRequest {
	r.fieldsAppAvailabilities = &fieldsAppAvailabilities
	return r
}

// the fields to include for returned resources of type customerReviews
func (r ApiAppsGetCollectionRequest) FieldsCustomerReviews(fieldsCustomerReviews []string) ApiAppsGetCollectionRequest {
	r.fieldsCustomerReviews = &fieldsCustomerReviews
	return r
}

// the fields to include for returned resources of type appEvents
func (r ApiAppsGetCollectionRequest) FieldsAppEvents(fieldsAppEvents []string) ApiAppsGetCollectionRequest {
	r.fieldsAppEvents = &fieldsAppEvents
	return r
}

// the fields to include for returned resources of type builds
func (r ApiAppsGetCollectionRequest) FieldsBuilds(fieldsBuilds []string) ApiAppsGetCollectionRequest {
	r.fieldsBuilds = &fieldsBuilds
	return r
}

// the fields to include for returned resources of type betaLicenseAgreements
func (r ApiAppsGetCollectionRequest) FieldsBetaLicenseAgreements(fieldsBetaLicenseAgreements []string) ApiAppsGetCollectionRequest {
	r.fieldsBetaLicenseAgreements = &fieldsBetaLicenseAgreements
	return r
}

// the fields to include for returned resources of type appClips
func (r ApiAppsGetCollectionRequest) FieldsAppClips(fieldsAppClips []string) ApiAppsGetCollectionRequest {
	r.fieldsAppClips = &fieldsAppClips
	return r
}

// the fields to include for returned resources of type appInfos
func (r ApiAppsGetCollectionRequest) FieldsAppInfos(fieldsAppInfos []string) ApiAppsGetCollectionRequest {
	r.fieldsAppInfos = &fieldsAppInfos
	return r
}

// the fields to include for returned resources of type betaAppLocalizations
func (r ApiAppsGetCollectionRequest) FieldsBetaAppLocalizations(fieldsBetaAppLocalizations []string) ApiAppsGetCollectionRequest {
	r.fieldsBetaAppLocalizations = &fieldsBetaAppLocalizations
	return r
}

// the fields to include for returned resources of type appPricePoints
func (r ApiAppsGetCollectionRequest) FieldsAppPricePoints(fieldsAppPricePoints []string) ApiAppsGetCollectionRequest {
	r.fieldsAppPricePoints = &fieldsAppPricePoints
	return r
}

// the fields to include for returned resources of type inAppPurchases
func (r ApiAppsGetCollectionRequest) FieldsInAppPurchases(fieldsInAppPurchases []string) ApiAppsGetCollectionRequest {
	r.fieldsInAppPurchases = &fieldsInAppPurchases
	return r
}

// the fields to include for returned resources of type preReleaseVersions
func (r ApiAppsGetCollectionRequest) FieldsPreReleaseVersions(fieldsPreReleaseVersions []string) ApiAppsGetCollectionRequest {
	r.fieldsPreReleaseVersions = &fieldsPreReleaseVersions
	return r
}

// the fields to include for returned resources of type subscriptionGroups
func (r ApiAppsGetCollectionRequest) FieldsSubscriptionGroups(fieldsSubscriptionGroups []string) ApiAppsGetCollectionRequest {
	r.fieldsSubscriptionGroups = &fieldsSubscriptionGroups
	return r
}

// the fields to include for returned resources of type appPrices
// Deprecated
func (r ApiAppsGetCollectionRequest) FieldsAppPrices(fieldsAppPrices []string) ApiAppsGetCollectionRequest {
	r.fieldsAppPrices = &fieldsAppPrices
	return r
}

// the fields to include for returned resources of type appPreOrders
func (r ApiAppsGetCollectionRequest) FieldsAppPreOrders(fieldsAppPreOrders []string) ApiAppsGetCollectionRequest {
	r.fieldsAppPreOrders = &fieldsAppPreOrders
	return r
}

// the fields to include for returned resources of type appStoreVersionExperiments
func (r ApiAppsGetCollectionRequest) FieldsAppStoreVersionExperiments(fieldsAppStoreVersionExperiments []string) ApiAppsGetCollectionRequest {
	r.fieldsAppStoreVersionExperiments = &fieldsAppStoreVersionExperiments
	return r
}

// the fields to include for returned resources of type gameCenterEnabledVersions
// Deprecated
func (r ApiAppsGetCollectionRequest) FieldsGameCenterEnabledVersions(fieldsGameCenterEnabledVersions []string) ApiAppsGetCollectionRequest {
	r.fieldsGameCenterEnabledVersions = &fieldsGameCenterEnabledVersions
	return r
}

// the fields to include for returned resources of type subscriptionGracePeriods
func (r ApiAppsGetCollectionRequest) FieldsSubscriptionGracePeriods(fieldsSubscriptionGracePeriods []string) ApiAppsGetCollectionRequest {
	r.fieldsSubscriptionGracePeriods = &fieldsSubscriptionGracePeriods
	return r
}

// the fields to include for returned resources of type endUserLicenseAgreements
func (r ApiAppsGetCollectionRequest) FieldsEndUserLicenseAgreements(fieldsEndUserLicenseAgreements []string) ApiAppsGetCollectionRequest {
	r.fieldsEndUserLicenseAgreements = &fieldsEndUserLicenseAgreements
	return r
}

// the fields to include for returned resources of type appStoreVersions
func (r ApiAppsGetCollectionRequest) FieldsAppStoreVersions(fieldsAppStoreVersions []string) ApiAppsGetCollectionRequest {
	r.fieldsAppStoreVersions = &fieldsAppStoreVersions
	return r
}

// the fields to include for returned resources of type appCustomProductPages
func (r ApiAppsGetCollectionRequest) FieldsAppCustomProductPages(fieldsAppCustomProductPages []string) ApiAppsGetCollectionRequest {
	r.fieldsAppCustomProductPages = &fieldsAppCustomProductPages
	return r
}

// the fields to include for returned resources of type appEncryptionDeclarations
func (r ApiAppsGetCollectionRequest) FieldsAppEncryptionDeclarations(fieldsAppEncryptionDeclarations []string) ApiAppsGetCollectionRequest {
	r.fieldsAppEncryptionDeclarations = &fieldsAppEncryptionDeclarations
	return r
}

// the fields to include for returned resources of type territories
// Deprecated
func (r ApiAppsGetCollectionRequest) FieldsTerritories(fieldsTerritories []string) ApiAppsGetCollectionRequest {
	r.fieldsTerritories = &fieldsTerritories
	return r
}

// the fields to include for returned resources of type perfPowerMetrics
func (r ApiAppsGetCollectionRequest) FieldsPerfPowerMetrics(fieldsPerfPowerMetrics []string) ApiAppsGetCollectionRequest {
	r.fieldsPerfPowerMetrics = &fieldsPerfPowerMetrics
	return r
}

// maximum number of related appClips returned (when they are included)
func (r ApiAppsGetCollectionRequest) LimitAppClips(limitAppClips int32) ApiAppsGetCollectionRequest {
	r.limitAppClips = &limitAppClips
	return r
}

// maximum number of related appCustomProductPages returned (when they are included)
func (r ApiAppsGetCollectionRequest) LimitAppCustomProductPages(limitAppCustomProductPages int32) ApiAppsGetCollectionRequest {
	r.limitAppCustomProductPages = &limitAppCustomProductPages
	return r
}

// maximum number of related appEncryptionDeclarations returned (when they are included)
func (r ApiAppsGetCollectionRequest) LimitAppEncryptionDeclarations(limitAppEncryptionDeclarations int32) ApiAppsGetCollectionRequest {
	r.limitAppEncryptionDeclarations = &limitAppEncryptionDeclarations
	return r
}

// maximum number of related appEvents returned (when they are included)
func (r ApiAppsGetCollectionRequest) LimitAppEvents(limitAppEvents int32) ApiAppsGetCollectionRequest {
	r.limitAppEvents = &limitAppEvents
	return r
}

// maximum number of related appInfos returned (when they are included)
func (r ApiAppsGetCollectionRequest) LimitAppInfos(limitAppInfos int32) ApiAppsGetCollectionRequest {
	r.limitAppInfos = &limitAppInfos
	return r
}

// maximum number of related appStoreVersionExperimentsV2 returned (when they are included)
func (r ApiAppsGetCollectionRequest) LimitAppStoreVersionExperimentsV2(limitAppStoreVersionExperimentsV2 int32) ApiAppsGetCollectionRequest {
	r.limitAppStoreVersionExperimentsV2 = &limitAppStoreVersionExperimentsV2
	return r
}

// maximum number of related appStoreVersions returned (when they are included)
func (r ApiAppsGetCollectionRequest) LimitAppStoreVersions(limitAppStoreVersions int32) ApiAppsGetCollectionRequest {
	r.limitAppStoreVersions = &limitAppStoreVersions
	return r
}

// maximum number of related availableTerritories returned (when they are included)
func (r ApiAppsGetCollectionRequest) LimitAvailableTerritories(limitAvailableTerritories int32) ApiAppsGetCollectionRequest {
	r.limitAvailableTerritories = &limitAvailableTerritories
	return r
}

// maximum number of related betaAppLocalizations returned (when they are included)
func (r ApiAppsGetCollectionRequest) LimitBetaAppLocalizations(limitBetaAppLocalizations int32) ApiAppsGetCollectionRequest {
	r.limitBetaAppLocalizations = &limitBetaAppLocalizations
	return r
}

// maximum number of related betaGroups returned (when they are included)
func (r ApiAppsGetCollectionRequest) LimitBetaGroups(limitBetaGroups int32) ApiAppsGetCollectionRequest {
	r.limitBetaGroups = &limitBetaGroups
	return r
}

// maximum number of related builds returned (when they are included)
func (r ApiAppsGetCollectionRequest) LimitBuilds(limitBuilds int32) ApiAppsGetCollectionRequest {
	r.limitBuilds = &limitBuilds
	return r
}

// maximum number of related gameCenterEnabledVersions returned (when they are included)
// Deprecated
func (r ApiAppsGetCollectionRequest) LimitGameCenterEnabledVersions(limitGameCenterEnabledVersions int32) ApiAppsGetCollectionRequest {
	r.limitGameCenterEnabledVersions = &limitGameCenterEnabledVersions
	return r
}

// maximum number of related inAppPurchases returned (when they are included)
// Deprecated
func (r ApiAppsGetCollectionRequest) LimitInAppPurchases(limitInAppPurchases int32) ApiAppsGetCollectionRequest {
	r.limitInAppPurchases = &limitInAppPurchases
	return r
}

// maximum number of related inAppPurchasesV2 returned (when they are included)
func (r ApiAppsGetCollectionRequest) LimitInAppPurchasesV2(limitInAppPurchasesV2 int32) ApiAppsGetCollectionRequest {
	r.limitInAppPurchasesV2 = &limitInAppPurchasesV2
	return r
}

// maximum number of related preReleaseVersions returned (when they are included)
func (r ApiAppsGetCollectionRequest) LimitPreReleaseVersions(limitPreReleaseVersions int32) ApiAppsGetCollectionRequest {
	r.limitPreReleaseVersions = &limitPreReleaseVersions
	return r
}

// maximum number of related prices returned (when they are included)
// Deprecated
func (r ApiAppsGetCollectionRequest) LimitPrices(limitPrices int32) ApiAppsGetCollectionRequest {
	r.limitPrices = &limitPrices
	return r
}

// maximum number of related promotedPurchases returned (when they are included)
func (r ApiAppsGetCollectionRequest) LimitPromotedPurchases(limitPromotedPurchases int32) ApiAppsGetCollectionRequest {
	r.limitPromotedPurchases = &limitPromotedPurchases
	return r
}

// maximum number of related reviewSubmissions returned (when they are included)
func (r ApiAppsGetCollectionRequest) LimitReviewSubmissions(limitReviewSubmissions int32) ApiAppsGetCollectionRequest {
	r.limitReviewSubmissions = &limitReviewSubmissions
	return r
}

// maximum number of related subscriptionGroups returned (when they are included)
func (r ApiAppsGetCollectionRequest) LimitSubscriptionGroups(limitSubscriptionGroups int32) ApiAppsGetCollectionRequest {
	r.limitSubscriptionGroups = &limitSubscriptionGroups
	return r
}

func (r ApiAppsGetCollectionRequest) Execute() (*AppsResponse, *http.Response, error) {
	return r.ApiService.AppsGetCollectionExecute(r)
}

/*
AppsGetCollection Method for AppsGetCollection

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiAppsGetCollectionRequest
*/
func (a *AppsApiService) AppsGetCollection(ctx context.Context) ApiAppsGetCollectionRequest {
	return ApiAppsGetCollectionRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return AppsResponse
func (a *AppsApiService) AppsGetCollectionExecute(r ApiAppsGetCollectionRequest) (*AppsResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *AppsResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AppsApiService.AppsGetCollection")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/apps"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.filterAppStoreVersionsAppStoreState != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter[appStoreVersions.appStoreState]", r.filterAppStoreVersionsAppStoreState, "csv")
	}
	if r.filterAppStoreVersionsPlatform != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter[appStoreVersions.platform]", r.filterAppStoreVersionsPlatform, "csv")
	}
	if r.filterBundleId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter[bundleId]", r.filterBundleId, "csv")
	}
	if r.filterName != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter[name]", r.filterName, "csv")
	}
	if r.filterSku != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter[sku]", r.filterSku, "csv")
	}
	if r.filterAppStoreVersions != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter[appStoreVersions]", r.filterAppStoreVersions, "csv")
	}
	if r.filterId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter[id]", r.filterId, "csv")
	}
	if r.existsGameCenterEnabledVersions != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "exists[gameCenterEnabledVersions]", r.existsGameCenterEnabledVersions, "")
	}
	if r.sort != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "sort", r.sort, "csv")
	}
	if r.fieldsApps != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields[apps]", r.fieldsApps, "csv")
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "")
	}
	if r.include != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "include", r.include, "csv")
	}
	if r.fieldsBetaAppReviewDetails != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields[betaAppReviewDetails]", r.fieldsBetaAppReviewDetails, "csv")
	}
	if r.fieldsGameCenterDetails != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields[gameCenterDetails]", r.fieldsGameCenterDetails, "csv")
	}
	if r.fieldsAppPriceSchedules != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields[appPriceSchedules]", r.fieldsAppPriceSchedules, "csv")
	}
	if r.fieldsCiProducts != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields[ciProducts]", r.fieldsCiProducts, "csv")
	}
	if r.fieldsReviewSubmissions != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields[reviewSubmissions]", r.fieldsReviewSubmissions, "csv")
	}
	if r.fieldsBetaGroups != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields[betaGroups]", r.fieldsBetaGroups, "csv")
	}
	if r.fieldsPromotedPurchases != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields[promotedPurchases]", r.fieldsPromotedPurchases, "csv")
	}
	if r.fieldsAppAvailabilities != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields[appAvailabilities]", r.fieldsAppAvailabilities, "csv")
	}
	if r.fieldsCustomerReviews != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields[customerReviews]", r.fieldsCustomerReviews, "csv")
	}
	if r.fieldsAppEvents != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields[appEvents]", r.fieldsAppEvents, "csv")
	}
	if r.fieldsBuilds != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields[builds]", r.fieldsBuilds, "csv")
	}
	if r.fieldsBetaLicenseAgreements != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields[betaLicenseAgreements]", r.fieldsBetaLicenseAgreements, "csv")
	}
	if r.fieldsAppClips != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields[appClips]", r.fieldsAppClips, "csv")
	}
	if r.fieldsAppInfos != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields[appInfos]", r.fieldsAppInfos, "csv")
	}
	if r.fieldsBetaAppLocalizations != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields[betaAppLocalizations]", r.fieldsBetaAppLocalizations, "csv")
	}
	if r.fieldsAppPricePoints != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields[appPricePoints]", r.fieldsAppPricePoints, "csv")
	}
	if r.fieldsInAppPurchases != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields[inAppPurchases]", r.fieldsInAppPurchases, "csv")
	}
	if r.fieldsPreReleaseVersions != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields[preReleaseVersions]", r.fieldsPreReleaseVersions, "csv")
	}
	if r.fieldsSubscriptionGroups != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields[subscriptionGroups]", r.fieldsSubscriptionGroups, "csv")
	}
	if r.fieldsAppPrices != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields[appPrices]", r.fieldsAppPrices, "csv")
	}
	if r.fieldsAppPreOrders != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields[appPreOrders]", r.fieldsAppPreOrders, "csv")
	}
	if r.fieldsAppStoreVersionExperiments != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields[appStoreVersionExperiments]", r.fieldsAppStoreVersionExperiments, "csv")
	}
	if r.fieldsGameCenterEnabledVersions != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields[gameCenterEnabledVersions]", r.fieldsGameCenterEnabledVersions, "csv")
	}
	if r.fieldsSubscriptionGracePeriods != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields[subscriptionGracePeriods]", r.fieldsSubscriptionGracePeriods, "csv")
	}
	if r.fieldsEndUserLicenseAgreements != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields[endUserLicenseAgreements]", r.fieldsEndUserLicenseAgreements, "csv")
	}
	if r.fieldsAppStoreVersions != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields[appStoreVersions]", r.fieldsAppStoreVersions, "csv")
	}
	if r.fieldsAppCustomProductPages != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields[appCustomProductPages]", r.fieldsAppCustomProductPages, "csv")
	}
	if r.fieldsAppEncryptionDeclarations != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields[appEncryptionDeclarations]", r.fieldsAppEncryptionDeclarations, "csv")
	}
	if r.fieldsTerritories != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields[territories]", r.fieldsTerritories, "csv")
	}
	if r.fieldsPerfPowerMetrics != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields[perfPowerMetrics]", r.fieldsPerfPowerMetrics, "csv")
	}
	if r.limitAppClips != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit[appClips]", r.limitAppClips, "")
	}
	if r.limitAppCustomProductPages != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit[appCustomProductPages]", r.limitAppCustomProductPages, "")
	}
	if r.limitAppEncryptionDeclarations != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit[appEncryptionDeclarations]", r.limitAppEncryptionDeclarations, "")
	}
	if r.limitAppEvents != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit[appEvents]", r.limitAppEvents, "")
	}
	if r.limitAppInfos != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit[appInfos]", r.limitAppInfos, "")
	}
	if r.limitAppStoreVersionExperimentsV2 != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit[appStoreVersionExperimentsV2]", r.limitAppStoreVersionExperimentsV2, "")
	}
	if r.limitAppStoreVersions != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit[appStoreVersions]", r.limitAppStoreVersions, "")
	}
	if r.limitAvailableTerritories != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit[availableTerritories]", r.limitAvailableTerritories, "")
	}
	if r.limitBetaAppLocalizations != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit[betaAppLocalizations]", r.limitBetaAppLocalizations, "")
	}
	if r.limitBetaGroups != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit[betaGroups]", r.limitBetaGroups, "")
	}
	if r.limitBuilds != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit[builds]", r.limitBuilds, "")
	}
	if r.limitGameCenterEnabledVersions != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit[gameCenterEnabledVersions]", r.limitGameCenterEnabledVersions, "")
	}
	if r.limitInAppPurchases != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit[inAppPurchases]", r.limitInAppPurchases, "")
	}
	if r.limitInAppPurchasesV2 != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit[inAppPurchasesV2]", r.limitInAppPurchasesV2, "")
	}
	if r.limitPreReleaseVersions != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit[preReleaseVersions]", r.limitPreReleaseVersions, "")
	}
	if r.limitPrices != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit[prices]", r.limitPrices, "")
	}
	if r.limitPromotedPurchases != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit[promotedPurchases]", r.limitPromotedPurchases, "")
	}
	if r.limitReviewSubmissions != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit[reviewSubmissions]", r.limitReviewSubmissions, "")
	}
	if r.limitSubscriptionGroups != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit[subscriptionGroups]", r.limitSubscriptionGroups, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiAppsGetInstanceRequest struct {
	ctx                               context.Context
	ApiService                        *AppsApiService
	id                                string
	fieldsApps                        *[]string
	include                           *[]string
	fieldsBetaAppReviewDetails        *[]string
	fieldsGameCenterDetails           *[]string
	fieldsAppPriceSchedules           *[]string
	fieldsCiProducts                  *[]string
	fieldsReviewSubmissions           *[]string
	fieldsBetaGroups                  *[]string
	fieldsPromotedPurchases           *[]string
	fieldsAppAvailabilities           *[]string
	fieldsCustomerReviews             *[]string
	fieldsAppEvents                   *[]string
	fieldsBuilds                      *[]string
	fieldsBetaLicenseAgreements       *[]string
	fieldsAppClips                    *[]string
	fieldsAppInfos                    *[]string
	fieldsBetaAppLocalizations        *[]string
	fieldsAppPricePoints              *[]string
	fieldsInAppPurchases              *[]string
	fieldsPreReleaseVersions          *[]string
	fieldsSubscriptionGroups          *[]string
	fieldsAppPrices                   *[]string
	fieldsAppPreOrders                *[]string
	fieldsAppStoreVersionExperiments  *[]string
	fieldsGameCenterEnabledVersions   *[]string
	fieldsSubscriptionGracePeriods    *[]string
	fieldsEndUserLicenseAgreements    *[]string
	fieldsAppStoreVersions            *[]string
	fieldsAppCustomProductPages       *[]string
	fieldsAppEncryptionDeclarations   *[]string
	fieldsTerritories                 *[]string
	fieldsPerfPowerMetrics            *[]string
	limitAppClips                     *int32
	limitAppCustomProductPages        *int32
	limitAppEncryptionDeclarations    *int32
	limitAppEvents                    *int32
	limitAppInfos                     *int32
	limitAppStoreVersionExperimentsV2 *int32
	limitAppStoreVersions             *int32
	limitAvailableTerritories         *int32
	limitBetaAppLocalizations         *int32
	limitBetaGroups                   *int32
	limitBuilds                       *int32
	limitGameCenterEnabledVersions    *int32
	limitInAppPurchases               *int32
	limitInAppPurchasesV2             *int32
	limitPreReleaseVersions           *int32
	limitPrices                       *int32
	limitPromotedPurchases            *int32
	limitReviewSubmissions            *int32
	limitSubscriptionGroups           *int32
}

// the fields to include for returned resources of type apps
func (r ApiAppsGetInstanceRequest) FieldsApps(fieldsApps []string) ApiAppsGetInstanceRequest {
	r.fieldsApps = &fieldsApps
	return r
}

// comma-separated list of relationships to include
func (r ApiAppsGetInstanceRequest) Include(include []string) ApiAppsGetInstanceRequest {
	r.include = &include
	return r
}

// the fields to include for returned resources of type betaAppReviewDetails
func (r ApiAppsGetInstanceRequest) FieldsBetaAppReviewDetails(fieldsBetaAppReviewDetails []string) ApiAppsGetInstanceRequest {
	r.fieldsBetaAppReviewDetails = &fieldsBetaAppReviewDetails
	return r
}

// the fields to include for returned resources of type gameCenterDetails
func (r ApiAppsGetInstanceRequest) FieldsGameCenterDetails(fieldsGameCenterDetails []string) ApiAppsGetInstanceRequest {
	r.fieldsGameCenterDetails = &fieldsGameCenterDetails
	return r
}

// the fields to include for returned resources of type appPriceSchedules
func (r ApiAppsGetInstanceRequest) FieldsAppPriceSchedules(fieldsAppPriceSchedules []string) ApiAppsGetInstanceRequest {
	r.fieldsAppPriceSchedules = &fieldsAppPriceSchedules
	return r
}

// the fields to include for returned resources of type ciProducts
func (r ApiAppsGetInstanceRequest) FieldsCiProducts(fieldsCiProducts []string) ApiAppsGetInstanceRequest {
	r.fieldsCiProducts = &fieldsCiProducts
	return r
}

// the fields to include for returned resources of type reviewSubmissions
func (r ApiAppsGetInstanceRequest) FieldsReviewSubmissions(fieldsReviewSubmissions []string) ApiAppsGetInstanceRequest {
	r.fieldsReviewSubmissions = &fieldsReviewSubmissions
	return r
}

// the fields to include for returned resources of type betaGroups
func (r ApiAppsGetInstanceRequest) FieldsBetaGroups(fieldsBetaGroups []string) ApiAppsGetInstanceRequest {
	r.fieldsBetaGroups = &fieldsBetaGroups
	return r
}

// the fields to include for returned resources of type promotedPurchases
func (r ApiAppsGetInstanceRequest) FieldsPromotedPurchases(fieldsPromotedPurchases []string) ApiAppsGetInstanceRequest {
	r.fieldsPromotedPurchases = &fieldsPromotedPurchases
	return r
}

// the fields to include for returned resources of type appAvailabilities
func (r ApiAppsGetInstanceRequest) FieldsAppAvailabilities(fieldsAppAvailabilities []string) ApiAppsGetInstanceRequest {
	r.fieldsAppAvailabilities = &fieldsAppAvailabilities
	return r
}

// the fields to include for returned resources of type customerReviews
func (r ApiAppsGetInstanceRequest) FieldsCustomerReviews(fieldsCustomerReviews []string) ApiAppsGetInstanceRequest {
	r.fieldsCustomerReviews = &fieldsCustomerReviews
	return r
}

// the fields to include for returned resources of type appEvents
func (r ApiAppsGetInstanceRequest) FieldsAppEvents(fieldsAppEvents []string) ApiAppsGetInstanceRequest {
	r.fieldsAppEvents = &fieldsAppEvents
	return r
}

// the fields to include for returned resources of type builds
func (r ApiAppsGetInstanceRequest) FieldsBuilds(fieldsBuilds []string) ApiAppsGetInstanceRequest {
	r.fieldsBuilds = &fieldsBuilds
	return r
}

// the fields to include for returned resources of type betaLicenseAgreements
func (r ApiAppsGetInstanceRequest) FieldsBetaLicenseAgreements(fieldsBetaLicenseAgreements []string) ApiAppsGetInstanceRequest {
	r.fieldsBetaLicenseAgreements = &fieldsBetaLicenseAgreements
	return r
}

// the fields to include for returned resources of type appClips
func (r ApiAppsGetInstanceRequest) FieldsAppClips(fieldsAppClips []string) ApiAppsGetInstanceRequest {
	r.fieldsAppClips = &fieldsAppClips
	return r
}

// the fields to include for returned resources of type appInfos
func (r ApiAppsGetInstanceRequest) FieldsAppInfos(fieldsAppInfos []string) ApiAppsGetInstanceRequest {
	r.fieldsAppInfos = &fieldsAppInfos
	return r
}

// the fields to include for returned resources of type betaAppLocalizations
func (r ApiAppsGetInstanceRequest) FieldsBetaAppLocalizations(fieldsBetaAppLocalizations []string) ApiAppsGetInstanceRequest {
	r.fieldsBetaAppLocalizations = &fieldsBetaAppLocalizations
	return r
}

// the fields to include for returned resources of type appPricePoints
func (r ApiAppsGetInstanceRequest) FieldsAppPricePoints(fieldsAppPricePoints []string) ApiAppsGetInstanceRequest {
	r.fieldsAppPricePoints = &fieldsAppPricePoints
	return r
}

// the fields to include for returned resources of type inAppPurchases
func (r ApiAppsGetInstanceRequest) FieldsInAppPurchases(fieldsInAppPurchases []string) ApiAppsGetInstanceRequest {
	r.fieldsInAppPurchases = &fieldsInAppPurchases
	return r
}

// the fields to include for returned resources of type preReleaseVersions
func (r ApiAppsGetInstanceRequest) FieldsPreReleaseVersions(fieldsPreReleaseVersions []string) ApiAppsGetInstanceRequest {
	r.fieldsPreReleaseVersions = &fieldsPreReleaseVersions
	return r
}

// the fields to include for returned resources of type subscriptionGroups
func (r ApiAppsGetInstanceRequest) FieldsSubscriptionGroups(fieldsSubscriptionGroups []string) ApiAppsGetInstanceRequest {
	r.fieldsSubscriptionGroups = &fieldsSubscriptionGroups
	return r
}

// the fields to include for returned resources of type appPrices
// Deprecated
func (r ApiAppsGetInstanceRequest) FieldsAppPrices(fieldsAppPrices []string) ApiAppsGetInstanceRequest {
	r.fieldsAppPrices = &fieldsAppPrices
	return r
}

// the fields to include for returned resources of type appPreOrders
func (r ApiAppsGetInstanceRequest) FieldsAppPreOrders(fieldsAppPreOrders []string) ApiAppsGetInstanceRequest {
	r.fieldsAppPreOrders = &fieldsAppPreOrders
	return r
}

// the fields to include for returned resources of type appStoreVersionExperiments
func (r ApiAppsGetInstanceRequest) FieldsAppStoreVersionExperiments(fieldsAppStoreVersionExperiments []string) ApiAppsGetInstanceRequest {
	r.fieldsAppStoreVersionExperiments = &fieldsAppStoreVersionExperiments
	return r
}

// the fields to include for returned resources of type gameCenterEnabledVersions
// Deprecated
func (r ApiAppsGetInstanceRequest) FieldsGameCenterEnabledVersions(fieldsGameCenterEnabledVersions []string) ApiAppsGetInstanceRequest {
	r.fieldsGameCenterEnabledVersions = &fieldsGameCenterEnabledVersions
	return r
}

// the fields to include for returned resources of type subscriptionGracePeriods
func (r ApiAppsGetInstanceRequest) FieldsSubscriptionGracePeriods(fieldsSubscriptionGracePeriods []string) ApiAppsGetInstanceRequest {
	r.fieldsSubscriptionGracePeriods = &fieldsSubscriptionGracePeriods
	return r
}

// the fields to include for returned resources of type endUserLicenseAgreements
func (r ApiAppsGetInstanceRequest) FieldsEndUserLicenseAgreements(fieldsEndUserLicenseAgreements []string) ApiAppsGetInstanceRequest {
	r.fieldsEndUserLicenseAgreements = &fieldsEndUserLicenseAgreements
	return r
}

// the fields to include for returned resources of type appStoreVersions
func (r ApiAppsGetInstanceRequest) FieldsAppStoreVersions(fieldsAppStoreVersions []string) ApiAppsGetInstanceRequest {
	r.fieldsAppStoreVersions = &fieldsAppStoreVersions
	return r
}

// the fields to include for returned resources of type appCustomProductPages
func (r ApiAppsGetInstanceRequest) FieldsAppCustomProductPages(fieldsAppCustomProductPages []string) ApiAppsGetInstanceRequest {
	r.fieldsAppCustomProductPages = &fieldsAppCustomProductPages
	return r
}

// the fields to include for returned resources of type appEncryptionDeclarations
func (r ApiAppsGetInstanceRequest) FieldsAppEncryptionDeclarations(fieldsAppEncryptionDeclarations []string) ApiAppsGetInstanceRequest {
	r.fieldsAppEncryptionDeclarations = &fieldsAppEncryptionDeclarations
	return r
}

// the fields to include for returned resources of type territories
// Deprecated
func (r ApiAppsGetInstanceRequest) FieldsTerritories(fieldsTerritories []string) ApiAppsGetInstanceRequest {
	r.fieldsTerritories = &fieldsTerritories
	return r
}

// the fields to include for returned resources of type perfPowerMetrics
func (r ApiAppsGetInstanceRequest) FieldsPerfPowerMetrics(fieldsPerfPowerMetrics []string) ApiAppsGetInstanceRequest {
	r.fieldsPerfPowerMetrics = &fieldsPerfPowerMetrics
	return r
}

// maximum number of related appClips returned (when they are included)
func (r ApiAppsGetInstanceRequest) LimitAppClips(limitAppClips int32) ApiAppsGetInstanceRequest {
	r.limitAppClips = &limitAppClips
	return r
}

// maximum number of related appCustomProductPages returned (when they are included)
func (r ApiAppsGetInstanceRequest) LimitAppCustomProductPages(limitAppCustomProductPages int32) ApiAppsGetInstanceRequest {
	r.limitAppCustomProductPages = &limitAppCustomProductPages
	return r
}

// maximum number of related appEncryptionDeclarations returned (when they are included)
func (r ApiAppsGetInstanceRequest) LimitAppEncryptionDeclarations(limitAppEncryptionDeclarations int32) ApiAppsGetInstanceRequest {
	r.limitAppEncryptionDeclarations = &limitAppEncryptionDeclarations
	return r
}

// maximum number of related appEvents returned (when they are included)
func (r ApiAppsGetInstanceRequest) LimitAppEvents(limitAppEvents int32) ApiAppsGetInstanceRequest {
	r.limitAppEvents = &limitAppEvents
	return r
}

// maximum number of related appInfos returned (when they are included)
func (r ApiAppsGetInstanceRequest) LimitAppInfos(limitAppInfos int32) ApiAppsGetInstanceRequest {
	r.limitAppInfos = &limitAppInfos
	return r
}

// maximum number of related appStoreVersionExperimentsV2 returned (when they are included)
func (r ApiAppsGetInstanceRequest) LimitAppStoreVersionExperimentsV2(limitAppStoreVersionExperimentsV2 int32) ApiAppsGetInstanceRequest {
	r.limitAppStoreVersionExperimentsV2 = &limitAppStoreVersionExperimentsV2
	return r
}

// maximum number of related appStoreVersions returned (when they are included)
func (r ApiAppsGetInstanceRequest) LimitAppStoreVersions(limitAppStoreVersions int32) ApiAppsGetInstanceRequest {
	r.limitAppStoreVersions = &limitAppStoreVersions
	return r
}

// maximum number of related availableTerritories returned (when they are included)
func (r ApiAppsGetInstanceRequest) LimitAvailableTerritories(limitAvailableTerritories int32) ApiAppsGetInstanceRequest {
	r.limitAvailableTerritories = &limitAvailableTerritories
	return r
}

// maximum number of related betaAppLocalizations returned (when they are included)
func (r ApiAppsGetInstanceRequest) LimitBetaAppLocalizations(limitBetaAppLocalizations int32) ApiAppsGetInstanceRequest {
	r.limitBetaAppLocalizations = &limitBetaAppLocalizations
	return r
}

// maximum number of related betaGroups returned (when they are included)
func (r ApiAppsGetInstanceRequest) LimitBetaGroups(limitBetaGroups int32) ApiAppsGetInstanceRequest {
	r.limitBetaGroups = &limitBetaGroups
	return r
}

// maximum number of related builds returned (when they are included)
func (r ApiAppsGetInstanceRequest) LimitBuilds(limitBuilds int32) ApiAppsGetInstanceRequest {
	r.limitBuilds = &limitBuilds
	return r
}

// maximum number of related gameCenterEnabledVersions returned (when they are included)
// Deprecated
func (r ApiAppsGetInstanceRequest) LimitGameCenterEnabledVersions(limitGameCenterEnabledVersions int32) ApiAppsGetInstanceRequest {
	r.limitGameCenterEnabledVersions = &limitGameCenterEnabledVersions
	return r
}

// maximum number of related inAppPurchases returned (when they are included)
// Deprecated
func (r ApiAppsGetInstanceRequest) LimitInAppPurchases(limitInAppPurchases int32) ApiAppsGetInstanceRequest {
	r.limitInAppPurchases = &limitInAppPurchases
	return r
}

// maximum number of related inAppPurchasesV2 returned (when they are included)
func (r ApiAppsGetInstanceRequest) LimitInAppPurchasesV2(limitInAppPurchasesV2 int32) ApiAppsGetInstanceRequest {
	r.limitInAppPurchasesV2 = &limitInAppPurchasesV2
	return r
}

// maximum number of related preReleaseVersions returned (when they are included)
func (r ApiAppsGetInstanceRequest) LimitPreReleaseVersions(limitPreReleaseVersions int32) ApiAppsGetInstanceRequest {
	r.limitPreReleaseVersions = &limitPreReleaseVersions
	return r
}

// maximum number of related prices returned (when they are included)
// Deprecated
func (r ApiAppsGetInstanceRequest) LimitPrices(limitPrices int32) ApiAppsGetInstanceRequest {
	r.limitPrices = &limitPrices
	return r
}

// maximum number of related promotedPurchases returned (when they are included)
func (r ApiAppsGetInstanceRequest) LimitPromotedPurchases(limitPromotedPurchases int32) ApiAppsGetInstanceRequest {
	r.limitPromotedPurchases = &limitPromotedPurchases
	return r
}

// maximum number of related reviewSubmissions returned (when they are included)
func (r ApiAppsGetInstanceRequest) LimitReviewSubmissions(limitReviewSubmissions int32) ApiAppsGetInstanceRequest {
	r.limitReviewSubmissions = &limitReviewSubmissions
	return r
}

// maximum number of related subscriptionGroups returned (when they are included)
func (r ApiAppsGetInstanceRequest) LimitSubscriptionGroups(limitSubscriptionGroups int32) ApiAppsGetInstanceRequest {
	r.limitSubscriptionGroups = &limitSubscriptionGroups
	return r
}

func (r ApiAppsGetInstanceRequest) Execute() (*AppResponse, *http.Response, error) {
	return r.ApiService.AppsGetInstanceExecute(r)
}

/*
AppsGetInstance Method for AppsGetInstance

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id the id of the requested resource
	@return ApiAppsGetInstanceRequest
*/
func (a *AppsApiService) AppsGetInstance(ctx context.Context, id string) ApiAppsGetInstanceRequest {
	return ApiAppsGetInstanceRequest{
		ApiService: a,
		ctx:        ctx,
		id:         id,
	}
}

// Execute executes the request
//
//	@return AppResponse
func (a *AppsApiService) AppsGetInstanceExecute(r ApiAppsGetInstanceRequest) (*AppResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *AppResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AppsApiService.AppsGetInstance")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/apps/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.fieldsApps != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields[apps]", r.fieldsApps, "csv")
	}
	if r.include != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "include", r.include, "csv")
	}
	if r.fieldsBetaAppReviewDetails != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields[betaAppReviewDetails]", r.fieldsBetaAppReviewDetails, "csv")
	}
	if r.fieldsGameCenterDetails != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields[gameCenterDetails]", r.fieldsGameCenterDetails, "csv")
	}
	if r.fieldsAppPriceSchedules != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields[appPriceSchedules]", r.fieldsAppPriceSchedules, "csv")
	}
	if r.fieldsCiProducts != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields[ciProducts]", r.fieldsCiProducts, "csv")
	}
	if r.fieldsReviewSubmissions != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields[reviewSubmissions]", r.fieldsReviewSubmissions, "csv")
	}
	if r.fieldsBetaGroups != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields[betaGroups]", r.fieldsBetaGroups, "csv")
	}
	if r.fieldsPromotedPurchases != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields[promotedPurchases]", r.fieldsPromotedPurchases, "csv")
	}
	if r.fieldsAppAvailabilities != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields[appAvailabilities]", r.fieldsAppAvailabilities, "csv")
	}
	if r.fieldsCustomerReviews != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields[customerReviews]", r.fieldsCustomerReviews, "csv")
	}
	if r.fieldsAppEvents != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields[appEvents]", r.fieldsAppEvents, "csv")
	}
	if r.fieldsBuilds != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields[builds]", r.fieldsBuilds, "csv")
	}
	if r.fieldsBetaLicenseAgreements != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields[betaLicenseAgreements]", r.fieldsBetaLicenseAgreements, "csv")
	}
	if r.fieldsAppClips != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields[appClips]", r.fieldsAppClips, "csv")
	}
	if r.fieldsAppInfos != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields[appInfos]", r.fieldsAppInfos, "csv")
	}
	if r.fieldsBetaAppLocalizations != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields[betaAppLocalizations]", r.fieldsBetaAppLocalizations, "csv")
	}
	if r.fieldsAppPricePoints != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields[appPricePoints]", r.fieldsAppPricePoints, "csv")
	}
	if r.fieldsInAppPurchases != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields[inAppPurchases]", r.fieldsInAppPurchases, "csv")
	}
	if r.fieldsPreReleaseVersions != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields[preReleaseVersions]", r.fieldsPreReleaseVersions, "csv")
	}
	if r.fieldsSubscriptionGroups != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields[subscriptionGroups]", r.fieldsSubscriptionGroups, "csv")
	}
	if r.fieldsAppPrices != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields[appPrices]", r.fieldsAppPrices, "csv")
	}
	if r.fieldsAppPreOrders != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields[appPreOrders]", r.fieldsAppPreOrders, "csv")
	}
	if r.fieldsAppStoreVersionExperiments != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields[appStoreVersionExperiments]", r.fieldsAppStoreVersionExperiments, "csv")
	}
	if r.fieldsGameCenterEnabledVersions != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields[gameCenterEnabledVersions]", r.fieldsGameCenterEnabledVersions, "csv")
	}
	if r.fieldsSubscriptionGracePeriods != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields[subscriptionGracePeriods]", r.fieldsSubscriptionGracePeriods, "csv")
	}
	if r.fieldsEndUserLicenseAgreements != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields[endUserLicenseAgreements]", r.fieldsEndUserLicenseAgreements, "csv")
	}
	if r.fieldsAppStoreVersions != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields[appStoreVersions]", r.fieldsAppStoreVersions, "csv")
	}
	if r.fieldsAppCustomProductPages != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields[appCustomProductPages]", r.fieldsAppCustomProductPages, "csv")
	}
	if r.fieldsAppEncryptionDeclarations != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields[appEncryptionDeclarations]", r.fieldsAppEncryptionDeclarations, "csv")
	}
	if r.fieldsTerritories != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields[territories]", r.fieldsTerritories, "csv")
	}
	if r.fieldsPerfPowerMetrics != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields[perfPowerMetrics]", r.fieldsPerfPowerMetrics, "csv")
	}
	if r.limitAppClips != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit[appClips]", r.limitAppClips, "")
	}
	if r.limitAppCustomProductPages != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit[appCustomProductPages]", r.limitAppCustomProductPages, "")
	}
	if r.limitAppEncryptionDeclarations != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit[appEncryptionDeclarations]", r.limitAppEncryptionDeclarations, "")
	}
	if r.limitAppEvents != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit[appEvents]", r.limitAppEvents, "")
	}
	if r.limitAppInfos != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit[appInfos]", r.limitAppInfos, "")
	}
	if r.limitAppStoreVersionExperimentsV2 != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit[appStoreVersionExperimentsV2]", r.limitAppStoreVersionExperimentsV2, "")
	}
	if r.limitAppStoreVersions != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit[appStoreVersions]", r.limitAppStoreVersions, "")
	}
	if r.limitAvailableTerritories != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit[availableTerritories]", r.limitAvailableTerritories, "")
	}
	if r.limitBetaAppLocalizations != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit[betaAppLocalizations]", r.limitBetaAppLocalizations, "")
	}
	if r.limitBetaGroups != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit[betaGroups]", r.limitBetaGroups, "")
	}
	if r.limitBuilds != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit[builds]", r.limitBuilds, "")
	}
	if r.limitGameCenterEnabledVersions != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit[gameCenterEnabledVersions]", r.limitGameCenterEnabledVersions, "")
	}
	if r.limitInAppPurchases != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit[inAppPurchases]", r.limitInAppPurchases, "")
	}
	if r.limitInAppPurchasesV2 != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit[inAppPurchasesV2]", r.limitInAppPurchasesV2, "")
	}
	if r.limitPreReleaseVersions != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit[preReleaseVersions]", r.limitPreReleaseVersions, "")
	}
	if r.limitPrices != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit[prices]", r.limitPrices, "")
	}
	if r.limitPromotedPurchases != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit[promotedPurchases]", r.limitPromotedPurchases, "")
	}
	if r.limitReviewSubmissions != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit[reviewSubmissions]", r.limitReviewSubmissions, "")
	}
	if r.limitSubscriptionGroups != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit[subscriptionGroups]", r.limitSubscriptionGroups, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiAppsInAppPurchasesGetToManyRelatedRequest struct {
	ctx                     context.Context
	ApiService              *AppsApiService
	id                      string
	filterInAppPurchaseType *[]string
	filterCanBeSubmitted    *[]string
	sort                    *[]string
	fieldsInAppPurchases    *[]string
	fieldsApps              *[]string
	limit                   *int32
	limitApps               *int32
	include                 *[]string
}

// filter by attribute &#39;inAppPurchaseType&#39;
func (r ApiAppsInAppPurchasesGetToManyRelatedRequest) FilterInAppPurchaseType(filterInAppPurchaseType []string) ApiAppsInAppPurchasesGetToManyRelatedRequest {
	r.filterInAppPurchaseType = &filterInAppPurchaseType
	return r
}

// filter by canBeSubmitted
func (r ApiAppsInAppPurchasesGetToManyRelatedRequest) FilterCanBeSubmitted(filterCanBeSubmitted []string) ApiAppsInAppPurchasesGetToManyRelatedRequest {
	r.filterCanBeSubmitted = &filterCanBeSubmitted
	return r
}

// comma-separated list of sort expressions; resources will be sorted as specified
func (r ApiAppsInAppPurchasesGetToManyRelatedRequest) Sort(sort []string) ApiAppsInAppPurchasesGetToManyRelatedRequest {
	r.sort = &sort
	return r
}

// the fields to include for returned resources of type inAppPurchases
func (r ApiAppsInAppPurchasesGetToManyRelatedRequest) FieldsInAppPurchases(fieldsInAppPurchases []string) ApiAppsInAppPurchasesGetToManyRelatedRequest {
	r.fieldsInAppPurchases = &fieldsInAppPurchases
	return r
}

// the fields to include for returned resources of type apps
func (r ApiAppsInAppPurchasesGetToManyRelatedRequest) FieldsApps(fieldsApps []string) ApiAppsInAppPurchasesGetToManyRelatedRequest {
	r.fieldsApps = &fieldsApps
	return r
}

// maximum resources per page
func (r ApiAppsInAppPurchasesGetToManyRelatedRequest) Limit(limit int32) ApiAppsInAppPurchasesGetToManyRelatedRequest {
	r.limit = &limit
	return r
}

// maximum number of related apps returned (when they are included)
func (r ApiAppsInAppPurchasesGetToManyRelatedRequest) LimitApps(limitApps int32) ApiAppsInAppPurchasesGetToManyRelatedRequest {
	r.limitApps = &limitApps
	return r
}

// comma-separated list of relationships to include
func (r ApiAppsInAppPurchasesGetToManyRelatedRequest) Include(include []string) ApiAppsInAppPurchasesGetToManyRelatedRequest {
	r.include = &include
	return r
}

func (r ApiAppsInAppPurchasesGetToManyRelatedRequest) Execute() (*InAppPurchasesResponse, *http.Response, error) {
	return r.ApiService.AppsInAppPurchasesGetToManyRelatedExecute(r)
}

/*
AppsInAppPurchasesGetToManyRelated Method for AppsInAppPurchasesGetToManyRelated

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id the id of the requested resource
	@return ApiAppsInAppPurchasesGetToManyRelatedRequest

Deprecated
*/
func (a *AppsApiService) AppsInAppPurchasesGetToManyRelated(ctx context.Context, id string) ApiAppsInAppPurchasesGetToManyRelatedRequest {
	return ApiAppsInAppPurchasesGetToManyRelatedRequest{
		ApiService: a,
		ctx:        ctx,
		id:         id,
	}
}

// Execute executes the request
//
//	@return InAppPurchasesResponse
//
// Deprecated
func (a *AppsApiService) AppsInAppPurchasesGetToManyRelatedExecute(r ApiAppsInAppPurchasesGetToManyRelatedRequest) (*InAppPurchasesResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *InAppPurchasesResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AppsApiService.AppsInAppPurchasesGetToManyRelated")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/apps/{id}/inAppPurchases"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.filterInAppPurchaseType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter[inAppPurchaseType]", r.filterInAppPurchaseType, "csv")
	}
	if r.filterCanBeSubmitted != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter[canBeSubmitted]", r.filterCanBeSubmitted, "csv")
	}
	if r.sort != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "sort", r.sort, "csv")
	}
	if r.fieldsInAppPurchases != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields[inAppPurchases]", r.fieldsInAppPurchases, "csv")
	}
	if r.fieldsApps != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields[apps]", r.fieldsApps, "csv")
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "")
	}
	if r.limitApps != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit[apps]", r.limitApps, "")
	}
	if r.include != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "include", r.include, "csv")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiAppsInAppPurchasesV2GetToManyRelatedRequest struct {
	ctx                                          context.Context
	ApiService                                   *AppsApiService
	id                                           string
	filterInAppPurchaseType                      *[]string
	filterName                                   *[]string
	filterProductId                              *[]string
	filterState                                  *[]string
	sort                                         *[]string
	fieldsInAppPurchaseAppStoreReviewScreenshots *[]string
	fieldsInAppPurchaseAvailabilities            *[]string
	fieldsPromotedPurchases                      *[]string
	fieldsInAppPurchaseLocalizations             *[]string
	fieldsInAppPurchases                         *[]string
	fieldsInAppPurchasePriceSchedules            *[]string
	fieldsInAppPurchaseContents                  *[]string
	limit                                        *int32
	limitInAppPurchaseLocalizations              *int32
	include                                      *[]string
}

// filter by attribute &#39;inAppPurchaseType&#39;
func (r ApiAppsInAppPurchasesV2GetToManyRelatedRequest) FilterInAppPurchaseType(filterInAppPurchaseType []string) ApiAppsInAppPurchasesV2GetToManyRelatedRequest {
	r.filterInAppPurchaseType = &filterInAppPurchaseType
	return r
}

// filter by attribute &#39;name&#39;
func (r ApiAppsInAppPurchasesV2GetToManyRelatedRequest) FilterName(filterName []string) ApiAppsInAppPurchasesV2GetToManyRelatedRequest {
	r.filterName = &filterName
	return r
}

// filter by attribute &#39;productId&#39;
func (r ApiAppsInAppPurchasesV2GetToManyRelatedRequest) FilterProductId(filterProductId []string) ApiAppsInAppPurchasesV2GetToManyRelatedRequest {
	r.filterProductId = &filterProductId
	return r
}

// filter by attribute &#39;state&#39;
func (r ApiAppsInAppPurchasesV2GetToManyRelatedRequest) FilterState(filterState []string) ApiAppsInAppPurchasesV2GetToManyRelatedRequest {
	r.filterState = &filterState
	return r
}

// comma-separated list of sort expressions; resources will be sorted as specified
func (r ApiAppsInAppPurchasesV2GetToManyRelatedRequest) Sort(sort []string) ApiAppsInAppPurchasesV2GetToManyRelatedRequest {
	r.sort = &sort
	return r
}

// the fields to include for returned resources of type inAppPurchaseAppStoreReviewScreenshots
func (r ApiAppsInAppPurchasesV2GetToManyRelatedRequest) FieldsInAppPurchaseAppStoreReviewScreenshots(fieldsInAppPurchaseAppStoreReviewScreenshots []string) ApiAppsInAppPurchasesV2GetToManyRelatedRequest {
	r.fieldsInAppPurchaseAppStoreReviewScreenshots = &fieldsInAppPurchaseAppStoreReviewScreenshots
	return r
}

// the fields to include for returned resources of type inAppPurchaseAvailabilities
func (r ApiAppsInAppPurchasesV2GetToManyRelatedRequest) FieldsInAppPurchaseAvailabilities(fieldsInAppPurchaseAvailabilities []string) ApiAppsInAppPurchasesV2GetToManyRelatedRequest {
	r.fieldsInAppPurchaseAvailabilities = &fieldsInAppPurchaseAvailabilities
	return r
}

// the fields to include for returned resources of type promotedPurchases
func (r ApiAppsInAppPurchasesV2GetToManyRelatedRequest) FieldsPromotedPurchases(fieldsPromotedPurchases []string) ApiAppsInAppPurchasesV2GetToManyRelatedRequest {
	r.fieldsPromotedPurchases = &fieldsPromotedPurchases
	return r
}

// the fields to include for returned resources of type inAppPurchaseLocalizations
func (r ApiAppsInAppPurchasesV2GetToManyRelatedRequest) FieldsInAppPurchaseLocalizations(fieldsInAppPurchaseLocalizations []string) ApiAppsInAppPurchasesV2GetToManyRelatedRequest {
	r.fieldsInAppPurchaseLocalizations = &fieldsInAppPurchaseLocalizations
	return r
}

// the fields to include for returned resources of type inAppPurchases
func (r ApiAppsInAppPurchasesV2GetToManyRelatedRequest) FieldsInAppPurchases(fieldsInAppPurchases []string) ApiAppsInAppPurchasesV2GetToManyRelatedRequest {
	r.fieldsInAppPurchases = &fieldsInAppPurchases
	return r
}

// the fields to include for returned resources of type inAppPurchasePriceSchedules
func (r ApiAppsInAppPurchasesV2GetToManyRelatedRequest) FieldsInAppPurchasePriceSchedules(fieldsInAppPurchasePriceSchedules []string) ApiAppsInAppPurchasesV2GetToManyRelatedRequest {
	r.fieldsInAppPurchasePriceSchedules = &fieldsInAppPurchasePriceSchedules
	return r
}

// the fields to include for returned resources of type inAppPurchaseContents
func (r ApiAppsInAppPurchasesV2GetToManyRelatedRequest) FieldsInAppPurchaseContents(fieldsInAppPurchaseContents []string) ApiAppsInAppPurchasesV2GetToManyRelatedRequest {
	r.fieldsInAppPurchaseContents = &fieldsInAppPurchaseContents
	return r
}

// maximum resources per page
func (r ApiAppsInAppPurchasesV2GetToManyRelatedRequest) Limit(limit int32) ApiAppsInAppPurchasesV2GetToManyRelatedRequest {
	r.limit = &limit
	return r
}

// maximum number of related inAppPurchaseLocalizations returned (when they are included)
func (r ApiAppsInAppPurchasesV2GetToManyRelatedRequest) LimitInAppPurchaseLocalizations(limitInAppPurchaseLocalizations int32) ApiAppsInAppPurchasesV2GetToManyRelatedRequest {
	r.limitInAppPurchaseLocalizations = &limitInAppPurchaseLocalizations
	return r
}

// comma-separated list of relationships to include
func (r ApiAppsInAppPurchasesV2GetToManyRelatedRequest) Include(include []string) ApiAppsInAppPurchasesV2GetToManyRelatedRequest {
	r.include = &include
	return r
}

func (r ApiAppsInAppPurchasesV2GetToManyRelatedRequest) Execute() (*InAppPurchasesV2Response, *http.Response, error) {
	return r.ApiService.AppsInAppPurchasesV2GetToManyRelatedExecute(r)
}

/*
AppsInAppPurchasesV2GetToManyRelated Method for AppsInAppPurchasesV2GetToManyRelated

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id the id of the requested resource
	@return ApiAppsInAppPurchasesV2GetToManyRelatedRequest
*/
func (a *AppsApiService) AppsInAppPurchasesV2GetToManyRelated(ctx context.Context, id string) ApiAppsInAppPurchasesV2GetToManyRelatedRequest {
	return ApiAppsInAppPurchasesV2GetToManyRelatedRequest{
		ApiService: a,
		ctx:        ctx,
		id:         id,
	}
}

// Execute executes the request
//
//	@return InAppPurchasesV2Response
func (a *AppsApiService) AppsInAppPurchasesV2GetToManyRelatedExecute(r ApiAppsInAppPurchasesV2GetToManyRelatedRequest) (*InAppPurchasesV2Response, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *InAppPurchasesV2Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AppsApiService.AppsInAppPurchasesV2GetToManyRelated")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/apps/{id}/inAppPurchasesV2"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.filterInAppPurchaseType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter[inAppPurchaseType]", r.filterInAppPurchaseType, "csv")
	}
	if r.filterName != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter[name]", r.filterName, "csv")
	}
	if r.filterProductId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter[productId]", r.filterProductId, "csv")
	}
	if r.filterState != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter[state]", r.filterState, "csv")
	}
	if r.sort != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "sort", r.sort, "csv")
	}
	if r.fieldsInAppPurchaseAppStoreReviewScreenshots != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields[inAppPurchaseAppStoreReviewScreenshots]", r.fieldsInAppPurchaseAppStoreReviewScreenshots, "csv")
	}
	if r.fieldsInAppPurchaseAvailabilities != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields[inAppPurchaseAvailabilities]", r.fieldsInAppPurchaseAvailabilities, "csv")
	}
	if r.fieldsPromotedPurchases != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields[promotedPurchases]", r.fieldsPromotedPurchases, "csv")
	}
	if r.fieldsInAppPurchaseLocalizations != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields[inAppPurchaseLocalizations]", r.fieldsInAppPurchaseLocalizations, "csv")
	}
	if r.fieldsInAppPurchases != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields[inAppPurchases]", r.fieldsInAppPurchases, "csv")
	}
	if r.fieldsInAppPurchasePriceSchedules != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields[inAppPurchasePriceSchedules]", r.fieldsInAppPurchasePriceSchedules, "csv")
	}
	if r.fieldsInAppPurchaseContents != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields[inAppPurchaseContents]", r.fieldsInAppPurchaseContents, "csv")
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "")
	}
	if r.limitInAppPurchaseLocalizations != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit[inAppPurchaseLocalizations]", r.limitInAppPurchaseLocalizations, "")
	}
	if r.include != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "include", r.include, "csv")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiAppsPerfPowerMetricsGetToManyRelatedRequest struct {
	ctx              context.Context
	ApiService       *AppsApiService
	id               string
	filterDeviceType *[]string
	filterMetricType *[]string
	filterPlatform   *[]string
}

// filter by attribute &#39;deviceType&#39;
func (r ApiAppsPerfPowerMetricsGetToManyRelatedRequest) FilterDeviceType(filterDeviceType []string) ApiAppsPerfPowerMetricsGetToManyRelatedRequest {
	r.filterDeviceType = &filterDeviceType
	return r
}

// filter by attribute &#39;metricType&#39;
func (r ApiAppsPerfPowerMetricsGetToManyRelatedRequest) FilterMetricType(filterMetricType []string) ApiAppsPerfPowerMetricsGetToManyRelatedRequest {
	r.filterMetricType = &filterMetricType
	return r
}

// filter by attribute &#39;platform&#39;
func (r ApiAppsPerfPowerMetricsGetToManyRelatedRequest) FilterPlatform(filterPlatform []string) ApiAppsPerfPowerMetricsGetToManyRelatedRequest {
	r.filterPlatform = &filterPlatform
	return r
}

func (r ApiAppsPerfPowerMetricsGetToManyRelatedRequest) Execute() (*XcodeMetrics, *http.Response, error) {
	return r.ApiService.AppsPerfPowerMetricsGetToManyRelatedExecute(r)
}

/*
AppsPerfPowerMetricsGetToManyRelated Method for AppsPerfPowerMetricsGetToManyRelated

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id the id of the requested resource
	@return ApiAppsPerfPowerMetricsGetToManyRelatedRequest
*/
func (a *AppsApiService) AppsPerfPowerMetricsGetToManyRelated(ctx context.Context, id string) ApiAppsPerfPowerMetricsGetToManyRelatedRequest {
	return ApiAppsPerfPowerMetricsGetToManyRelatedRequest{
		ApiService: a,
		ctx:        ctx,
		id:         id,
	}
}

// Execute executes the request
//
//	@return XcodeMetrics
func (a *AppsApiService) AppsPerfPowerMetricsGetToManyRelatedExecute(r ApiAppsPerfPowerMetricsGetToManyRelatedRequest) (*XcodeMetrics, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *XcodeMetrics
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AppsApiService.AppsPerfPowerMetricsGetToManyRelated")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/apps/{id}/perfPowerMetrics"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.filterDeviceType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter[deviceType]", r.filterDeviceType, "csv")
	}
	if r.filterMetricType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter[metricType]", r.filterMetricType, "csv")
	}
	if r.filterPlatform != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter[platform]", r.filterPlatform, "csv")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/vnd.apple.xcode-metrics+json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiAppsPreOrderGetToOneRelatedRequest struct {
	ctx                context.Context
	ApiService         *AppsApiService
	id                 string
	fieldsAppPreOrders *[]string
}

// the fields to include for returned resources of type appPreOrders
func (r ApiAppsPreOrderGetToOneRelatedRequest) FieldsAppPreOrders(fieldsAppPreOrders []string) ApiAppsPreOrderGetToOneRelatedRequest {
	r.fieldsAppPreOrders = &fieldsAppPreOrders
	return r
}

func (r ApiAppsPreOrderGetToOneRelatedRequest) Execute() (*AppPreOrderWithoutIncludesResponse, *http.Response, error) {
	return r.ApiService.AppsPreOrderGetToOneRelatedExecute(r)
}

/*
AppsPreOrderGetToOneRelated Method for AppsPreOrderGetToOneRelated

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id the id of the requested resource
	@return ApiAppsPreOrderGetToOneRelatedRequest
*/
func (a *AppsApiService) AppsPreOrderGetToOneRelated(ctx context.Context, id string) ApiAppsPreOrderGetToOneRelatedRequest {
	return ApiAppsPreOrderGetToOneRelatedRequest{
		ApiService: a,
		ctx:        ctx,
		id:         id,
	}
}

// Execute executes the request
//
//	@return AppPreOrderWithoutIncludesResponse
func (a *AppsApiService) AppsPreOrderGetToOneRelatedExecute(r ApiAppsPreOrderGetToOneRelatedRequest) (*AppPreOrderWithoutIncludesResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *AppPreOrderWithoutIncludesResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AppsApiService.AppsPreOrderGetToOneRelated")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/apps/{id}/preOrder"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.fieldsAppPreOrders != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields[appPreOrders]", r.fieldsAppPreOrders, "csv")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiAppsPreReleaseVersionsGetToManyRelatedRequest struct {
	ctx                      context.Context
	ApiService               *AppsApiService
	id                       string
	fieldsPreReleaseVersions *[]string
	limit                    *int32
}

// the fields to include for returned resources of type preReleaseVersions
func (r ApiAppsPreReleaseVersionsGetToManyRelatedRequest) FieldsPreReleaseVersions(fieldsPreReleaseVersions []string) ApiAppsPreReleaseVersionsGetToManyRelatedRequest {
	r.fieldsPreReleaseVersions = &fieldsPreReleaseVersions
	return r
}

// maximum resources per page
func (r ApiAppsPreReleaseVersionsGetToManyRelatedRequest) Limit(limit int32) ApiAppsPreReleaseVersionsGetToManyRelatedRequest {
	r.limit = &limit
	return r
}

func (r ApiAppsPreReleaseVersionsGetToManyRelatedRequest) Execute() (*PreReleaseVersionsWithoutIncludesResponse, *http.Response, error) {
	return r.ApiService.AppsPreReleaseVersionsGetToManyRelatedExecute(r)
}

/*
AppsPreReleaseVersionsGetToManyRelated Method for AppsPreReleaseVersionsGetToManyRelated

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id the id of the requested resource
	@return ApiAppsPreReleaseVersionsGetToManyRelatedRequest
*/
func (a *AppsApiService) AppsPreReleaseVersionsGetToManyRelated(ctx context.Context, id string) ApiAppsPreReleaseVersionsGetToManyRelatedRequest {
	return ApiAppsPreReleaseVersionsGetToManyRelatedRequest{
		ApiService: a,
		ctx:        ctx,
		id:         id,
	}
}

// Execute executes the request
//
//	@return PreReleaseVersionsWithoutIncludesResponse
func (a *AppsApiService) AppsPreReleaseVersionsGetToManyRelatedExecute(r ApiAppsPreReleaseVersionsGetToManyRelatedRequest) (*PreReleaseVersionsWithoutIncludesResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *PreReleaseVersionsWithoutIncludesResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AppsApiService.AppsPreReleaseVersionsGetToManyRelated")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/apps/{id}/preReleaseVersions"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.fieldsPreReleaseVersions != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields[preReleaseVersions]", r.fieldsPreReleaseVersions, "csv")
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiAppsPricePointsGetToManyRelatedRequest struct {
	ctx                  context.Context
	ApiService           *AppsApiService
	id                   string
	filterPriceTier      *[]string
	filterTerritory      *[]string
	fieldsAppPriceTiers  *[]string
	fieldsAppPricePoints *[]string
	fieldsApps           *[]string
	fieldsTerritories    *[]string
	limit                *int32
	include              *[]string
}

// filter by id(s) of related &#39;priceTier&#39;
// Deprecated
func (r ApiAppsPricePointsGetToManyRelatedRequest) FilterPriceTier(filterPriceTier []string) ApiAppsPricePointsGetToManyRelatedRequest {
	r.filterPriceTier = &filterPriceTier
	return r
}

// filter by id(s) of related &#39;territory&#39;
func (r ApiAppsPricePointsGetToManyRelatedRequest) FilterTerritory(filterTerritory []string) ApiAppsPricePointsGetToManyRelatedRequest {
	r.filterTerritory = &filterTerritory
	return r
}

// the fields to include for returned resources of type appPriceTiers
func (r ApiAppsPricePointsGetToManyRelatedRequest) FieldsAppPriceTiers(fieldsAppPriceTiers []string) ApiAppsPricePointsGetToManyRelatedRequest {
	r.fieldsAppPriceTiers = &fieldsAppPriceTiers
	return r
}

// the fields to include for returned resources of type appPricePoints
func (r ApiAppsPricePointsGetToManyRelatedRequest) FieldsAppPricePoints(fieldsAppPricePoints []string) ApiAppsPricePointsGetToManyRelatedRequest {
	r.fieldsAppPricePoints = &fieldsAppPricePoints
	return r
}

// the fields to include for returned resources of type apps
func (r ApiAppsPricePointsGetToManyRelatedRequest) FieldsApps(fieldsApps []string) ApiAppsPricePointsGetToManyRelatedRequest {
	r.fieldsApps = &fieldsApps
	return r
}

// the fields to include for returned resources of type territories
func (r ApiAppsPricePointsGetToManyRelatedRequest) FieldsTerritories(fieldsTerritories []string) ApiAppsPricePointsGetToManyRelatedRequest {
	r.fieldsTerritories = &fieldsTerritories
	return r
}

// maximum resources per page
func (r ApiAppsPricePointsGetToManyRelatedRequest) Limit(limit int32) ApiAppsPricePointsGetToManyRelatedRequest {
	r.limit = &limit
	return r
}

// comma-separated list of relationships to include
func (r ApiAppsPricePointsGetToManyRelatedRequest) Include(include []string) ApiAppsPricePointsGetToManyRelatedRequest {
	r.include = &include
	return r
}

func (r ApiAppsPricePointsGetToManyRelatedRequest) Execute() (*AppPricePointsV2Response, *http.Response, error) {
	return r.ApiService.AppsPricePointsGetToManyRelatedExecute(r)
}

/*
AppsPricePointsGetToManyRelated Method for AppsPricePointsGetToManyRelated

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id the id of the requested resource
	@return ApiAppsPricePointsGetToManyRelatedRequest

Deprecated
*/
func (a *AppsApiService) AppsPricePointsGetToManyRelated(ctx context.Context, id string) ApiAppsPricePointsGetToManyRelatedRequest {
	return ApiAppsPricePointsGetToManyRelatedRequest{
		ApiService: a,
		ctx:        ctx,
		id:         id,
	}
}

// Execute executes the request
//
//	@return AppPricePointsV2Response
//
// Deprecated
func (a *AppsApiService) AppsPricePointsGetToManyRelatedExecute(r ApiAppsPricePointsGetToManyRelatedRequest) (*AppPricePointsV2Response, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *AppPricePointsV2Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AppsApiService.AppsPricePointsGetToManyRelated")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/apps/{id}/pricePoints"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.filterPriceTier != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter[priceTier]", r.filterPriceTier, "csv")
	}
	if r.filterTerritory != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter[territory]", r.filterTerritory, "csv")
	}
	if r.fieldsAppPriceTiers != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields[appPriceTiers]", r.fieldsAppPriceTiers, "csv")
	}
	if r.fieldsAppPricePoints != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields[appPricePoints]", r.fieldsAppPricePoints, "csv")
	}
	if r.fieldsApps != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields[apps]", r.fieldsApps, "csv")
	}
	if r.fieldsTerritories != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields[territories]", r.fieldsTerritories, "csv")
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "")
	}
	if r.include != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "include", r.include, "csv")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiAppsPricesGetToManyRelatedRequest struct {
	ctx                 context.Context
	ApiService          *AppsApiService
	id                  string
	fieldsAppPriceTiers *[]string
	fieldsApps          *[]string
	fieldsAppPrices     *[]string
	limit               *int32
	include             *[]string
}

// the fields to include for returned resources of type appPriceTiers
func (r ApiAppsPricesGetToManyRelatedRequest) FieldsAppPriceTiers(fieldsAppPriceTiers []string) ApiAppsPricesGetToManyRelatedRequest {
	r.fieldsAppPriceTiers = &fieldsAppPriceTiers
	return r
}

// the fields to include for returned resources of type apps
func (r ApiAppsPricesGetToManyRelatedRequest) FieldsApps(fieldsApps []string) ApiAppsPricesGetToManyRelatedRequest {
	r.fieldsApps = &fieldsApps
	return r
}

// the fields to include for returned resources of type appPrices
func (r ApiAppsPricesGetToManyRelatedRequest) FieldsAppPrices(fieldsAppPrices []string) ApiAppsPricesGetToManyRelatedRequest {
	r.fieldsAppPrices = &fieldsAppPrices
	return r
}

// maximum resources per page
func (r ApiAppsPricesGetToManyRelatedRequest) Limit(limit int32) ApiAppsPricesGetToManyRelatedRequest {
	r.limit = &limit
	return r
}

// comma-separated list of relationships to include
func (r ApiAppsPricesGetToManyRelatedRequest) Include(include []string) ApiAppsPricesGetToManyRelatedRequest {
	r.include = &include
	return r
}

func (r ApiAppsPricesGetToManyRelatedRequest) Execute() (*AppPricesResponse, *http.Response, error) {
	return r.ApiService.AppsPricesGetToManyRelatedExecute(r)
}

/*
AppsPricesGetToManyRelated Method for AppsPricesGetToManyRelated

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id the id of the requested resource
	@return ApiAppsPricesGetToManyRelatedRequest

Deprecated
*/
func (a *AppsApiService) AppsPricesGetToManyRelated(ctx context.Context, id string) ApiAppsPricesGetToManyRelatedRequest {
	return ApiAppsPricesGetToManyRelatedRequest{
		ApiService: a,
		ctx:        ctx,
		id:         id,
	}
}

// Execute executes the request
//
//	@return AppPricesResponse
//
// Deprecated
func (a *AppsApiService) AppsPricesGetToManyRelatedExecute(r ApiAppsPricesGetToManyRelatedRequest) (*AppPricesResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *AppPricesResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AppsApiService.AppsPricesGetToManyRelated")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/apps/{id}/prices"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.fieldsAppPriceTiers != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields[appPriceTiers]", r.fieldsAppPriceTiers, "csv")
	}
	if r.fieldsApps != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields[apps]", r.fieldsApps, "csv")
	}
	if r.fieldsAppPrices != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields[appPrices]", r.fieldsAppPrices, "csv")
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "")
	}
	if r.include != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "include", r.include, "csv")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiAppsPromotedPurchasesGetToManyRelatedRequest struct {
	ctx                          context.Context
	ApiService                   *AppsApiService
	id                           string
	fieldsPromotedPurchases      *[]string
	fieldsSubscriptions          *[]string
	fieldsInAppPurchases         *[]string
	fieldsPromotedPurchaseImages *[]string
	limit                        *int32
	limitPromotionImages         *int32
	include                      *[]string
}

// the fields to include for returned resources of type promotedPurchases
func (r ApiAppsPromotedPurchasesGetToManyRelatedRequest) FieldsPromotedPurchases(fieldsPromotedPurchases []string) ApiAppsPromotedPurchasesGetToManyRelatedRequest {
	r.fieldsPromotedPurchases = &fieldsPromotedPurchases
	return r
}

// the fields to include for returned resources of type subscriptions
func (r ApiAppsPromotedPurchasesGetToManyRelatedRequest) FieldsSubscriptions(fieldsSubscriptions []string) ApiAppsPromotedPurchasesGetToManyRelatedRequest {
	r.fieldsSubscriptions = &fieldsSubscriptions
	return r
}

// the fields to include for returned resources of type inAppPurchases
func (r ApiAppsPromotedPurchasesGetToManyRelatedRequest) FieldsInAppPurchases(fieldsInAppPurchases []string) ApiAppsPromotedPurchasesGetToManyRelatedRequest {
	r.fieldsInAppPurchases = &fieldsInAppPurchases
	return r
}

// the fields to include for returned resources of type promotedPurchaseImages
func (r ApiAppsPromotedPurchasesGetToManyRelatedRequest) FieldsPromotedPurchaseImages(fieldsPromotedPurchaseImages []string) ApiAppsPromotedPurchasesGetToManyRelatedRequest {
	r.fieldsPromotedPurchaseImages = &fieldsPromotedPurchaseImages
	return r
}

// maximum resources per page
func (r ApiAppsPromotedPurchasesGetToManyRelatedRequest) Limit(limit int32) ApiAppsPromotedPurchasesGetToManyRelatedRequest {
	r.limit = &limit
	return r
}

// maximum number of related promotionImages returned (when they are included)
func (r ApiAppsPromotedPurchasesGetToManyRelatedRequest) LimitPromotionImages(limitPromotionImages int32) ApiAppsPromotedPurchasesGetToManyRelatedRequest {
	r.limitPromotionImages = &limitPromotionImages
	return r
}

// comma-separated list of relationships to include
func (r ApiAppsPromotedPurchasesGetToManyRelatedRequest) Include(include []string) ApiAppsPromotedPurchasesGetToManyRelatedRequest {
	r.include = &include
	return r
}

func (r ApiAppsPromotedPurchasesGetToManyRelatedRequest) Execute() (*PromotedPurchasesResponse, *http.Response, error) {
	return r.ApiService.AppsPromotedPurchasesGetToManyRelatedExecute(r)
}

/*
AppsPromotedPurchasesGetToManyRelated Method for AppsPromotedPurchasesGetToManyRelated

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id the id of the requested resource
	@return ApiAppsPromotedPurchasesGetToManyRelatedRequest
*/
func (a *AppsApiService) AppsPromotedPurchasesGetToManyRelated(ctx context.Context, id string) ApiAppsPromotedPurchasesGetToManyRelatedRequest {
	return ApiAppsPromotedPurchasesGetToManyRelatedRequest{
		ApiService: a,
		ctx:        ctx,
		id:         id,
	}
}

// Execute executes the request
//
//	@return PromotedPurchasesResponse
func (a *AppsApiService) AppsPromotedPurchasesGetToManyRelatedExecute(r ApiAppsPromotedPurchasesGetToManyRelatedRequest) (*PromotedPurchasesResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *PromotedPurchasesResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AppsApiService.AppsPromotedPurchasesGetToManyRelated")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/apps/{id}/promotedPurchases"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.fieldsPromotedPurchases != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields[promotedPurchases]", r.fieldsPromotedPurchases, "csv")
	}
	if r.fieldsSubscriptions != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields[subscriptions]", r.fieldsSubscriptions, "csv")
	}
	if r.fieldsInAppPurchases != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields[inAppPurchases]", r.fieldsInAppPurchases, "csv")
	}
	if r.fieldsPromotedPurchaseImages != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields[promotedPurchaseImages]", r.fieldsPromotedPurchaseImages, "csv")
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "")
	}
	if r.limitPromotionImages != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit[promotionImages]", r.limitPromotionImages, "")
	}
	if r.include != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "include", r.include, "csv")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiAppsPromotedPurchasesGetToManyRelationshipRequest struct {
	ctx        context.Context
	ApiService *AppsApiService
	id         string
	limit      *int32
}

// maximum resources per page
func (r ApiAppsPromotedPurchasesGetToManyRelationshipRequest) Limit(limit int32) ApiAppsPromotedPurchasesGetToManyRelationshipRequest {
	r.limit = &limit
	return r
}

func (r ApiAppsPromotedPurchasesGetToManyRelationshipRequest) Execute() (*AppPromotedPurchasesLinkagesResponse, *http.Response, error) {
	return r.ApiService.AppsPromotedPurchasesGetToManyRelationshipExecute(r)
}

/*
AppsPromotedPurchasesGetToManyRelationship Method for AppsPromotedPurchasesGetToManyRelationship

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id the id of the requested resource
	@return ApiAppsPromotedPurchasesGetToManyRelationshipRequest
*/
func (a *AppsApiService) AppsPromotedPurchasesGetToManyRelationship(ctx context.Context, id string) ApiAppsPromotedPurchasesGetToManyRelationshipRequest {
	return ApiAppsPromotedPurchasesGetToManyRelationshipRequest{
		ApiService: a,
		ctx:        ctx,
		id:         id,
	}
}

// Execute executes the request
//
//	@return AppPromotedPurchasesLinkagesResponse
func (a *AppsApiService) AppsPromotedPurchasesGetToManyRelationshipExecute(r ApiAppsPromotedPurchasesGetToManyRelationshipRequest) (*AppPromotedPurchasesLinkagesResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *AppPromotedPurchasesLinkagesResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AppsApiService.AppsPromotedPurchasesGetToManyRelationship")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/apps/{id}/relationships/promotedPurchases"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiAppsPromotedPurchasesReplaceToManyRelationshipRequest struct {
	ctx                                 context.Context
	ApiService                          *AppsApiService
	id                                  string
	appPromotedPurchasesLinkagesRequest *AppPromotedPurchasesLinkagesRequest
}

// List of related linkages
func (r ApiAppsPromotedPurchasesReplaceToManyRelationshipRequest) AppPromotedPurchasesLinkagesRequest(appPromotedPurchasesLinkagesRequest AppPromotedPurchasesLinkagesRequest) ApiAppsPromotedPurchasesReplaceToManyRelationshipRequest {
	r.appPromotedPurchasesLinkagesRequest = &appPromotedPurchasesLinkagesRequest
	return r
}

func (r ApiAppsPromotedPurchasesReplaceToManyRelationshipRequest) Execute() (*http.Response, error) {
	return r.ApiService.AppsPromotedPurchasesReplaceToManyRelationshipExecute(r)
}

/*
AppsPromotedPurchasesReplaceToManyRelationship Method for AppsPromotedPurchasesReplaceToManyRelationship

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id the id of the requested resource
	@return ApiAppsPromotedPurchasesReplaceToManyRelationshipRequest
*/
func (a *AppsApiService) AppsPromotedPurchasesReplaceToManyRelationship(ctx context.Context, id string) ApiAppsPromotedPurchasesReplaceToManyRelationshipRequest {
	return ApiAppsPromotedPurchasesReplaceToManyRelationshipRequest{
		ApiService: a,
		ctx:        ctx,
		id:         id,
	}
}

// Execute executes the request
func (a *AppsApiService) AppsPromotedPurchasesReplaceToManyRelationshipExecute(r ApiAppsPromotedPurchasesReplaceToManyRelationshipRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodPatch
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AppsApiService.AppsPromotedPurchasesReplaceToManyRelationship")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/apps/{id}/relationships/promotedPurchases"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.appPromotedPurchasesLinkagesRequest == nil {
		return nil, reportError("appPromotedPurchasesLinkagesRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.appPromotedPurchasesLinkagesRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 409 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiAppsReviewSubmissionsGetToManyRelatedRequest struct {
	ctx                         context.Context
	ApiService                  *AppsApiService
	id                          string
	filterPlatform              *[]string
	filterState                 *[]string
	fieldsReviewSubmissionItems *[]string
	fieldsActors                *[]string
	fieldsAppStoreVersions      *[]string
	fieldsApps                  *[]string
	fieldsReviewSubmissions     *[]string
	limit                       *int32
	limitItems                  *int32
	include                     *[]string
}

// filter by attribute &#39;platform&#39;
func (r ApiAppsReviewSubmissionsGetToManyRelatedRequest) FilterPlatform(filterPlatform []string) ApiAppsReviewSubmissionsGetToManyRelatedRequest {
	r.filterPlatform = &filterPlatform
	return r
}

// filter by attribute &#39;state&#39;
func (r ApiAppsReviewSubmissionsGetToManyRelatedRequest) FilterState(filterState []string) ApiAppsReviewSubmissionsGetToManyRelatedRequest {
	r.filterState = &filterState
	return r
}

// the fields to include for returned resources of type reviewSubmissionItems
func (r ApiAppsReviewSubmissionsGetToManyRelatedRequest) FieldsReviewSubmissionItems(fieldsReviewSubmissionItems []string) ApiAppsReviewSubmissionsGetToManyRelatedRequest {
	r.fieldsReviewSubmissionItems = &fieldsReviewSubmissionItems
	return r
}

// the fields to include for returned resources of type actors
func (r ApiAppsReviewSubmissionsGetToManyRelatedRequest) FieldsActors(fieldsActors []string) ApiAppsReviewSubmissionsGetToManyRelatedRequest {
	r.fieldsActors = &fieldsActors
	return r
}

// the fields to include for returned resources of type appStoreVersions
func (r ApiAppsReviewSubmissionsGetToManyRelatedRequest) FieldsAppStoreVersions(fieldsAppStoreVersions []string) ApiAppsReviewSubmissionsGetToManyRelatedRequest {
	r.fieldsAppStoreVersions = &fieldsAppStoreVersions
	return r
}

// the fields to include for returned resources of type apps
func (r ApiAppsReviewSubmissionsGetToManyRelatedRequest) FieldsApps(fieldsApps []string) ApiAppsReviewSubmissionsGetToManyRelatedRequest {
	r.fieldsApps = &fieldsApps
	return r
}

// the fields to include for returned resources of type reviewSubmissions
func (r ApiAppsReviewSubmissionsGetToManyRelatedRequest) FieldsReviewSubmissions(fieldsReviewSubmissions []string) ApiAppsReviewSubmissionsGetToManyRelatedRequest {
	r.fieldsReviewSubmissions = &fieldsReviewSubmissions
	return r
}

// maximum resources per page
func (r ApiAppsReviewSubmissionsGetToManyRelatedRequest) Limit(limit int32) ApiAppsReviewSubmissionsGetToManyRelatedRequest {
	r.limit = &limit
	return r
}

// maximum number of related items returned (when they are included)
func (r ApiAppsReviewSubmissionsGetToManyRelatedRequest) LimitItems(limitItems int32) ApiAppsReviewSubmissionsGetToManyRelatedRequest {
	r.limitItems = &limitItems
	return r
}

// comma-separated list of relationships to include
func (r ApiAppsReviewSubmissionsGetToManyRelatedRequest) Include(include []string) ApiAppsReviewSubmissionsGetToManyRelatedRequest {
	r.include = &include
	return r
}

func (r ApiAppsReviewSubmissionsGetToManyRelatedRequest) Execute() (*ReviewSubmissionsResponse, *http.Response, error) {
	return r.ApiService.AppsReviewSubmissionsGetToManyRelatedExecute(r)
}

/*
AppsReviewSubmissionsGetToManyRelated Method for AppsReviewSubmissionsGetToManyRelated

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id the id of the requested resource
	@return ApiAppsReviewSubmissionsGetToManyRelatedRequest
*/
func (a *AppsApiService) AppsReviewSubmissionsGetToManyRelated(ctx context.Context, id string) ApiAppsReviewSubmissionsGetToManyRelatedRequest {
	return ApiAppsReviewSubmissionsGetToManyRelatedRequest{
		ApiService: a,
		ctx:        ctx,
		id:         id,
	}
}

// Execute executes the request
//
//	@return ReviewSubmissionsResponse
func (a *AppsApiService) AppsReviewSubmissionsGetToManyRelatedExecute(r ApiAppsReviewSubmissionsGetToManyRelatedRequest) (*ReviewSubmissionsResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *ReviewSubmissionsResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AppsApiService.AppsReviewSubmissionsGetToManyRelated")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/apps/{id}/reviewSubmissions"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.filterPlatform != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter[platform]", r.filterPlatform, "csv")
	}
	if r.filterState != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter[state]", r.filterState, "csv")
	}
	if r.fieldsReviewSubmissionItems != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields[reviewSubmissionItems]", r.fieldsReviewSubmissionItems, "csv")
	}
	if r.fieldsActors != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields[actors]", r.fieldsActors, "csv")
	}
	if r.fieldsAppStoreVersions != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields[appStoreVersions]", r.fieldsAppStoreVersions, "csv")
	}
	if r.fieldsApps != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields[apps]", r.fieldsApps, "csv")
	}
	if r.fieldsReviewSubmissions != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields[reviewSubmissions]", r.fieldsReviewSubmissions, "csv")
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "")
	}
	if r.limitItems != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit[items]", r.limitItems, "")
	}
	if r.include != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "include", r.include, "csv")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiAppsSubscriptionGracePeriodGetToOneRelatedRequest struct {
	ctx                            context.Context
	ApiService                     *AppsApiService
	id                             string
	fieldsSubscriptionGracePeriods *[]string
}

// the fields to include for returned resources of type subscriptionGracePeriods
func (r ApiAppsSubscriptionGracePeriodGetToOneRelatedRequest) FieldsSubscriptionGracePeriods(fieldsSubscriptionGracePeriods []string) ApiAppsSubscriptionGracePeriodGetToOneRelatedRequest {
	r.fieldsSubscriptionGracePeriods = &fieldsSubscriptionGracePeriods
	return r
}

func (r ApiAppsSubscriptionGracePeriodGetToOneRelatedRequest) Execute() (*SubscriptionGracePeriodResponse, *http.Response, error) {
	return r.ApiService.AppsSubscriptionGracePeriodGetToOneRelatedExecute(r)
}

/*
AppsSubscriptionGracePeriodGetToOneRelated Method for AppsSubscriptionGracePeriodGetToOneRelated

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id the id of the requested resource
	@return ApiAppsSubscriptionGracePeriodGetToOneRelatedRequest
*/
func (a *AppsApiService) AppsSubscriptionGracePeriodGetToOneRelated(ctx context.Context, id string) ApiAppsSubscriptionGracePeriodGetToOneRelatedRequest {
	return ApiAppsSubscriptionGracePeriodGetToOneRelatedRequest{
		ApiService: a,
		ctx:        ctx,
		id:         id,
	}
}

// Execute executes the request
//
//	@return SubscriptionGracePeriodResponse
func (a *AppsApiService) AppsSubscriptionGracePeriodGetToOneRelatedExecute(r ApiAppsSubscriptionGracePeriodGetToOneRelatedRequest) (*SubscriptionGracePeriodResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *SubscriptionGracePeriodResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AppsApiService.AppsSubscriptionGracePeriodGetToOneRelated")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/apps/{id}/subscriptionGracePeriod"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.fieldsSubscriptionGracePeriods != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields[subscriptionGracePeriods]", r.fieldsSubscriptionGracePeriods, "csv")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiAppsSubscriptionGroupsGetToManyRelatedRequest struct {
	ctx                                  context.Context
	ApiService                           *AppsApiService
	id                                   string
	filterReferenceName                  *[]string
	filterSubscriptionsState             *[]string
	sort                                 *[]string
	fieldsSubscriptions                  *[]string
	fieldsSubscriptionGroups             *[]string
	fieldsSubscriptionGroupLocalizations *[]string
	limit                                *int32
	limitSubscriptions                   *int32
	limitSubscriptionGroupLocalizations  *int32
	include                              *[]string
}

// filter by attribute &#39;referenceName&#39;
func (r ApiAppsSubscriptionGroupsGetToManyRelatedRequest) FilterReferenceName(filterReferenceName []string) ApiAppsSubscriptionGroupsGetToManyRelatedRequest {
	r.filterReferenceName = &filterReferenceName
	return r
}

// filter by attribute &#39;subscriptions.state&#39;
func (r ApiAppsSubscriptionGroupsGetToManyRelatedRequest) FilterSubscriptionsState(filterSubscriptionsState []string) ApiAppsSubscriptionGroupsGetToManyRelatedRequest {
	r.filterSubscriptionsState = &filterSubscriptionsState
	return r
}

// comma-separated list of sort expressions; resources will be sorted as specified
func (r ApiAppsSubscriptionGroupsGetToManyRelatedRequest) Sort(sort []string) ApiAppsSubscriptionGroupsGetToManyRelatedRequest {
	r.sort = &sort
	return r
}

// the fields to include for returned resources of type subscriptions
func (r ApiAppsSubscriptionGroupsGetToManyRelatedRequest) FieldsSubscriptions(fieldsSubscriptions []string) ApiAppsSubscriptionGroupsGetToManyRelatedRequest {
	r.fieldsSubscriptions = &fieldsSubscriptions
	return r
}

// the fields to include for returned resources of type subscriptionGroups
func (r ApiAppsSubscriptionGroupsGetToManyRelatedRequest) FieldsSubscriptionGroups(fieldsSubscriptionGroups []string) ApiAppsSubscriptionGroupsGetToManyRelatedRequest {
	r.fieldsSubscriptionGroups = &fieldsSubscriptionGroups
	return r
}

// the fields to include for returned resources of type subscriptionGroupLocalizations
func (r ApiAppsSubscriptionGroupsGetToManyRelatedRequest) FieldsSubscriptionGroupLocalizations(fieldsSubscriptionGroupLocalizations []string) ApiAppsSubscriptionGroupsGetToManyRelatedRequest {
	r.fieldsSubscriptionGroupLocalizations = &fieldsSubscriptionGroupLocalizations
	return r
}

// maximum resources per page
func (r ApiAppsSubscriptionGroupsGetToManyRelatedRequest) Limit(limit int32) ApiAppsSubscriptionGroupsGetToManyRelatedRequest {
	r.limit = &limit
	return r
}

// maximum number of related subscriptions returned (when they are included)
func (r ApiAppsSubscriptionGroupsGetToManyRelatedRequest) LimitSubscriptions(limitSubscriptions int32) ApiAppsSubscriptionGroupsGetToManyRelatedRequest {
	r.limitSubscriptions = &limitSubscriptions
	return r
}

// maximum number of related subscriptionGroupLocalizations returned (when they are included)
func (r ApiAppsSubscriptionGroupsGetToManyRelatedRequest) LimitSubscriptionGroupLocalizations(limitSubscriptionGroupLocalizations int32) ApiAppsSubscriptionGroupsGetToManyRelatedRequest {
	r.limitSubscriptionGroupLocalizations = &limitSubscriptionGroupLocalizations
	return r
}

// comma-separated list of relationships to include
func (r ApiAppsSubscriptionGroupsGetToManyRelatedRequest) Include(include []string) ApiAppsSubscriptionGroupsGetToManyRelatedRequest {
	r.include = &include
	return r
}

func (r ApiAppsSubscriptionGroupsGetToManyRelatedRequest) Execute() (*SubscriptionGroupsResponse, *http.Response, error) {
	return r.ApiService.AppsSubscriptionGroupsGetToManyRelatedExecute(r)
}

/*
AppsSubscriptionGroupsGetToManyRelated Method for AppsSubscriptionGroupsGetToManyRelated

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id the id of the requested resource
	@return ApiAppsSubscriptionGroupsGetToManyRelatedRequest
*/
func (a *AppsApiService) AppsSubscriptionGroupsGetToManyRelated(ctx context.Context, id string) ApiAppsSubscriptionGroupsGetToManyRelatedRequest {
	return ApiAppsSubscriptionGroupsGetToManyRelatedRequest{
		ApiService: a,
		ctx:        ctx,
		id:         id,
	}
}

// Execute executes the request
//
//	@return SubscriptionGroupsResponse
func (a *AppsApiService) AppsSubscriptionGroupsGetToManyRelatedExecute(r ApiAppsSubscriptionGroupsGetToManyRelatedRequest) (*SubscriptionGroupsResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *SubscriptionGroupsResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AppsApiService.AppsSubscriptionGroupsGetToManyRelated")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/apps/{id}/subscriptionGroups"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.filterReferenceName != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter[referenceName]", r.filterReferenceName, "csv")
	}
	if r.filterSubscriptionsState != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter[subscriptions.state]", r.filterSubscriptionsState, "csv")
	}
	if r.sort != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "sort", r.sort, "csv")
	}
	if r.fieldsSubscriptions != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields[subscriptions]", r.fieldsSubscriptions, "csv")
	}
	if r.fieldsSubscriptionGroups != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields[subscriptionGroups]", r.fieldsSubscriptionGroups, "csv")
	}
	if r.fieldsSubscriptionGroupLocalizations != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields[subscriptionGroupLocalizations]", r.fieldsSubscriptionGroupLocalizations, "csv")
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "")
	}
	if r.limitSubscriptions != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit[subscriptions]", r.limitSubscriptions, "")
	}
	if r.limitSubscriptionGroupLocalizations != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit[subscriptionGroupLocalizations]", r.limitSubscriptionGroupLocalizations, "")
	}
	if r.include != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "include", r.include, "csv")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiAppsUpdateInstanceRequest struct {
	ctx              context.Context
	ApiService       *AppsApiService
	id               string
	appUpdateRequest *AppUpdateRequest
}

// App representation
func (r ApiAppsUpdateInstanceRequest) AppUpdateRequest(appUpdateRequest AppUpdateRequest) ApiAppsUpdateInstanceRequest {
	r.appUpdateRequest = &appUpdateRequest
	return r
}

func (r ApiAppsUpdateInstanceRequest) Execute() (*AppResponse, *http.Response, error) {
	return r.ApiService.AppsUpdateInstanceExecute(r)
}

/*
AppsUpdateInstance Method for AppsUpdateInstance

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id the id of the requested resource
	@return ApiAppsUpdateInstanceRequest
*/
func (a *AppsApiService) AppsUpdateInstance(ctx context.Context, id string) ApiAppsUpdateInstanceRequest {
	return ApiAppsUpdateInstanceRequest{
		ApiService: a,
		ctx:        ctx,
		id:         id,
	}
}

// Execute executes the request
//
//	@return AppResponse
func (a *AppsApiService) AppsUpdateInstanceExecute(r ApiAppsUpdateInstanceRequest) (*AppResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPatch
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *AppResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AppsApiService.AppsUpdateInstance")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/apps/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.appUpdateRequest == nil {
		return localVarReturnValue, nil, reportError("appUpdateRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.appUpdateRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 409 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
